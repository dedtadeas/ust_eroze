import{AE as e,Bx as t,CD as n,MC as r,_E as i,kC as a,vC as o,vE as s}from"./index-BqmCqmfp.js";import{s as c}from"./pixelRangeUtils-DMjHgTK0.js";var l=class{constructor(e=null,t=null,n=null){this.minValue=e,this.maxValue=t,this.noDataValue=n}},u,d=u=class extends o{static createEmptyBand(e,t){return new(u.getPixelArrayConstructor(e))(t)}static combineBandMasks(e){if(e.length<2)return e[0];let t=e[0].length,n=new Uint8Array(t).fill(255);for(let r=0;r<e.length;r++){let i=e[r];for(let e=0;e<t;e++)i[e]||(n[e]=0)}return n}static getPixelArrayConstructor(e){let t;switch(e){case`u1`:case`u2`:case`u4`:case`u8`:t=Uint8Array;break;case`u16`:t=Uint16Array;break;case`u32`:t=Uint32Array;break;case`s8`:t=Int8Array;break;case`s16`:t=Int16Array;break;case`s32`:t=Int32Array;break;case`f32`:case`c64`:case`c128`:case`unknown`:t=Float32Array;break;case`f64`:t=Float64Array}return t}constructor(e){super(e),this.width=null,this.height=null,this.pixelType=`f32`,this.validPixelCount=null,this.mask=null,this.maskIsAlpha=!1,this.premultiplyAlpha=!1,this.statistics=null,this.depthCount=1}castPixelType(e){if(!e)return`f32`;let t=e.toLowerCase();return[`u1`,`u2`,`u4`].includes(t)?t=`u8`:[`unknown`,`u8`,`s8`,`u16`,`s16`,`u32`,`s32`,`f32`,`f64`].includes(t)||(t=`f32`),t}getPlaneCount(){return this.pixels?.length}addData(e){if(!e.pixels||e.pixels.length!==this.width*this.height)throw new i(`pixelblock:invalid-or-missing-pixels`,`add data requires valid pixels array that has same length defined by pixel block width * height`);this.pixels||=[],this.statistics||=[],this.pixels.push(e.pixels),this.statistics.push(e.statistics??new l)}getAsRGBA(){let e=new ArrayBuffer(this.width*this.height*4);switch(this.pixelType){case`s8`:case`s16`:case`u16`:case`s32`:case`u32`:case`f32`:case`f64`:this._fillFromNon8Bit(e);break;default:this._fillFrom8Bit(e)}return new Uint8ClampedArray(e)}getAsRGBAFloat(){let e=new Float32Array(this.width*this.height*4);return this._fillFrom32Bit(e),e}updateStatistics(){if(!this.pixels)return;this.statistics=this.pixels.map(e=>f(e,this.mask));let e=this.mask,t=0;if(e!=null)for(let n=0;n<e.length;n++)e[n]&&t++;else t=this.width*this.height;this.validPixelCount=t}clamp(e){if(!e||e===`f64`||e===`f32`||!this.pixels)return;let[t,n]=c(e),r=this.pixels,i=this.width*this.height,a=r.length,o,s,l,d=[];for(let c=0;c<a;c++){l=u.createEmptyBand(e,i),o=r[c];for(let e=0;e<i;e++)s=o[e],l[e]=s>n?n:s<t?t:s;d.push(l)}this.pixels=d,this.pixelType=e}extractBands(e){let{pixels:t,statistics:n}=this;if(e==null||e.length===0||!t||t.length===0)return this;let r=t.length,i=e.some(e=>e>=t.length),a=r===e.length&&!e.some((e,t)=>e!==t);if(i||a)return this;let o=this.bandMasks?.length===r?e.map(e=>this.bandMasks[e]):void 0,{mask:s,validPixelCount:c}=this,{width:l,height:d}=this;return o?.length&&(s=u.combineBandMasks(o),c=s.filter(e=>!!e).length),new u({pixelType:this.pixelType,width:l,height:d,mask:s,bandMasks:o,validPixelCount:c,maskIsAlpha:this.maskIsAlpha,pixels:e.map(e=>t[e]),statistics:n&&e.map(e=>n[e])})}clone(){let t=new u({width:this.width,height:this.height,pixelType:this.pixelType,maskIsAlpha:this.maskIsAlpha,validPixelCount:this.validPixelCount,premultiplyAlpha:this.premultiplyAlpha,depthCount:this.depthCount}),n;this.mask!=null&&(t.mask=new Uint8Array(this.mask)),this.noDataValues&&(t.noDataValues=[...this.noDataValues]),this.bandMasks&&(t.bandMasks=this.bandMasks.map(e=>new Uint8Array(e)));let r=u.getPixelArrayConstructor(this.pixelType);if(this.pixels&&this.pixels.length>0){t.pixels=[];let e=!!this.pixels[0].slice;for(n=0;n<this.pixels.length;n++)t.pixels[n]=e?this.pixels[n].slice():new r(this.pixels[n])}if(this.statistics)for(t.statistics=[],n=0;n<this.statistics.length;n++)t.statistics[n]=e(this.statistics[n]);return t}getTransferableObject(){let{pixels:e,bandMasks:t,mask:n}=this;this.pixels=[],this.bandMasks=void 0,this.mask=void 0;let r=this.toJSON();this.pixels=e,this.bandMasks=t,this.mask=n,r.pixels=e&&[...e],r.bandMasks=t&&[...t],r.mask=n;let i=[];return[...e??[],n,...t??[]].filter(e=>e!=null&&ArrayBuffer.isView(e)).forEach(e=>{e&&!i.includes(e.buffer)&&i.push(e.buffer)}),{pixelBlock:r,transferList:i}}_fillFrom8Bit(e){let{mask:t,maskIsAlpha:n,premultiplyAlpha:r,pixels:i}=this;if(!e||!i?.length)return void s.getLogger(this).error(`getAsRGBA()`,`Unable to convert to RGBA. The input pixel block is empty.`);let a,o,c,l;a=o=c=i[0],i.length>=3?(o=i[1],c=i[2]):i.length===2&&(o=i[1]);let u=new Uint32Array(e),d=this.width*this.height;if(a.length===d)if(t!=null&&t.length===d)if(n)for(l=0;l<d;l++){let e=t[l];if(e){let t=e/255;u[l]=r?e<<24|c[l]*t<<16|o[l]*t<<8|a[l]*t:e<<24|c[l]<<16|o[l]<<8|a[l]}}else for(l=0;l<d;l++)t[l]&&(u[l]=255<<24|c[l]<<16|o[l]<<8|a[l]);else for(l=0;l<d;l++)u[l]=255<<24|c[l]<<16|o[l]<<8|a[l];else s.getLogger(this).error(`getAsRGBA()`,`Unable to convert to RGBA. The pixelblock is invalid.`)}_fillFromNon8Bit(e){let{pixels:t,mask:n,statistics:r}=this;if(!e||!t?.length)return void s.getLogger(this).error(`getAsRGBA()`,`Unable to convert to RGBA. The input pixel block is empty.`);let i=this.pixelType,a=1,o=0,c=1;if(r&&r.length>0){for(let e of r)if(e.minValue!=null&&(o=Math.min(o,e.minValue)),e.maxValue!=null&&e.minValue!=null){let t=e.maxValue-e.minValue;c=Math.max(c,t)}a=255/c}else{let e=255;i===`s8`?(o=-128,e=127):i===`u16`?e=65535:i===`s16`?(o=-32768,e=32767):i===`u32`?e=4294967295:i===`s32`?(o=-2147483648,e=2147483647):i===`f32`?(o=-34e38,e=34e38):i===`f64`&&(o=-Number.MAX_VALUE,e=Number.MAX_VALUE),a=255/(e-o)}let l=new Uint32Array(e),u=this.width*this.height,d,f,p,m,h;if(d=f=p=t[0],d.length!==u)return s.getLogger(this).error(`getAsRGBA()`,`Unable to convert to RGBA. The pixelblock is invalid.`);if(t.length>=2)if(f=t[1],t.length>=3&&(p=t[2]),n!=null&&n.length===u)for(m=0;m<u;m++)n[m]&&(l[m]=255<<24|(p[m]-o)*a<<16|(f[m]-o)*a<<8|(d[m]-o)*a);else for(m=0;m<u;m++)l[m]=255<<24|(p[m]-o)*a<<16|(f[m]-o)*a<<8|(d[m]-o)*a;else if(n!=null&&n.length===u)for(m=0;m<u;m++)h=(d[m]-o)*a,n[m]&&(l[m]=255<<24|h<<16|h<<8|h);else for(m=0;m<u;m++)h=(d[m]-o)*a,l[m]=255<<24|h<<16|h<<8|h}_fillFrom32Bit(e){let{pixels:t,mask:n}=this;if(!e||!t?.length)return s.getLogger(this).error(`getAsRGBAFloat()`,`Unable to convert to RGBA. The input pixel block is empty.`);let r,i,a,o;r=i=a=t[0],t.length>=3?(i=t[1],a=t[2]):t.length===2&&(i=t[1]);let c=this.width*this.height;if(r.length!==c)return s.getLogger(this).error(`getAsRGBAFloat()`,`Unable to convert to RGBA. The pixelblock is invalid.`);let l=0;if(n!=null&&n.length===c)for(o=0;o<c;o++)e[l++]=r[o],e[l++]=i[o],e[l++]=a[o],e[l++]=1&n[o];else for(o=0;o<c;o++)e[l++]=r[o],e[l++]=i[o],e[l++]=a[o],e[l++]=1}};function f(e,t){let n=1/0,r=-1/0,i=e.length,a,o=0;if(t!=null)for(a=0;a<i;a++)t[a]&&(o=e[a],n=o<n?o:n,r=o>r?o:r);else for(a=0;a<i;a++)o=e[a],n=o<n?o:n,r=o>r?o:r;return new l(n,r)}n([r({json:{write:!0}})],d.prototype,`width`,void 0),n([r({json:{write:!0}})],d.prototype,`height`,void 0),n([r({json:{write:!0}})],d.prototype,`pixelType`,void 0),n([t(`pixelType`)],d.prototype,`castPixelType`,null),n([r({json:{write:!0}})],d.prototype,`validPixelCount`,void 0),n([r({json:{write:!0}})],d.prototype,`mask`,void 0),n([r({json:{write:!0}})],d.prototype,`maskIsAlpha`,void 0),n([r({json:{write:!0}})],d.prototype,`pixels`,void 0),n([r()],d.prototype,`premultiplyAlpha`,void 0),n([r({json:{write:!0}})],d.prototype,`statistics`,void 0),n([r({json:{write:!0}})],d.prototype,`depthCount`,void 0),n([r({json:{write:!0}})],d.prototype,`noDataValues`,void 0),n([r({json:{write:!0}})],d.prototype,`bandMasks`,void 0),d=u=n([a(`esri.layers.support.PixelBlock`)],d);export{l as n,d as t};
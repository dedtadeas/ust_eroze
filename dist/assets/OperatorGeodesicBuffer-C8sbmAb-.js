import{wD as e,xD as t}from"./index-BqmCqmfp.js";import{n,t as r}from"./SimpleGeometryCursor-CI9GIWKa.js";import{A as i,C as a,Cn as o,I as s,Qt as c,bn as l,cn as u,dn as d,gn as f,in as p,kt as m,ln as h,mn as g,nt as _,pn as v,st as y,wn as b}from"./Point2D-UYEfE6HP.js";import{t as x}from"./Envelope2D-BNwQDrOT.js";import{Bt as S,Ct as C,D as w,En as T,H as E,Ht as D,It as O,Jt as k,K as A,L as j,M as ee,N as M,On as te,S as N,T as P,U as ne,Z as re,a as F,et as I,gn as L,gt as R,jt as z,m as B,mn as V,n as ie,o as H,pn as U,qt as ae,rt as oe,s as se,sn as W,t as G,tt as ce,u as le,v as K,vn as q,wn as ue}from"./UnitFactory-J9WMNXdY.js";import{t as J}from"./Transformation2D-DVoPQwGC.js";import"./OperatorDefinitions-DQQu7-BK.js";import{t as de}from"./GeometryCleaner-BEJM7I4l-DybJvg8-.js";function fe(e,t,n,r,i,a){r<Number.MAX_VALUE&&r>-Number.MAX_VALUE||p(`Geodesic_bufferer.buffer - bad distance`),g(e);let s=de(e),c=s.getGeometryType();if(o(c)){let e=s.getPointCount(),o=8e6;if(Math.abs(r)>o&&(e>50||c!==u.enumMultiPoint&&n===4&&e>2)){let e=s,c=r>0?1:-1,l=7e6,u=r,d=1;do d++,u=(Math.abs(u)-l)*c;while(Math.abs(u)>o);u=r;for(let r=0;r<d-1;r++)e=Y(e,t,n,l*c,i,d,a),u=(Math.abs(u)-l)*c;return e=Y(e,t,n,u,i,d,a),e}}return Y(s,t,n,r,i,1,a)}var pe=class{constructor(e){this.m_sr=null,this.m_gcs=null,this.m_transform=null,this.m_a=0,this.m_eSquared=0,this.m_rpu=0,this.m_radTolerance=0,this.m_q90=0,this.m_gcs90=0,this.m_gcs180=0,this.m_gcs360=0,this.m_gcs60=0,this.m_ellipticToGeodesicMaxRatio=0,this.m_curveType=0,this.m_bShapePreserving=!1,this.m_distance=0,this.m_absDistance=0,this.m_convergenceOffset=0,this.m_cornerStep=0,this.m_segmentStep=0,this.m_progressTracker=e}bufferPolygon(e){let t=new W,n=new Se(this,e,t);return this.processGnomonicBufferPiecesCursor(!0,n)}bufferPolyline(e){let t=new Se(this,e,null);return this.processGnomonicBufferPiecesCursor(!0,t)}bufferMultiPoint(e){let t=new Ce(this,e);return this.processGnomonicBufferPiecesCursor(!1,t)}bufferPoint(e){let t=e.getXY();t.scale(this.m_rpu);let n=new W;if(this.bufferPoint2D(t,!1,n)){let e=V(null,n,!0);n=N(n,e,!0,!0,-1,this.m_progressTracker,0,!1)}return n=new C().foldInto360RangeGeodetic(n,this.m_gcs,2),n}processGnomonicBufferPiecesCursor(e,t){let n=t,r=n.getGnomonic(),i=E(ce()),a=new G,o=new I().executeMany(a,i,this.m_progressTracker,2),c=y(6,!1),l=s(x,6);this.initializeGrid(c,l);let u=[null,null,null,null,null,null],d=[null,null,null,null,null,null],f=[null,null,null,null,null,null],p,m,h;for(;(p=n.next())!==null;){if(m=n.getGnomonic(),m!==r){if(r!==null){let t=o.next();if(a=null,o=null,t!=null){let n=V(i,t,!0),a=q(n);t=r.unproject(t,a,this.m_progressTracker),this.putInGridCursors(e,t,i,!0,c,l,u,d,f)}}m!==null&&(a=new G,o=new I().executeMany(a,i,this.m_progressTracker,2)),r=m}if(n.isRunningInGnomonic()){if(m.project(p),n.needsSimplify()){let e=V(null,p,!0);p=N(p,e,!0,!0,-1,this.m_progressTracker,0,!1)}a.tick($(p)),o.tock()}else this.putInGridCursors(e,p,i,!0,c,l,u,d,f)}let g=!1;for(let e=0;e<6;e++)if(f[e]!=null){g=!0;break}if(g){let t=!1,s=[null,null,null,null,null,null];if(e){let r=n.m_densified;if(n.m_densified=null,r!==null){let n=new J;n.scale(1/this.m_rpu,1/this.m_rpu),r.applyTransformation(n),this.m_distance>0?this.putInGridCursors(e,r,i,!1,c,l,u,d,f):(this.processInGrid(e,r,!1,c,l,u,s),t=!0)}}let p=new G,m=new I().executeMany(p,this.m_gcs,this.m_progressTracker,2);if(o!==null){let t=o.next();a=null,o=null;let n=V(i,t,!0),s=q(n);t=r.unproject(t,s,this.m_progressTracker),this.putInGridCursors(e,t,i,!0,c,l,u,d,f)}for(let e=0;e<6;e++)if(f[e]!=null){let n=f[e].next();f[e]=null,d[e]=null,t&&s[e]!==null&&(n=new B().execute(s[e],n,i,this.m_progressTracker));let r=V(i,n,!0),a=q(r);n=u[e].unproject(n,a,this.m_progressTracker),n=new se().execute(n,this.m_gcs,!0,this.m_progressTracker),p.tick($(n)),m.tock()}h=m.next()}else{let t,s=!1;if(e){let e=n.m_densified;if(n.m_densified=null,e!==null){let n=new J;n.scale(1/this.m_rpu,1/this.m_rpu),e.applyTransformation(n),m.project(e);let r=V(null,e,!0);e=N(e,r,!1,!0,-1,this.m_progressTracker,0,!1),this.m_distance>0?(a.tick($(e)),o.tock()):(t=e,s=!0)}}let c=o.next();a=null,o=null,s&&(c=new B().execute(t,c,i,this.m_progressTracker));let l=V(i,c,!0),u=q(l);h=r.unproject(c,u,this.m_progressTracker),h=new se().execute(h,this.m_gcs,!0,this.m_progressTracker)}return h=new C().foldInto360RangeGeodetic(h,this.m_gcs,2),h}putInGridCursors(e,t,n,r,i,a,o,s,c){let l=[null,null,null,null,null,null];this.processInGrid(e,t,r,i,a,o,l);for(let e=0;e<6;e++)l[e]!==null&&(s[e]===null&&(s[e]=new G,c[e]=new I().executeMany(s[e],n,this.m_progressTracker,2)),s[e].tick($(l[e])),c[e].tock())}processInGrid(e,t,n,r,i,a,o){let s=.01,c=this.insertGeodeticPointsAlongGrid(t,i,s);for(let e=0;e<6;e++){if(r[e])continue;let l=i[e].clone();l.inflateCoords(s,s);let u=L(t,l),d=U(null,u,!1).total(),f=D(c,l,d,NaN,this.m_progressTracker);if(f!==null&&!f.isEmpty()){if(f===c&&(f=f.clone()),a[e]===null){let t=new m;e<3?t.setCoords(0,1):t.setCoords(0,-1);let n=new m;n.setAdd(i[e].getCenter(),t),a[e]=Q(this.m_gcs,n)}a[e].project(f);let t=V(null,f,!0);f=N(f,t,n,!0,-1,this.m_progressTracker,0,!1),o[e]=f}}}insertGeodeticPointsAlongGrid(e,t,n){let r=x.construct(t[3].xmin,t[3].ymin,t[2].xmax,t[2].ymax),i=oe(this.m_gcs,r,e,!0,this.m_progressTracker),a=new k,o=a.addGeometry(i);return R(a,o,this.m_gcs,0,2,!0,t[0].xmax+n),R(a,o,this.m_gcs,0,2,!0,t[1].xmax+n),R(a,o,this.m_gcs,0,2,!1,t[1].ymin+n),n!==0&&(R(a,o,this.m_gcs,0,2,!0,t[0].xmax-n),R(a,o,this.m_gcs,0,2,!0,t[1].xmax-n),R(a,o,this.m_gcs,0,2,!1,t[1].ymin-n)),a.getGeometry(o)}initializeGrid(e,t){for(let t=0;t<6;t++)e[t]=!1;t[0].setCoords({xmin:-this.m_gcs180,ymin:0,xmax:-this.m_gcs60,ymax:this.m_gcs90}),t[1].setCoords({xmin:-this.m_gcs60,ymin:0,xmax:this.m_gcs60,ymax:this.m_gcs90}),t[2].setCoords({xmin:this.m_gcs60,ymin:0,xmax:this.m_gcs180,ymax:this.m_gcs90}),t[3].setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:-this.m_gcs60,ymax:0}),t[4].setCoords({xmin:-this.m_gcs60,ymin:-this.m_gcs90,xmax:this.m_gcs60,ymax:0}),t[5].setCoords({xmin:this.m_gcs60,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:0})}checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(e,t,n,r,i,a){let o=e[0],s=e.at(-1),c=o.y<s.y?o.y:s.y,l=o.y>s.y?o.y:s.y,u=j.q(this.m_a,this.m_eSquared,c),d=j.q(this.m_a,this.m_eSquared,l);if(this.m_q90-(u+t+this.m_absDistance)>.001&&this.m_q90+(d-t-this.m_absDistance)>.001)return!1;let f=n-_,p=r+_,m=f-Math.PI,h=f+Math.PI,g=p+Math.PI,v=[NaN],y=[NaN],b=[NaN],x=[NaN],S=!1;if(me(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,o,f,m,s,p,v,y),me(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,s,g,p,o,m,b,x),(p<v[0]&&v[0]<g||p<y[0]&&y[0]<g)&&(S=!0),S||(m<b[0]&&b[0]<f||m<x[0]&&x[0]<f)&&(S=!0),!S&&i)return!1;let C=[];for(let t=e.length-1;t>=0;t--)C.push(e[t]);a.setEmpty(),a.addPathPoint2D(null,0,!0);let w=0;w=X(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,this.m_curveType,e,f,p,i,w,a),w=Z(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,s,p,g,this.m_cornerStep,i,w,a,v[0],y[0]),w=X(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,this.m_curveType,C,g,h,i,w,a),w=Z(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,o,m,f,this.m_cornerStep,i,w,a,b[0],x[0]);let T=!1;return i||(T=this.checkAndPrepForPole(a)),S||T}bufferPoint2D(e,t,n){n.setEmpty(),n.addPathPoint2D(null,0,!0),Z(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,e,-this.m_cornerStep,2*Math.PI,this.m_cornerStep,t,0,n);let r=!1;return t||(r=this.checkAndPrepForPole(n)),r}checkAndPrepForPole(e){let t=this.checkAndPrepForPoleTouch(e),n=this.checkAndPrepForPoleWrap(e);return t||n}checkAndPrepForPoleTouch(e){let t=new x;return e.queryEnvelope(t),!(!w(t.ymax,this.m_gcs90)&&!w(t.ymin,-this.m_gcs90))&&(this.prepPoleTouch(e),!0)}checkAndPrepForPoleWrap(e){let t=e.getXY(0),n=e.getXY(e.getPointCount()-1);return Math.abs(t.x-n.x)>this.m_gcs180?(this.prepSinglePoleWrap(e),!0):this.checkAndPrepForDoublePoleWrap(e)}checkAndPrepForDoublePoleWrap(e){return e.calculateArea2D()<0&&(this.prepDoublePoleWrap(e),!0)}prepPoleTouch(e){let t=new W;t.insertPath2D(-1,null,0,0,!0);let n=e.getPathStart(0),r=e.getPathEnd(0),i=r-n,a=-1;for(a=n;a<r;a++){let t=e.getXY(a),n=w(t.y,this.m_gcs90),r=w(t.y,-this.m_gcs90);if(!n&&!r)break}let o=a,s=!1,c=NaN;do{let r=e.getXY(o),a=w(r.y,this.m_gcs90),l=w(r.y,-this.m_gcs90),u=n+(o+1-n)%i;if(a||l){let n=m.construct(c,r.y);t.insertPoint2D(0,-1,n);let i=e.getXY(u),a=w(i.y,this.m_gcs90),o=w(i.y,-this.m_gcs90);a||o||(n=m.construct(i.x,r.y),s?t.setXY(t.getPointCount()-1,n):t.insertPoint2D(0,-1,n)),s=!0}else t.insertPoint2D(0,-1,r),c=r.x,s=!1;o=u}while(o!==a);e.setEmpty(),e.add(t,!1)}prepSinglePoleWrap(e){let t=new W,n=new W,r=new J,i=e.getXY(e.getPathStart(0)),a=e.getXY(e.getPathEnd(0)-1),o=this.m_gcs360,s=this.m_gcs180,c=new x;c.setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:this.m_gcs90});let l=new x;e.queryEnvelope(l);let u=Math.ceil(l.width()/o),d,f;i.x>a.x?(d=-o,f=this.m_gcs90):(d=o,f=-this.m_gcs90),r.setShiftCoords(d,0),t.addPath(e,0,!0),n.add(t,!1);let p=new T;for(let e=0;e<u;e++)n.applyTransformation(r),n.getPointByVal(0,p),t.lineToPoint(p),t.addSegmentsFromPath(n,0,0,n.getSegmentCount()-1,!1);let h=t.getXY(0),g=t.getXY(t.getPointCount()-1);h.y=f,g.y=f,t.lineTo(g);let _=new m;for(_.setCoordsPoint2D(g),_.x-=.5*d;Math.abs(_.x-h.x)>s;)t.lineTo(_),_.x-=.5*d;t.lineTo(h);let v=c.getCenterX(),y=new x;t.queryEnvelope(y);let b=0,S=y.getCenter().x;S-v>s?b=-Math.ceil((S-v-s)/o):v-S>s&&(b=Math.ceil((v-S-s)/o)),b!==0&&(r.setShiftCoords(b*o,0),t.applyTransformation(r));let C=new k,w=C.addGeometry(t);R(C,w,this.m_gcs,0,2,!0,c.xmin),R(C,w,this.m_gcs,0,2,!0,c.xmax);let E=C.getGeometry(w),O=L(E,c);O.inflateCoords(0,1);let A=U(null,O,!0).total(),j=D(E,c,A,NaN,this.m_progressTracker);e.setEmpty(),e.add(j,!1)}prepDoublePoleWrap(e){let t=this.m_gcs360,n=this.m_gcs180,r=new x;r.setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:this.m_gcs90});let i=r.getCenter().x,a=new x;e.queryPathEnvelope(0,a);let o,s=0,c=a.getCenter().x;if(c-i>n?s=-Math.ceil((c-i-n)/t):i-c>n&&(s=Math.ceil((i-c-n)/t)),s!==0){let n=new J;n.setShiftCoords(s*t,0),e.getImpl().applyTransformationToPath(n,0),e.queryPathEnvelope(0,a),c=a.getCenter().x}let l=new x;r.containsExclusiveEnvelope(a)?(o=!1,l.setCoords({env2D:r})):(o=!0,l.setCoords({env2D:r}),l.xmin-=t,l.xmax+=t);let u=e.createInstance();u.addPathPoint2D(null,0,!0);let d=new m;if(d.setCoords(l.xmin,l.ymin),u.insertPoint2D(0,-1,d),d.setCoords(l.xmin,l.ymax),u.insertPoint2D(0,-1,d),d.setCoords(.5*(l.xmin+l.xmax),l.ymax),u.insertPoint2D(0,-1,d),d.setCoords(l.xmax,l.ymax),u.insertPoint2D(0,-1,d),d.setCoords(l.xmax,l.ymin),u.insertPoint2D(0,-1,d),d.setCoords(.5*(l.xmin+l.xmax),l.ymin),u.insertPoint2D(0,-1,d),o){u.addPath(e,0,!0);let n=new J;c<i?n.setShiftCoords(t,0):n.setShiftCoords(-t,0),e.getImpl().applyTransformationToPath(n,0),u.addPath(e,0,!0);let a=new k,o=a.addGeometry(u);R(a,o,this.m_gcs,0,2,!0,r.xmin),R(a,o,this.m_gcs,0,2,!0,r.xmax),u=a.getGeometry(o);let s=L(u,r);s.inflateCoords(0,1);let l=U(null,s,!0).total();u=D(u,r,l,NaN,this.m_progressTracker)}else u.addPath(e,0,!0);e.setEmpty(),e.add(u,!1)}setMinCornerStep(){let n={stack:[],error:void 0,hasError:!1};try{let r=Math.min(Math.PI*this.m_a-this.m_absDistance,this.m_absDistance);r=Math.min(r,.125*this.m_a*Math.PI);let i=new m;i.setCoords(0,10*this.m_rpu);let o=45*this.m_rpu,s=t(n,new a(new F,new F),!1),c=t(n,new a(new F,new F),!1),l=t(n,new a(new F,new F),!1),u=t(n,new a(new F,new F),!1),d=new m,f=new m,p=new m,h=new m;for(H.geodesicCoordinate(this.m_a,this.m_eSquared,i.x,i.y,r,0,s.at(0),s.at(1)),d.setCoords(s.at(0).val,s.at(1).val),H.geodesicCoordinate(this.m_a,this.m_eSquared,i.x,i.y,r,o,c.at(0),c.at(1)),f.setCoords(c.at(0).val,c.at(1).val);;){let n={stack:[],error:void 0,hasError:!1};try{let e=.5*(0+o);H.geodesicCoordinate(this.m_a,this.m_eSquared,i.x,i.y,r,e,l.at(0),l.at(1)),p.setCoords(l.at(0).val,l.at(1).val);let a=t(n,new F,!1),s=t(n,new F,!1);H.geodeticDistance(this.m_a,this.m_eSquared,d.x,d.y,f.x,f.y,a,s,null,2),H.geodeticCoordinate(this.m_a,this.m_eSquared,d.x,d.y,.5*a.val,s.val,u.at(0),u.at(1),2),h.setCoords(u.at(0).val,u.at(1).val);let m=t(n,new F,!1);if(H.geodeticDistance(this.m_a,this.m_eSquared,p.x,p.y,h.x,h.y,m,null,null,2),m.val<=this.m_convergenceOffset)break;o*=.9,H.geodesicCoordinate(this.m_a,this.m_eSquared,i.x,i.y,r,o,c.at(0),c.at(1)),f.setCoords(c.at(0).val,c.at(1).val)}catch(e){n.error=e,n.hasError=!0}finally{e(n)}}let g=o-0;this.m_cornerStep=2*Math.PI/Math.ceil(2*Math.PI/g)}catch(e){n.error=e,n.hasError=!0}finally{e(n)}}setMinSegmentStep(){let n={stack:[],error:void 0,hasError:!1};try{let r=Math.min(Math.PI*this.m_a-this.m_absDistance,this.m_absDistance);r=Math.min(r,.125*this.m_a*Math.PI);let i=new m,o=new m;i.setCoords(0,10*this.m_rpu),o.setCoords(10*this.m_rpu,10*this.m_rpu);let s=t(n,new F,!1),c=t(n,new F,!1),l=t(n,new F,!1);H.geodeticDistance(this.m_a,this.m_eSquared,i.x,i.y,o.x,o.y,l,s,c,this.m_curveType);let u=t(n,new a(new F,new F),!1),d=t(n,new a(new F,new F),!1),f=new m,p=t(n,new F,!1),h=t(n,new a(new F,new F),!1),g=t(n,new a(new F,new F),!1),_=t(n,new a(new F,new F),!1),v=t(n,new a(new F,new F),!1),y=new m,b=new m,x=new m,S=new m,C=1,w=s.val,T=c.val,E=w-.5*Math.PI,D=T+.5*Math.PI,O=l.val;for(H.geodesicCoordinate(this.m_a,this.m_eSquared,i.x,i.y,r,E,h.at(0),h.at(1)),y.setCoords(h.at(0).val,h.at(1).val),H.geodesicCoordinate(this.m_a,this.m_eSquared,o.x,o.y,r,D,g.at(0),g.at(1)),b.setCoords(g.at(0).val,g.at(1).val);;){let n={stack:[],error:void 0,hasError:!1};try{let a=.5*(0+C);H.geodeticCoordinate(this.m_a,this.m_eSquared,i.x,i.y,a*O,w,u.at(0),u.at(1),this.m_curveType),f.setCoords(u.at(0).val,u.at(1).val),H.geodeticDistance(this.m_a,this.m_eSquared,i.x,i.y,f.x,f.y,null,null,p,this.m_curveType);let s=p.val+.5*Math.PI;H.geodesicCoordinate(this.m_a,this.m_eSquared,f.x,f.y,r,s,_.at(0),_.at(1)),x.setCoords(_.at(0).val,_.at(1).val);let c=t(n,new F,!1),l=t(n,new F,!1);H.geodeticDistance(this.m_a,this.m_eSquared,y.x,y.y,b.x,b.y,c,l,null,2),H.geodeticCoordinate(this.m_a,this.m_eSquared,y.x,y.y,.5*c.val,l.val,v.at(0),v.at(1),2),S.setCoords(v.at(0).val,v.at(1).val);let m=t(n,new F,!1);if(H.geodeticDistance(this.m_a,this.m_eSquared,x.x,x.y,S.x,S.y,m,null,null,2),m.val<=this.m_convergenceOffset)break;{let n={stack:[],error:void 0,hasError:!1};try{C*=.9,H.geodeticCoordinate(this.m_a,this.m_eSquared,i.x,i.y,C*O,w,d.at(0),d.at(1),this.m_curveType),o.setCoords(d.at(0).val,d.at(1).val);let e=t(n,new F,!1);H.geodeticDistance(this.m_a,this.m_eSquared,i.x,i.y,o.x,o.y,null,null,e,this.m_curveType);let a=e.val+.5*Math.PI;H.geodesicCoordinate(this.m_a,this.m_eSquared,o.x,o.y,r,a,g.at(0),g.at(1)),b.setCoords(g.at(0).val,g.at(1).val)}catch(e){n.error=e,n.hasError=!0}finally{e(n)}}}catch(e){n.error=e,n.hasError=!0}finally{e(n)}}let k=C*O;k>1e5&&(k=1e5),this.m_segmentStep=k}catch(e){n.error=e,n.hasError=!0}finally{e(n)}}setConvergenceOffset(){let e;e=this.m_absDistance>5e4?100:this.m_absDistance>1e4?10:1,this.m_absDistance/e<500&&(e=this.m_absDistance/500),e<.01&&(e=.01),this.m_convergenceOffset=e}};function Y(e,t,n,r,i,a,o){if(e.isEmpty())return new W({vd:e.getDescription()});let s=e;if(c(s)){let e=10*t.getTolerance(0);s=new S().execute(s,0,e,0,o,12e3)}let p=new pe(o);p.m_sr=t,p.m_gcs=t.getGCS(),p.m_transform=ee(t,p.m_gcs,null);let m=le();p.m_gcs.querySpheroidData(m);let h=new x;s.queryEnvelope(h),p.m_a=m.majorSemiAxis,p.m_eSquared=m.e2,p.m_rpu=p.m_gcs.getUnit().getUnitToBaseFactor(),p.m_gcs90=.5*Math.PI/p.m_rpu,p.m_gcs180=Math.PI/p.m_rpu,p.m_gcs360=2*Math.PI/p.m_rpu,p.m_gcs60=p.m_gcs360/6,p.m_q90=j.q90(p.m_a,p.m_eSquared),p.m_ellipticToGeodesicMaxRatio=.5*p.m_a*Math.PI/p.m_q90,p.m_radTolerance=p.m_gcs.getTolerance(0)*p.m_rpu,n===4?(p.m_curveType=2,p.m_bShapePreserving=!0):(p.m_curveType=n,p.m_bShapePreserving=!1),p.m_distance=r,p.m_absDistance=Math.abs(r),Number.isNaN(i)||i<=0?p.setConvergenceOffset():p.m_convergenceOffset=Math.max(i,.001),p.m_convergenceOffset/=a;let g,_=s.getGeometryType();if(d(_)){let e=new ae({vd:s.getDescription()});e.addSegment(s,!0),g=e,_=u.enumPolyline}else if(_===u.enumEnvelope){let e=s,t=new x;e.queryEnvelope(t);let n=q(U(p.m_sr,h,!0));if(t.minDimension()<=n)if(t.maxDimension()===0){let t=new T({vd:s.getDescription()});e.getCenter(t),g=t,_=u.enumPoint}else{let t=new ae({vd:s.getDescription()});t.addEnvelope(e,!1),g=t,_=u.enumPolyline}else{let t=new W({vd:s.getDescription()});t.addEnvelope(e,!1),g=t,_=u.enumPolygon}}else g=s;if(p.setMinCornerStep(),f(_)||p.setMinSegmentStep(),p.m_absDistance<=.5*p.m_convergenceOffset)return _===u.enumPolygon?p.m_bShapePreserving?g:P(g,p.m_sr,p.m_curveType,p.m_segmentStep,-1,o):new W({vd:g.getDescription()});if(p.m_distance<0&&_!==u.enumPolygon)return new W({vd:g.getDescription()});if(p.m_bShapePreserving&&v(_)){let e=P(g,t,4,NaN,p.m_convergenceOffset,o);g=new C().execute(e,p.m_transform,o)}else g=new C().execute(g,p.m_transform,o);if(g=ie(g,p.m_gcs),g.isEmpty())return new W({vd:g.getDescription()});!p.m_bShapePreserving&&v(_)&&(g=A(p.m_rpu,g)),g=ge(g,p.m_gcs);let y=new W;switch(_){case u.enumPolygon:y=p.bufferPolygon(g);break;case u.enumPolyline:y=p.bufferPolyline(g);break;case u.enumMultiPoint:y=p.bufferMultiPoint(g);break;case u.enumPoint:y=p.bufferPoint(g);break;default:l(``)}let b=new C().execute(y,p.m_transform.getInverse(),o);return b.mergeVertexDescription(g.getDescription()),b}function X(n,r,i,o,s,c,l,u,d,f,p){let h={stack:[],error:void 0,hasError:!1};try{let e=new m;e.setNAN(),d||p.getPointCount()>0&&(e.setCoordsPoint2D(p.getXY(p.getPointCount()-1)),e.scale(i));let g=t(h,new F,!1),_=t(h,new a(new F,new F),!1),v=new m,y=new m,b=c.at(-1),x=1/i;for(let t=0;t<c.length;t++){let i=c[t],a;t===0?a=l:t===c.length-1?a=u:(H.geodeticDistance(n,r,b.x,b.y,i.x,i.y,null,null,g,s),a=g.val-.5*Math.PI),H.geodesicCoordinate(n,r,i.x,i.y,o,a,_.at(0),_.at(1)),d?y.setCoords(_.at(0).val,_.at(1).val):(v.setCoords(_.at(0).val,_.at(1).val),f=he(i.x,v.x,e.x,f),y.setCoords(f+v.x,v.y),e.setCoordsPoint2D(y)),y.scale(x),p.insertPoint2D(0,-1,y)}return f}catch(e){h.error=e,h.hasError=!0}finally{e(h)}}function Z(n,r,i,o,s,c,l,u,d,f,p,h=NaN,g=NaN){let _={stack:[],error:void 0,hasError:!1};try{if(l-c<u)return f;let e=t(_,new a(new F,new F),!1),v=new m,y=new m,b=new m;y.setNAN(),d||p.getPointCount()>0&&(y.setCoordsPoint2D(p.getXY(p.getPointCount()-1)),y.scale(i));let x=Math.ceil(c/u),S=x++*u;S===c&&(S=x++*u);let C=c,w=1/i;for(;S<l+u&&(C<h&&h<S?(S=h,x--):C<g&&g<S&&(S=g,x--),!(S>=l));)H.geodesicCoordinate(n,r,s.x,s.y,o,S,e.at(0),e.at(1)),d?b.setCoords(e.at(0).val,e.at(1).val):(v.setCoords(e.at(0).val,e.at(1).val),f=he(s.x,v.x,y.x,f),b.setCoords(f+v.x,v.y),y.setCoordsPoint2D(b)),b.scale(w),p.insertPoint2D(0,-1,b),C=S,S=x++*u;return f}catch(e){_.error=e,_.hasError=!0}finally{e(_)}}function me(n,r,o,s,c,l,u,d,f,p,h){let g={stack:[],error:void 0,hasError:!1};try{let e=new m,o=new m,_=t(g,new a(new F,new F),!1);H.geodesicCoordinate(n,r,c.x,c.y,s,l,_.at(0),_.at(1)),e.setCoords(_.at(0).val,_.at(1).val),H.geodesicCoordinate(n,r,c.x,c.y,s,u,_.at(0),_.at(1)),o.setCoords(_.at(0).val,_.at(1).val);let v=t(g,new F,!1);for(H.geodeticDistance(n,r,d.x,d.y,e.x,e.y,null,v,null,0),p[0]=v.val,H.geodeticDistance(n,r,d.x,d.y,o.x,o.y,null,v,null,0),h[0]=v.val;p[0]<=h[0];)p[0]+=i;for(;p[0]>h[0];)p[0]-=i;for(;p[0]>=f;)p[0]-=i,h[0]-=i;for(;p[0]<f;)p[0]+=i,h[0]+=i}catch(e){g.error=e,g.hasError=!0}finally{e(g)}}function he(e,t,n,r){if(Number.isNaN(n)){for(;r+t-e>Math.PI;)r-=i;for(;e-(r+t)>Math.PI;)r+=i;return r}return r+t-n>Math.PI?r-=i:n-(r+t)>Math.PI&&(r+=i),r}function ge(e,t){let n=e.getGeometryType(),r;if(r=v(n)?e.getPathCount():n===u.enumMultiPoint?e.getPointCount():1,r===1)return e;let i=[],a=[];for(let o=0;o<r;o++){i.push(o);let r=new m;if(v(n)){let t=new x;e.queryPathEnvelope(o,t),r.assign(t.getCenter())}else r.assign(e.getXY(o));let s=t.toGeohash(r);a.push(s)}i.sort((e,t)=>a[e]<a[t]?-1:a[e]>a[t]?1:0);let o=e.createInstance();for(let t=0;t<r;t++){let r=i[t];v(n)?o.addPath(e,r,!0):o.addPoints(e,r,r+1)}return o}function _e(n,r,i,a,o,s){let c={stack:[],error:void 0,hasError:!1};try{if(a>=s)return!1;let e=i[0],l=i.at(-1),u=t(c,new F,!1),d=t(c,new F,!1),f=t(c,new F,!1);H.greatEllipticDistance(n,r,o.x,o.y,e.x,e.y,u,null,null),H.greatEllipticDistance(n,r,o.x,o.y,l.x,l.y,d,null,null),H.greatEllipticDistance(n,r,e.x,e.y,l.x,l.y,f,null,null);let p=Math.min(u.val,d.val)+f.val,m=p+a;if(m<s)return!0;let h=t(c,new F,!1);p=Math.max(u.val,d.val);for(let e=1;e<i.length-1;e++){let t=i[e];H.greatEllipticDistance(n,r,o.x,o.y,t.x,t.y,h,null,null),h.val>p&&(p=h.val)}return m=p+a,m<s}catch(e){c.error=e,c.hasError=!0}finally{e(c)}}function ve(e,t,n,r,i,a,o,s){let c;if(r.length%2==0){let e=r.length>>1,t=r[e],n=r[e-1];c=m.lerp(t,n,.5)}else c=r[r.length-1>>1].clone();let l=c.clone(),u=z(e,t,l,75/180*Math.PI);return!!_e(e,t,r,i,l,u)&&(a!==null&&(a.setCoordsPoint2D(c),a.scale(1/n)),o!==null&&o.setCoordsPoint2D(l),s!==null&&(s[0]=u),!0)}function ye(n,r,i,a,o,s){let c={stack:[],error:void 0,hasError:!1};try{if(a>=s)return!1;let e=t(c,new F,!1);return H.greatEllipticDistance(n,r,o.x,o.y,i.x,i.y,e,null,null),e.val+a<s}catch(e){c.error=e,c.hasError=!0}finally{e(c)}}function be(e,t,n,r,i,a,o,s){let c=z(e,t,r,75/180*Math.PI);return!!ye(e,t,r,i,r,c)&&(a!==null&&(a.setCoordsPoint2D(r),a.scale(1/n)),o!==null&&o.setCoordsPoint2D(r),s!==null&&(s[0]=c),!0)}function Q(e,t){return new re(e,t)}function $(e){return ue(e,0)||te(e,0),e}var xe=class{constructor(e){this.m_bRunningInGnomonic=!1,this.m_bNeedsSimplify=!1,this.m_gnomonic=null,this.m_gnomonicCenterRad=new m,this.m_minGnomonicRadius=NaN,this.m_progressTracker=e}isRunningInGnomonic(){return this.m_bRunningInGnomonic}needsSimplify(){return this.m_bNeedsSimplify}getGnomonic(){return this.m_gnomonic}},Se=class extends xe{constructor(e,t,n){super(e.m_progressTracker),this.m_segIter=null,this.m_bNextSegmentCannotJoin=!1,this.m_currentDensifiedDelta=[0],this.m_currentBufferedDelta=0,this.m_lastAzimuth=0,this.m_startAzimuth=[0],this.m_endAzimuth=[0],this.m_numWinds=0,this.m_debugCounter=0,this.m_bufferHelper=new W,this.m_densifiedPoints=[],this.m_bufferer=e,this.m_multiPath=t,this.m_densified=n,this.m_bNeedsSimplify=!0;let r=new x;this.m_multiPath.queryEnvelope(r);let i=r.getCenter(),a=i.clone();a.scale(this.m_bufferer.m_rpu),this.m_gnomonic=Q(this.m_bufferer.m_gcs,i),this.m_gnomonicCenterRad=a.clone(),this.m_minGnomonicRadius=z(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,a,75/180*Math.PI)}next(){let e;if(this.m_bNextSegmentCannotJoin)return this.m_bNextSegmentCannotJoin=!1,this.m_segIter.nextSegment(),e=this.m_bufferHelper.clone(),e;if(this.m_segIter===null){if(this.m_segIter=this.m_multiPath.getImpl().querySegmentIterator(),!this.m_segIter.nextPath())return null;this.m_densified!==null&&this.m_densified.addPathPoint2D(null,0,!0)}if(!this.m_segIter.hasNextSegment()){if(!this.m_segIter.nextPath())return null;this.m_densified!=null&&this.m_densified.addPathPoint2D(null,0,!0)}let t=null;this.m_currentBufferedDelta=0,this.m_currentDensifiedDelta=[0],this.m_numWinds=0,this.m_lastAzimuth=NaN,this.m_bNextSegmentCannotJoin=!1,this.m_densifiedPoints.length=0;let n=0,r=new m,i=new m;for(;this.m_segIter.hasNextSegment()&&this.m_numWinds<16;){let e=this.m_segIter.nextSegment();if(r.setCoordsPoint2D(e.getStartXY()),i.setCoordsPoint2D(e.getEndXY()),r.scale(this.m_bufferer.m_rpu),i.scale(this.m_bufferer.m_rpu),K(r,i))r.x=i.x;else if(O(r,i))i.x=r.x;else{let e=-1,t=-1,n=this.m_segIter.getPathIndex(),a=this.m_multiPath.getPathStart(n),o=this.m_multiPath.getPathEnd(n);if(e=this.m_segIter.getStartPointIndex()-1,t=this.m_segIter.getEndPointIndex()+1,e<a&&(e=this.m_multiPath.isClosedPath(n)?o-1:-1),t>o-1&&(t=this.m_multiPath.isClosedPath(n)?a:-1),e!==-1){let t=this.m_multiPath.getXY(e);t.scale(this.m_bufferer.m_rpu),O(t,r)&&(r.x=t.x)}if(t!==-1){let e=this.m_multiPath.getXY(t);e.scale(this.m_bufferer.m_rpu),K(i,e)&&(i.x=e.x)}}this.m_densifiedPoints.length=0;let a=M(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_curveType,r,i,this.m_bufferer.m_segmentStep,NaN,this.m_bufferer.m_radTolerance,this.m_startAzimuth,this.m_endAzimuth,this.m_densifiedPoints,this.m_currentDensifiedDelta);if(n===0)this.m_bRunningInGnomonic=this.isSegmentBufferInCurrentGnomonic(this.m_densifiedPoints),this.m_bRunningInGnomonic||=this.tryUpdateGnomonic(this.m_densifiedPoints);else if(this.m_bRunningInGnomonic){if(!this.isSegmentBufferInCurrentGnomonic(this.m_densifiedPoints)){this.m_segIter.previousSegment(),this.m_segIter.previousSegment(),this.m_segIter.nextSegment();break}}else if(ve(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_densifiedPoints,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,null,null,null)){this.m_segIter.previousSegment(),this.m_segIter.previousSegment(),this.m_segIter.nextSegment();break}if(a===0||ne(r,i)?(this.m_bufferHelper.setEmpty(),this.m_bufferer.bufferPoint2D(r,this.m_bRunningInGnomonic,this.m_bufferHelper),this.m_bNextSegmentCannotJoin=!0):(this.m_bufferHelper.setEmpty(),this.m_bNextSegmentCannotJoin=this.checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(a,this.m_bufferHelper)),this.m_bNextSegmentCannotJoin){this.m_segIter.previousSegment(),this.m_segIter.hasPreviousSegment()?(this.m_segIter.previousSegment(),this.m_segIter.nextSegment()):this.m_segIter.resetToFirstSegment(),this.m_densified!=null&&this.m_densified.insertPointsFromPoints(this.m_densified.getPathCount()-1,-1,this.m_densifiedPoints,0,this.m_densifiedPoints.length-1,!0);break}this.m_densified!=null&&this.m_densified.insertPointsFromPoints(this.m_densified.getPathCount()-1,-1,this.m_densifiedPoints,0,this.m_densifiedPoints.length-1,!0),t===null&&(t=new W,t.addPathPoint2D(null,0,!0)),this.addJoinAndBufferLeftSide(t),n++}if(this.m_currentDensifiedDelta=[0],n>0){let e=this.m_segIter.getStartPointIndex(),a=this.m_segIter.getPathIndex();for(;n>0;){if(this.m_segIter.previousSegment(),r.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getStartPointIndex())),i.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getEndPointIndex())),r.scale(this.m_bufferer.m_rpu),i.scale(this.m_bufferer.m_rpu),this.m_bRunningInGnomonic)if(K(r,i))r.x=i.x;else if(O(r,i))i.x=r.x;else{let e=-1,t=-1,n=this.m_segIter.getPathIndex(),a=this.m_multiPath.getPathStart(n),o=this.m_multiPath.getPathEnd(n);if(e=this.m_segIter.getStartPointIndex()-1,t=this.m_segIter.getEndPointIndex()+1,e<a&&(e=this.m_multiPath.isClosedPath(n)?o-1:-1),t>o-1&&(t=this.m_multiPath.isClosedPath(n)?a:-1),e!==-1){let t=this.m_multiPath.getXY(e);t.scale(this.m_bufferer.m_rpu),O(t,r)&&(r.x=t.x)}if(t!==-1){let e=this.m_multiPath.getXY(t);e.scale(this.m_bufferer.m_rpu),K(i,e)&&(i.x=e.x)}}this.m_densifiedPoints.length=0,M(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_curveType,i,r,this.m_bufferer.m_segmentStep,NaN,this.m_bufferer.m_radTolerance,this.m_startAzimuth,this.m_endAzimuth,this.m_densifiedPoints,this.m_currentDensifiedDelta),this.addJoinAndBufferLeftSide(t),n--}return r.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getStartPointIndex())),r.scale(this.m_bufferer.m_rpu),this.m_currentBufferedDelta=Z(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,r,this.m_lastAzimuth+.5*Math.PI,this.m_lastAzimuth+1.5*Math.PI,this.m_bufferer.m_cornerStep,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,t),this.m_segIter.resetToVertex(e,a),this.m_segIter.nextSegment(),t}return this.m_bNextSegmentCannotJoin=!1,this.m_segIter.nextSegment(),e=this.m_bufferHelper.clone(),e}isSegmentBufferInCurrentGnomonic(e){return this.m_gnomonic!==null&&_e(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,this.m_gnomonicCenterRad,this.m_minGnomonicRadius)}tryUpdateGnomonic(e){let t=new m,n=new m,r=[0];return ve(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,t,n,r)?(this.m_gnomonicCenterRad.setCoordsPoint2D(n),this.m_minGnomonicRadius=r[0],this.m_gnomonic=Q(this.m_bufferer.m_gcs,t),!0):(this.m_gnomonic=null,!1)}checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(e,t){return this.m_bufferer.checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(this.m_densifiedPoints,e,this.m_startAzimuth[0],this.m_endAzimuth[0],this.m_bRunningInGnomonic,t)}addJoinAndBufferLeftSide(e){let t=this.m_densifiedPoints[0],n=NaN,r=this.m_startAzimuth[0]-_,a=this.m_endAzimuth[0]+_,o=!1;if(!Number.isNaN(this.m_lastAzimuth)){this.m_lastAzimuth>=this.m_startAzimuth[0]?(n=this.m_lastAzimuth+_,r=n+Math.PI-(this.m_lastAzimuth-this.m_startAzimuth[0])):(n=this.m_lastAzimuth+_,r=n+Math.PI-(i-(this.m_startAzimuth[0]-this.m_lastAzimuth))),o=!(this.m_lastAzimuth>=this.m_startAzimuth[0]&&this.m_lastAzimuth-this.m_startAzimuth[0]<=Math.PI)&&!(this.m_lastAzimuth<this.m_startAzimuth[0]&&this.m_startAzimuth[0]-this.m_lastAzimuth>=Math.PI);let a=!1;if(Math.abs(r-n)<=.5*this.m_bufferer.m_cornerStep&&(o||(a=!0)),a){if(e.removePointFromPath(0,e.getPointCount()-1),!this.m_bRunningInGnomonic){let t=new m;t.setCoordsPoint2D(e.getXY(e.getPointCount()-1)),t.scale(this.m_bufferer.m_rpu),t.x-this.m_currentBufferedDelta<-Math.PI?this.m_currentBufferedDelta-=i:t.x-this.m_currentBufferedDelta>Math.PI&&(this.m_currentBufferedDelta+=i)}r=.5*(r+n)}else if(o){let n=new m;n.setCoordsPoint2D(t),n.scale(1/this.m_bufferer.m_rpu),e.insertPoint2D(0,-1,n)}else Z(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,this.m_densifiedPoints[0],n,r,this.m_bufferer.m_cornerStep,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,e)}this.m_startAzimuth[0]!==this.m_lastAzimuth&&this.m_numWinds++,X(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,this.m_bufferer.m_curveType,this.m_densifiedPoints,r,a,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,e),this.m_lastAzimuth=this.m_endAzimuth[0]}},Ce=class extends xe{constructor(e,t){super(e.m_progressTracker),this.m_pointIndex=-1,this.m_bufferer=e,this.m_multiPoint=t,this.m_bNeedsSimplify=!1;let n=new x;this.m_multiPoint.queryEnvelope(n);let r=n.getCenter(),i=r.clone();i.scale(this.m_bufferer.m_rpu),this.m_gnomonic=Q(this.m_bufferer.m_gcs,r),this.m_gnomonicCenterRad=i.clone(),this.m_minGnomonicRadius=z(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,i,75/180*Math.PI)}next(){if(this.m_bNeedsSimplify=!1,++this.m_pointIndex===this.m_multiPoint.getPointCount())return null;let e=this.m_multiPoint.getXY(this.m_pointIndex);e.scale(this.m_bufferer.m_rpu),this.m_bRunningInGnomonic=this.isPointBufferInCurrentGnomonic(e),this.m_bRunningInGnomonic||=this.tryUpdateGnomonic(e);let t=new W;return this.m_bNeedsSimplify=this.m_bufferer.bufferPoint2D(e,this.m_bRunningInGnomonic,t),t}isPointBufferInCurrentGnomonic(e){return this.m_gnomonic!==null&&ye(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,this.m_gnomonicCenterRad,this.m_minGnomonicRadius)}tryUpdateGnomonic(e){let t=new m,n=new m,r=[0];return be(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,t,n,r)?(this.m_gnomonicCenterRad.setCoordsPoint2D(n),this.m_minGnomonicRadius=r[0],this.m_gnomonic=Q(this.m_bufferer.m_gcs,t),!0):(this.m_gnomonic=null,!1)}},we=class{getOperatorType(){return 10110}supportsCurves(){return!0}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}executeMany(e,t,n,r,i,a,o,s){if(o){let o=new Te(e,t,n,r,i,!1,a,s);return new I().executeMany(o,t,s)}return new Te(e,t,n,r,i,!1,a,s)}execute(e,t,n,i,a,o,s){let c=new r([e]),l=[i],u=this.executeMany(c,t,n,l,a,!1,o,s).next();return u||h(`geodesic buffer null output`),u}},Te=class extends n{constructor(e,t,n,r,i,a,o,s){super(),this.m_currentUnionEnvelope2D=new x,this.m_index=-1,this.m_dindex=-1,this.m_progressTracker=s,a&&b(``),t||p(``),t.getCoordinateSystemType()===0&&p(``),this.m_inputGeoms=e,this.m_spatialReference=t,this.m_curveType=n,this.m_distances=r,this.m_convergenceOffset=i,this.m_bOutlineOnly=a,this.m_bUnion=o}next(){let e;for(;e=this.m_inputGeoms.next();)return g(e),this.m_index=this.m_inputGeoms.getGeometryID(),this.m_dindex+1<this.m_distances.length&&this.m_dindex++,this.geodesicBuffer(e,this.m_distances[this.m_dindex]);return null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}geodesicBuffer(e,t){return fe(e,this.m_spatialReference,this.m_curveType,t,this.m_convergenceOffset,this.m_progressTracker)}};export{we as OperatorGeodesicBuffer};
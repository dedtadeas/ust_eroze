const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/meshFeatureSet-CBr8Bp39.js","assets/index-BqmCqmfp.js","assets/index-kIqmb12G.css","assets/earcut-Drx511Ix.js","assets/vec3-40WN6G4a.js","assets/vec4-CcFo8HF1.js","assets/vectorStacks-CKtslZxP.js","assets/quatf64-CJzmL3cc.js","assets/quat-Bk_ZaVz9.js","assets/Mesh-CUHzTZdQ.js","assets/computeTranslationToOriginAndRotation-BC3OuSky.js","assets/projectPointToVector-Clou1sfo.js","assets/spatialReferenceEllipsoidUtils-DBtdxVkA.js","assets/MeshComponent--ctdPfFQ.js","assets/MeshMaterialMetallicRoughness-BUsirHC6.js","assets/meshCloneUtils-Akm6YUJV.js","assets/meshProperties-Du90n6lL.js","assets/MeshLocalVertexSpace-HjmVAuYa.js","assets/MeshTransform-B2p38eYR.js","assets/axisAngleDegrees-Di7q97jx.js","assets/MeshVertexAttributes-Df5_8xlW.js","assets/External-Cyg8cgWj.js","assets/vertexSpaceConversion-g9XG_RJW.js","assets/BufferView-DNaZpbJX.js","assets/Util-3rPi0NfK.js","assets/meshVertexSpaceUtils-Y8FeTLov.js","assets/triangulationUtils-BJbNyOeM.js","assets/Indices-BsTLKVdx.js","assets/deduplicate-BuZ0DaaO.js","assets/plane-CTjDePZl.js","assets/meshFeatureAttributes-DKUFwpcn.js","assets/intersectionOperator-Fa-8HuJM.js","assets/UnitFactory-J9WMNXdY.js","assets/Envelope2D-BNwQDrOT.js","assets/Point2D-UYEfE6HP.js","assets/OperatorDefinitions-DQQu7-BK.js","assets/SimpleGeometryCursor-CI9GIWKa.js","assets/Transformation2D-DVoPQwGC.js","assets/intersectionOperator-BZ65EtX2.js","assets/operatorIntersection-Ctxxj_Rb.js","assets/apiConverter-DVPFZqjR.js","assets/jsonConverter-DiNOXEUJ.js"])))=>i.map(i=>d[i]);
import{$E as e,Ad as t,CD as n,Cd as r,Cw as i,Dd as a,Du as o,Fm as s,Fp as c,Gb as l,Gw as u,Hy as d,Id as f,MC as p,Md as m,Nd as h,Od as g,Pa as _,Pp as v,Sw as y,Xp as ee,_E as b,am as te,ar as ne,bD as re,ct as x,hC as ie,iT as S,jd as ae,kC as C,kw as oe,lm as se,nD as ce,nx as le,qp as ue,rT as de,sm as w,uT as fe,ur as pe,vC as me,vE as he,wd as T,zu as ge}from"./index-BqmCqmfp.js";import"./memoryEstimations-O7VgDRVG.js";import"./OptimizedFeature-Dx4_lHip.js";import"./OptimizedGeometry-f3I9Z6C1.js";import"./OptimizedFeatureSet-DlHqIhoP.js";import"./featureConversionUtils-7vyVIZ6j.js";import{n as _e,t as ve}from"./generateRendererUtils-BgK3c0Qk.js";import{_ as ye,h as be,l as xe,p as Se,r as E,s as Ce,t as D,u as we}from"./utils-BcHO3hev.js";import"./urlUtils-CtPsFIu4.js";import"./pbf-CwGh07vG.js";import"./pbfQueryUtils-DOeTJOP2.js";import"./queryUtils-GIY2oFHT.js";import"./query-D8IHih8e.js";import{t as Te}from"./executeQueryJSON-BAg2ttNX.js";import{t as Ee}from"./executeQueryPBF-DMb74A0k.js";import"./queryUtils-BA7HiGeg.js";import{u as De}from"./quantizationUtils-C5shine1.js";import{a as Oe,i as O,n as ke,o as k,r as A,t as Ae}from"./utils-DD1PtgG7.js";import{a as je,i as j,n as Me,o as M,r as Ne,t as N}from"./utils-C2AeUOnb.js";import{a as Pe,n as Fe,r as Ie,t as Le}from"./FixedIntervalBinParameters-BO-nZFQ3.js";import{t as Re}from"./AttributeBinsQuery-DyK0zHZB.js";import{n as ze,t as Be}from"./PivotQuery-VQ28ggdJ.js";import{a as Ve,i as P,n as F,r as He,t as Ue}from"./statsWorker-JK_YVXSy.js";function We(e,t){if(!e.view)throw new b(`${t}:missing-parameters`,`'view' parameter is required for binning`);if(e.sqlExpression)throw new b(`${t}:invalid-parameters`,`'sqlExpression' parameter is not supported for binning`);if(e.view.type===`3d`)throw new b(`${t}:invalid-parameters`,`3d view is not supported for binning`)}var I=class e{constructor(){this.connection=null}async open(e){this.connection=await s(`statsWorker`,{strategy:`distributed`,signal:e})}destroy(){this.connection?.close()}static getInstance(){return e.instance||=new e,e.instance}async summaryStatistics(e,t){if(!this.connection)throw new b(`worker-client:summary-statistics`,`connection is required`);return this.connection.invoke(`summaryStatistics`,{attribute:e,features:t})}async uniqueValues(e,t){if(!this.connection)throw new b(`worker-client:unique-values`,`connection is required`);return this.connection.invoke(`uniqueValues`,{attribute:e,features:t})}async classBreaks(e,t){if(!this.connection)throw new b(`worker-client:class-breaks`,`connection is required`);return this.connection.invoke(`classBreaks`,{attribute:e,features:t})}async histogram(e,t){if(!this.connection)throw new b(`worker-client:histogram`,`connection is required`);return this.connection.invoke(`histogram`,{attribute:e,features:t})}async heatmapStatistics(e,t){if(!this.connection)throw new b(`worker-client:heatmap-statistics`,`connection is required`);return this.connection.invoke(`heatmapStatistics`,{attribute:e,features:t})}};async function Ge(e,t,n,r,i){return Je(t,await Ke(e,t,n,r,i),n,r)}async function Ke(e,t,n,r,i){let a={...r},o=Ye(t,n),s=t.outStatistics?.[0]!=null,c=re(`featurelayer-pbf-statistics`),l=!s||c,u;if(n?.format===`pbf`&&l)try{u=await Ee(e,o,a,i)}catch(e){if(e.name!==`query:parsing-pbf`)throw e;n.format=`json`}return n?.format!==`json`&&l||(u=await Te(e,o,a,i)),qe(n?.fieldsIndex,u.fields),u}function qe(e,t){if(e!=null&&t!=null)for(let n of t){let t=e.get(n.name);t&&Object.assign(n,t.toJSON())}}async function Je(e,t,n,r){let a=n?.infoFor3D;if(!Xe(e,a)||a==null||!t.assetMaps||!t.features?.length)return _.fromJSON(t);let{meshFeatureSetFromJSON:o}=await de(i(()=>import(`./meshFeatureSet-CBr8Bp39.js`),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30])),r);return o(e,a,t)}function Ye(e,t){let n=r.from(e);n.sourceSpatialReference=n.sourceSpatialReference??t?.sourceSpatialReference??null,(t?.gdbVersion||t?.dynamicDataSource)&&(n=n===e?n.clone():n,n.gdbVersion=e.gdbVersion||t.gdbVersion,n.dynamicDataSource=e.dynamicDataSource?g.from(e.dynamicDataSource):t.dynamicDataSource);let i=t?.infoFor3D;if(i!=null&&Xe(e,i)){n=n===e?n.clone():n,n.formatOf3DObjects=null;let t=ne(i),r=pe(i);for(let e of i.queryFormats){if(e===t){n.formatOf3DObjects=e;break}e!==r||n.formatOf3DObjects||(n.formatOf3DObjects=e)}if(!n.formatOf3DObjects)throw new b(`query:unsupported-3d-query-formats`,`Could not find any supported 3D object query format. Only supported formats are 3D_glb and 3D_gltf`);if(n.outFields==null||!n.outFields.includes(`*`)){n=n===e?n.clone():n,n.outFields??=[];let{originX:t,originY:r,originZ:a,translationX:o,translationY:s,translationZ:c,scaleX:l,scaleY:u,scaleZ:d,rotationX:f,rotationY:p,rotationZ:m,rotationDeg:h}=i.transformFieldRoles;n.outFields.push(t,r,a,o,s,c,l,u,d,f,p,m,h)}}return n}function Xe(e,t){return t!=null&&!0===e.returnGeometry&&e.multipatchOption!==`xyFootprint`&&!e.outStatistics}async function Ze(e,t,n,r){let i=ge(e),{source:a,checkValueRange:o}=t,{classificationDefinition:s}=n,c={...n.toJSON(),f:`json`},l=null;if(l=s?.type===`class-breaks-definition`?s.classificationField:s?.attributeField,a){let e={source:a?.toJSON()};c.layer=JSON.stringify(e)}c.classificationDef&&=JSON.stringify(c.classificationDef);let u={query:c};r&&(u={...r,...u});let d={url:i.path,field:l,checkValueRange:o},f=i.path+`/generateRenderer`;return y(f,u).then(e=>Qe(d,e))}function Qe(e,t){let{field:n,checkValueRange:i,url:a}=e,o=t?.data;if(!o)return;if(!i){let e=$e(o);return Promise.resolve(e)}let s=new T({statisticType:`min`,onStatisticField:n}),c=new T({statisticType:`max`,onStatisticField:n}),l=new r({outStatistics:[s,c]});return Ge(a,l).then(e=>{let t=e.features[0].attributes,n=null,r=null;for(let e in t)e.toLowerCase().startsWith(`min`)?n=t[e]:r=t[e];return $e(o,n,r)})}function $e(e,t,n){if(e.type===`classBreaks`){let r=x(e);return{classBreaks:r.classBreakInfos.map((e,i)=>(i===0&&t!=null&&(e.minValue=t),i===r.classBreakInfos.length-1&&n!=null&&(e.maxValue=n),{minValue:e.minValue,maxValue:e.maxValue,label:e.label})),normalizationTotal:r.normalizationTotal}}let{uniqueValueInfos:r}=e;return{uniqueValues:r?.map((e,i)=>(i===0&&t!=null&&(e.value=t),i===r.length-1&&n!=null&&(e.value=n),{count:e.count,value:e.value,label:e.label}))??[]}}var L=class extends me{constructor(e){super(e),this.classificationDefinition=null,this.where=null}};n([p({json:{name:`classificationDef`,write:!0}})],L.prototype,`classificationDefinition`,void 0),n([p({type:String,json:{write:!0}})],L.prototype,`where`,void 0),L=n([C(`esri.rest.support.GenerateRendererParameters`)],L);var R=class extends me{constructor(e){super(e),this.type=`unique-value-definition`,this.attributeField=null,this.attributeField2=null,this.attributeField3=null,this.fieldDelimiter=null}get uniqueValueFields(){let e=[];return this.attributeField&&e.push(this.attributeField),this.attributeField2&&e.push(this.attributeField2),this.attributeField3&&e.push(this.attributeField3),e}};n([d({uniqueValueDef:`unique-value-definition`})],R.prototype,`type`,void 0),n([p()],R.prototype,`attributeField`,void 0),n([p()],R.prototype,`attributeField2`,void 0),n([p()],R.prototype,`attributeField3`,void 0),n([p({json:{write:!0}})],R.prototype,`fieldDelimiter`,void 0),n([p({json:{write:!0}})],R.prototype,`uniqueValueFields`,null),R=n([C(`esri.rest.support.UniqueValueDefinition`)],R);var et=`no_dominant_category`;function tt(e){return{expression:nt(e,{returnFieldName:!0,defaultValue:`'${et}'`})}}function nt(e,t){let{returnFieldName:n,defaultValue:r,layer:i}=t,a=[];if(n&&r){let t=e.map(e=>`${e} <= 0`).join(` AND `);a.push(`WHEN ${t} THEN ${r}`)}for(let t of e){let r=e.reduce((e,n)=>(t!==n&&e.push(`${t} > ${n}`),e),[]).join(` AND `),o=i&&ke(i,t),s=n&&`'${t}'`?`'${t}'`:o?A(t):t;a.push(`WHEN ${r} THEN ${s}`)}return`CASE ${a.join(` `)} ELSE ${r||`0`} END`}function rt(e){return e&&e.map(e=>`$feature["${e}"];`).join(`
`)+`
`||``}function it(e,t=!1){let n=e.map(e=>`"${e}"`);return`\n  var fieldNames = [ ${n.join(`, `)} ];\n  var numFields = ${n.length};\n  var maxValueField = null;\n  var maxValue = -Infinity;\n  var value, i, totalValue = null;\n\n  for(i = 0; i < numFields; i++) {\n    value = $feature[fieldNames[i]];\n\n    if(value > 0) {\n      if(value > maxValue) {\n        maxValue = value;\n        maxValueField = fieldNames[i];\n      }\n      else if (value == maxValue) {\n        maxValueField = null;\n      }\n    }\n    ${t?`
  if(value != null && value >= 0) {
    if (totalValue == null) { totalValue = 0; }
    totalValue = totalValue + value;
  }
  `:``}\n  }\n  `}function at(e){let t=it(e);return`\n  ${rt(e)}\n  ${t}\n  return maxValueField;\n  `}var z=class extends ie{constructor(e){super(e),this.adapterName=`layer-adapter`}};n([p({readOnly:!0})],z.prototype,`adapterName`,void 0),n([p({constructOnly:!0})],z.prototype,`layer`,void 0),n([p()],z.prototype,`geometryType`,void 0),n([p()],z.prototype,`objectIdField`,void 0),n([p()],z.prototype,`supportsSQLExpression`,void 0),n([p()],z.prototype,`hasQueryEngine`,void 0),n([p()],z.prototype,`minScale`,void 0),n([p()],z.prototype,`maxScale`,void 0),n([p()],z.prototype,`fullExtent`,void 0),z=n([C(`esri.smartMapping.support.adapters.LayerAdapter`)],z);var ot=/_value$/i,st=Math.LOG10E,ct={SECOND:1e3,MINUTE:6e4,HOUR:36e5};function B(e){return e.map(e=>e.toJSON())}function lt(e,t){let n=[],r=e.layer,i=`featureReduction`in r?r.featureReduction:null,a=i?.type===`binning`,o=i!=null&&`fields`in i?i.fields?.map(e=>e.name?.toLowerCase()).filter(Boolean):[];if(!a||!t)return n;for(let e of t)o.includes(e.toLowerCase())||n.push(e);return n}function V(e,t,n){let r=[];if(t)for(let i of t){let t=e.getField(i);t&&n&&`availableFields`in n&&!n.availableFields?.includes(t.name)&&r.push(t.name)}return r}function H(e,t){let n=e&&e.features;if(n?.length===0)return{avg:null,count:0,max:null,median:null,min:null,nullcount:0,stddev:null,sum:null,variance:null};let r=n?.[0]?.attributes,i={};for(let e in r)i[e.replace(ot,``).toLowerCase()]=r[e];return i.totalcount!=null&&i.totalcount>=i.count&&(i.nullcount=i.totalcount-i.count),delete i.totalcount,i.min===i.max&&i.min!=null&&i.stddev==null&&(i.stddev=i.variance=0),t&&([`min`,`max`,`avg`,`stddev`,`sum`,`variance`].forEach(e=>{i[e]!=null&&(i[e]=Math.ceil(i[e]))}),i.min===i.max&&i.min!=null&&(i.avg=i.min,i.stddev=i.variance=0)),i}function ut(e){let t=[],n=e.classBreaks,r=n[0].minValue,i=n[n.length-1].maxValue;n.forEach(e=>{t.push([e.minValue,e.maxValue])});let a={field:e.field,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,layer:e.layer};return{min:r,max:i,intervals:t,sqlExpr:U(a),excludeZerosExpr:e.where,normTotal:e.normalizationTotal}}function U(e){let{field:t,normalizationType:n,normalizationField:r,normalizationTotal:i,layer:a}=e,o=ke(a,t),s=t;return n===`percent-of-total`?s=`((${o?A(t):t} / ${i}) * 100)`:n===`log`?s=`(log(${t}) * ${st})`:n===`field`?s=`(${o?A(t):t} / ${r})`:n===`natural-log`?s=`(log(${o?A(t):t}))`:n===`square-root`&&(s=`(power(${o?A(t):t}, 0.5))`),s}function dt(e,t){let n;if(t=t.toLowerCase(),e){for(let r in e)if(r.toLowerCase()!==t){n=e[r];break}}return n}function W(e,t){let n;if(t=t.toLowerCase(),e){for(let r in e)if(r.toLowerCase()===t){n=e[r];break}}return n}function ft(e,t,n,r,i){let a={},o=`countOFExpr`;e&&e.features&&e.features.forEach(e=>{let t=e.attributes,n=dt(t,o),r=W(t,o);n!=null&&r!=null&&n!==0&&(a[n]=r)});let s=[];return Se(t,n,r).forEach((e,t)=>{let n=(t+1).toString();s.push({minValue:e[0],maxValue:e[1],count:a.hasOwnProperty(n)?a[n]:0})}),{bins:s,minValue:t,maxValue:n,normalizationTotal:i}}async function pt(e,t){let n=e&&e.features,{field:r,field2:i,field3:a,fieldDelimiter:o,layer:s,view:c,signal:l,labels:u}=t,d=`countOF${(!r||!i)&&r||`Expr`}`,f={},p=!1;for(let e of n){let t=e.attributes,n=W(t,d),s=r?W(t,r):dt(t,d),c=i?W(t,i):null,l=a?W(t,a):null;s===null&&n===0&&(p=!0),(s==null||typeof s==`string`&&s.trim()===``)&&(s=null),i&&(c==null||typeof c==`string`&&c.trim()===``)&&(c=null),a&&(l==null||typeof l==`string`&&l.trim()===``)&&(l=null);let u=s;i&&(u=`${be(u)}${o}${be(c)}`,a&&(u=`${u}${o}${be(l)}`)),f[u]==null?f[u]={count:n,data:u}:f[u].count=f[u].count+n}if(r&&p){let e=r+` is NULL`;try{let t=await s.queryFeatureCount({whereClause:e,view:c,signal:l});return f.null.count=f.null.count+t,mt(f,u)}catch{return S(l),mt(f,u)}}return mt(f,u)}function mt(e,t){if(t)for(let n in e)e[n].label=t[n];return{count:e}}async function ht(e,t,n){let r=e?n.getField(e):null,i=r?n.getFieldDomain(r.name):null;if(i)return i;let{uniqueValueInfos:a}=await n.uniqueValues({field:e,sqlWhere:t.sqlWhere,features:t.features,useFeaturesInView:t.useFeaturesInView,view:t.view,signal:t.signal}),o=a.map(e=>new h({code:e.value}));return new m({codedValues:o})}async function G(e,t){if(!e.returnAllCodedValues)return[];let{field:n,field2:r,field3:i}=e;if(n&&!r){let e=n?t.getField(n):null,r=e?t.getFieldDomain(e.name):null;return r?[r]:[]}let a=[];return n&&(a.push(ht(n,e,t)),r&&(a.push(ht(r,e,t)),i&&a.push(ht(i,e,t)))),Promise.all(a)}function gt(e,t){return Ae(e,new Date(0),t,`milliseconds`).sqlExpression}function _t(e,t){return`EXTRACT(${t} FROM ${e}) * ${ct[t]}`}function vt(e){return e?A([`HOUR`,`MINUTE`,`SECOND`].map(t=>`(${_t(e,t)})`).join(` + `)):null}function K(e){return{viewingMode:e.type===`2d`?`map`:e.viewingMode,scale:e.scale,spatialReference:e.spatialReference?.toJSON()}}function yt(e,t){let n=new Set(e.map(e=>e.value)),r=t.filter(e=>!n.has(e));for(let t of r)e.push({value:t,count:0});e.sort((e,n)=>t.indexOf(e.value)-t.indexOf(n.value));for(let t of e)t.value===`no_dominant_category`&&(t.value=null);return{predominantCategoryInfos:e}}function bt(e){let n=`featureReduction`in e?e.featureReduction:null;return((n!=null&&`fields`in n?n.fields:null)??[]).map(n=>{let r=xt(n,e.fieldsIndex);return r?new t({type:r,name:n.name,alias:n.alias}):null}).filter(ce)}function xt(e,t){switch(e.statisticType){case`avg`:case`avg_angle`:return`double`;case`count`:return`integer`;case`min`:case`max`:case`sum`:return e.onStatisticField?t.get(e.onStatisticField)?.type??null:e.onStatisticExpression?e.onStatisticExpression.returnType===`string`?null:`double`:null;case`mode`:return e.onStatisticField?t.get(e.onStatisticField)?.type??null:e.onStatisticExpression?e.onStatisticExpression.returnType===`string`?`string`:`double`:null;default:return null}}function St(e,t){return O(t)?gt(e,t?.name):w(t)?vt(t?.name):null}function Ct(e,t,n){let r=null;for(let i of n){let n=i?e.getField(i):null,a=q(e,{...t,field:i,outStatisticTypes:{include:[`min`,`max`,`sum`,`count`]}},n,!0,!0);r?r.outStatistics=r.outStatistics.concat(a.outStatistics):r=a}return r.where=e.createQuery()?.where,r}function wt(e,t,n,r){return t.map(t=>{let i=new T,a=null,o=null,s=`${t}_value${r?`_${r}`:``}`;if(t===`variance`)a=`var`,o=n;else if(t===`nullcount`){let t=e.objectIdField;a=`count`,o=t&&e.getField(t)?t:`1`,s=`totalcount_value`}else t===`median`?(a=`percentile-continuous`,o=n,i.statisticParameters={value:.5}):(a=t,o=n);return i.statisticType=a,i.onStatisticField=o,i.outStatisticFieldName=s,i})}function q(e,t,n,r=!0,i=!1){let{field:a,normalizationType:o,normalizationField:s,normalizationTotal:c,minValue:l,maxValue:u,filter:d}=t,f=e.supportsSQLExpression?St(e,n)||t.sqlExpression:null,p=U({field:a,normalizationType:o,normalizationField:s,normalizationTotal:c,layer:e}),m=f||p,h=m?j(m,l,u):null,g=N({field:a,normalizationField:s,normalizationType:o}),_=M(t.sqlWhere,g),y=M(_,h),ee=we({normalizationField:s,normalizationType:o,sqlExpression:f,supportsSQLExpression:e.supportsSQLExpression,minValue:l,maxValue:u}),b=v(e.getField(a??void 0)),{include:te,exclude:ne}=t.outStatisticTypes||{},re=xe.filter(e=>(!te||te.includes(e))&&(!ne||!ne.includes(e))&&(e===`nullcount`?ee:!b||e===`count`)&&(e!==`median`||r)),x=e.createQuery();return x.where=M(x.where,y),x.sqlFormat=f?`standard`:null,x.outStatistics=wt(e,re,m,i?a:void 0),J(x,d),x}function Tt(e,t,n=!0){let{fields:r,filter:i}=t,{include:a,exclude:o}=t.outStatisticTypes||{},s=xe.filter(e=>(!a||a.includes(e))&&(!o||!o.includes(e))&&(e!==`median`||n)),c=new Be;c.where=M(e.createQuery()?.where,t.sqlWhere)??void 0;let l=`new_value`;return c.outPivots=[new ze({sourceFields:r,valueFieldName:l})],c.outStatistics=wt(e,s,l),J(c,i),c}function J(e,t){t&&(e.geometry=t.geometry,e.spatialRelationship=t.spatialRelationship,e.timeExtent=e.timeExtent?.intersection(t.timeExtent)??t.timeExtent,e.distance=t.distance,e.units=t.units)}function Et(e,t){let{field:n,field2:r,field3:i,sqlExpression:a}=t,o=!(!n||!r),s=e.createQuery();return s.where=M(s.where,t.sqlWhere),s.sqlFormat=a?`standard`:null,s.outStatistics=[Dt(o?null:n,o?`1`:a)].filter(Boolean),s.groupByFieldsForStatistics=[n||a,r,i].filter(Boolean),J(s,t.filter),s}function Dt(e,t){let n=`countOF`+(e||`Expr`),r=new T;return r.statisticType=`count`,r.onStatisticField=t?`1`:e,r.outStatisticFieldName=n,r}function Y(e,t,n,r=10,i,a,o){let{min:s,max:c,normTotal:l,excludeZerosExpr:u}=t,d=t.intervals||Se(s,c,r),f=t.sqlExpr||n;return Ot(e,d,f,u,i,a,o).then(e=>({bins:e.map((e,t)=>({minValue:d[t][0],maxValue:d[t][1],count:e.status===`fulfilled`?e.value:0})),minValue:s,maxValue:c,normalizationTotal:l}))}function Ot(e,t,n,r,i,a,o){let s=[],c=t.length;for(let e=0;e<c;e++){let i=M(r,M(n+` >= `+t[e][0],t[e][1]===null?``:n+(e===c-1?` <= `:` < `)+t[e][1]));s.push(i)}return Promise.allSettled(s.map(t=>e.queryFeatureCount({whereClause:t,view:i,filter:a,signal:o})))}var kt=`countOFExpr`,At=`lowerBoundary`,jt=`upperBoundary`;function Mt(e,t,n){let r=e.valueExpression||e.sqlExpression,i=e.signal;if(!r){let{field:r,normalizationType:a,normalizationField:o}=e,s=r?t.getField(r):null,c=O(s)||w(s);return{sqlExpression:c?St(t,s):U({field:r,normalizationType:a,normalizationField:o,normalizationTotal:n,layer:t}),sqlWhere:c?null:e.sqlWhere||N({field:r,normalizationType:a,normalizationField:o}),filter:e.filter,signal:i}}return{valueExpression:e.valueExpression,sqlExpression:e.sqlExpression,sqlWhere:e.sqlWhere,filter:e.filter,signal:i}}async function Nt(e,t,n){let{field:r,normalizationType:i,normalizationField:a,signal:o}=e,s=N({field:r,normalizationType:i,normalizationField:a}),c=new L({classificationDefinition:ye({field:r,normalizationType:i,normalizationField:a,classificationMethod:e.classificationMethod,standardDeviationInterval:e.standardDeviationInterval,definedInterval:e.definedInterval,breakCount:e.numBins||10}),where:M(s,n)});return t.generateRenderer(c,o).then(e=>{let{normalizationTotal:n,classBreaks:o}=e;return ut({field:r,normalizationType:i,normalizationField:a,normalizationTotal:n,classBreaks:o,where:s,layer:t})})}async function Pt(e,t,n,r,i){let{field:a,sqlExpression:o,normalizationField:s,classificationMethod:c,normalizationType:l}=e,u=a?t.getField(a):null,d=w(u),f=ue(u)||d,p=e.numBins||10;if(f){if(l||c)throw new b(`${t.adapterName}:not-supported`,`NormalizationType and classificationMethod are not supported for date-only and time-only fields`);let e=(r-n)/p/1e3,i=e/86400;return new Ie({field:a,expression:o,interval:{unit:d?`seconds`:`days`,value:Math.ceil(d?e:i)},start:n,end:r})}if(c===`defined-interval`)return new Le({field:a,expression:o,normalizationField:s,normalizationTotal:i,normalizationType:l,interval:e.definedInterval??Math.ceil((r-n)/p),start:l?null:n,end:l?null:r,normalizationMinValue:l?n:null,normalizationMaxValue:l?r:null});if(c===`manual`)throw new b(`${t.adapterName}:not-supported`,`Layer does not support manual classificationMethod`);if(c===`natural-breaks`||c===`quantile`||c===`standard-deviation`){let r=U({field:a,normalizationField:s,normalizationTotal:i,normalizationType:l,layer:t}),c=e.minValue!==null&&e.maxValue!==null?j(r,e.minValue,e.maxValue):void 0,u=await Nt(e,t,c);if(!u.intervals)throw new b(`${t.adapterName}:invalid`,`Invalid intervals returned from generate renderer`);let d=[n,...u.intervals.map(e=>e[1])];return new Fe({field:l?null:a,expression:l?r:o,boundaries:d})}return new Pe({field:a,normalizationField:s,normalizationTotal:i,normalizationType:l,expression:o,numBins:p,start:l?null:n,end:l?null:r,normalizationMinValue:l?n:null,normalizationMaxValue:l?r:null})}function Ft(e,t,n,r){return n!=null&&r!=null?Promise.resolve({min:n,max:r}):t.summaryStatistics({...e,outStatisticTypes:{include:[`min`,`max`]}}).then(e=>({min:e.min,max:e.max}))}async function It(e,t,n,r){let{field:i,minValue:a,maxValue:o,filter:s,view:l}=e,u=i?t.getField(i):null,d=c(u)||te(u),f=Mt(e,t,n),{min:p,max:m}=await Ft(f,t,a,o);if(p==null||m==null)return{query:null,min:p,max:m};let h=new T({statisticType:`count`,outStatisticFieldName:kt,onStatisticField:`1`}),{where:g,timeExtent:_}=r||{},v=M(g,f.sqlWhere),y=new Re({binParameters:await Pt(e,t,p,m,n),outStatistics:[h],binOrder:e.sortOrder,where:v,timeExtent:_,lowerBoundaryAlias:`lowerBoundary`,upperBoundaryAlias:`upperBoundary`,outTimeZone:l?.timeZone&&d?le(l.timeZone):null});return J(y,s),{query:y,min:p,max:m}}function Lt(e,t=!1){return typeof e==`string`?(t?new Date(`1970-01-01T${e}Z`):new Date(e)).getTime():e}function Rt(e,t,n){let r=w(t);return{...n,bins:e.features.map(e=>({minValue:Lt(e.attributes[At],r),maxValue:Lt(e.attributes[jt],r),count:e.attributes[kt]}))}}function zt(e,t,n){let{valueExpression:r,view:i}=e,{featuresJSON:a,graphics:o,fieldInfos:s}=t,c={field:e.field,valueExpression:r,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:n,minValue:e.minValue,maxValue:e.maxValue,standardDeviationInterval:e.standardDeviationInterval,classificationMethod:e.classificationMethod,numBins:e.numBins};return r&&i&&(a||o)&&(c.viewInfoParams=K(i),c.timeZone=i.timeZone,c.fieldInfos=s),c}var Bt=5,X=null,Z=class extends z{constructor(){super(...arguments),this._hasLocalSource=!1,this.adapterName=`in-memory-layer-adapter`}destroy(){this.workerClient?.destroy()}async _waitForLayerViewUpdate(e){if(!e)throw new b(`${this.adapterName}:insufficient-data`,`layerView is required to fetch the features`);let t=new AbortController,n=l(()=>!e.updating,t.signal);await u(n,5e3,t).catch(e=>{throw he.getLogger(this).warn(`LayerView is taking too long to update. Aborting fetch from layerView.`),e})}async _fetchFeatureSetFromMemory(e,t,n){let r=this.layer;if(this._hasLocalSource&&`queryFeatures`in r)return r.queryFeatures(e);if(!t)throw new b(`${this.adapterName}:insufficient-data`,`view is required to fetch the features from layerView`);let i=await t.whenLayerView(this.layer);return await this._waitForLayerViewUpdate(i),i.queryFeatures(e,{signal:n})}async _fetchFeaturesFromMemory(e,t,n,r){let i=this.layer,a=r===`json`;if(this._hasLocalSource&&`queryFeatures`in i){let e=await i.queryFeatures(t);return a?B(e.features):e.features}if(await this._waitForLayerViewUpdate(e),a&&`queryFeaturesJSON`in e&&e.queryFeaturesJSON){let{features:r}=await e.queryFeaturesJSON(t,{signal:n});return r}if(!(`queryFeatures`in e))throw new b(`${this.adapterName}:not-supported`,`'queryFeatures' is not supported on the layerView`);let o=await e.queryFeatures(t,{signal:n});return a?B(o.features):o.features}_fetchFeaturesForStats(e,t){return k({field:e.field,field2:e.field2,field3:e.field3,normalizationField:e.normalizationField,valueExpression:e.valueExpression}).then(n=>this.getSampleFeatures({sampleSize:-1,view:e.view,returnGeometry:e.returnGeometry,filter:e.filter,requiredFields:n,signal:e.signal},t))}async _summaryStatsFromClientQuery(e,t){let{view:n,signal:r}=e,i=q(this,e,t),a=await this._fetchFeatureSetFromMemory(i,n,r),o=H(a,O(t)||w(t));return E(o,e.outStatisticTypes)}async _getNormalizationTotalFromMemory(e,t,n){let{featuresJSON:r,graphics:i,layerView:a,query:o}=t,s={include:[`sum`]},c=(!r&&!i&&a&&`querySummaryStatistics`in a?await a.querySummaryStatistics(o,{field:e},{signal:n}):r?await this.workerClient.summaryStatistics({field:e,outStatisticTypes:s},r):await F({attribute:{field:e,outStatisticTypes:s},features:i??[]})).sum;if(c==null)throw new b(`${this.adapterName}:invalid`,`invalid normalizationTotal`);return c}async _summaryStatsFromMemory(e,t){let{view:n,field:r,valueExpression:i,normalizationType:a,signal:o}=e,s={field:r,valueExpression:i,normalizationType:a,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,outStatisticTypes:e.outStatisticTypes},{featuresJSON:c,graphics:l,layerView:u,query:d,fieldInfos:f}=await this._processStatsFromMemoryParams({...e,layerViewFunc:`querySummaryStatistics`});return i&&n&&(c||l)&&(s.fieldType=t?.type?ae.toJSON(t.type):null,s.viewInfoParams=K(n),s.timeZone=n.timeZone,s.fieldInfos=f),a===`percent-of-total`&&e.normalizationTotal==null&&(s.normalizationTotal=await this._getNormalizationTotalFromMemory(r,{featuresJSON:c,graphics:l,layerView:u,query:d},o)),!c&&!l&&u&&`querySummaryStatistics`in u?u.querySummaryStatistics(d,s,{signal:o}):c?this.workerClient.summaryStatistics(s,c):F({attribute:s,features:l})}async _getFilteredFeatures(e,t){let n=e,r=t?.geometry;if(t?.spatialRelationship===`intersects`&&r){let t=await i(()=>import(`./intersectionOperator-Fa-8HuJM.js`),__vite__mapDeps([31,32,1,2,33,34,35,36,37,38,39,40,41]));n=e.filter(({geometry:e})=>!(!e||!t.execute(e,r)))}return e.length&&`declaredClass`in e[0]&&e[0].declaredClass===`esri.Graphic`?{graphics:n}:{featuresJSON:n}}async _processStatsFromMemoryParams(e){let{features:t,filter:n}=e;if(t?.length)return this._getFilteredFeatures(t,n);let{view:r,field:i,field2:a,field3:o,normalizationField:s,valueExpression:c,layerViewFunc:l,signal:u}=e,d=e.returnGeometry;if(d==null&&c){if(!X){let{arcadeUtils:e}=await se();X=e}let e=X.hasGeometryOperations(c);e&&await X.enableGeometryOperations(),d=e}let f=null,p=null,m=null,h=null,g=null;if(r)try{let e=this.layer.type===`subtype-sublayer`?this.layer.parent:this.layer;f=await r.whenLayerView(e),p=l!=null&&f!=null&&l in f&&typeof f[l]==`function`}catch{p=!1}if(p)try{await this._waitForLayerViewUpdate(f);let e=await k({field:i,field2:a,field3:o,normalizationField:s,valueExpression:c});V(this,e,f).length?p=!1:(m=this.layer.createQuery(),m.outFields=e,m.returnGeometry=!1,J(m,n)),f.suspended&&(p=!1)}catch{p=!1}return p||(h=await this._fetchFeaturesForStats({field:i,field2:a,field3:o,valueExpression:c,normalizationField:s,returnGeometry:d,filter:n,view:r,signal:u},`json`),g=(await k({valueExpression:c})).map(e=>this.getField(e)?.toJSON()).filter(Boolean)),{layerView:f,query:m,featuresJSON:h,fieldInfos:g}}async _uvFromClientQuery(e,t){let{view:n,signal:r}=e,i=Et(this,e),a=await this._fetchFeatureSetFromMemory(i,n,r),o=await pt(a,{layer:this,field:e.field,field2:e.field2,field3:e.field3,fieldDelimiter:`,`,view:e.view,signal:e.signal});return D(o,t,e.returnAllCodedValues,`,`)}async _uvFromMemory(e,t){let{view:n,field:r,valueExpression:i,returnAllCodedValues:a,signal:o}=e,{featuresJSON:s,graphics:c,layerView:l,query:u,fieldInfos:d}=await this._processStatsFromMemoryParams({...e,layerViewFunc:`queryUniqueValues`}),f={field:r,field2:e.field2,field3:e.field3,fieldDelimiter:`,`,valueExpression:i,domains:t,returnAllCodedValues:a};return i&&n&&(s||c)&&(f.viewInfoParams=K(n),f.timeZone=n.timeZone,f.fieldInfos=d),!s&&!c&&l&&`queryUniqueValues`in l?l.queryUniqueValues(u,f,{signal:o}):s?this.workerClient.uniqueValues(f,s):He({attribute:f,features:c})}_histogramForField(e){let t=null;return t=e.minValue!=null&&e.maxValue!=null?Promise.resolve({min:e.minValue,max:e.maxValue}):this.summaryStatistics({...e,outStatisticTypes:{include:[`min`,`max`,`count`]}}).then(e=>{if(!e.count)throw new b(`${this.adapterName}:insufficient-data`,`Either the layer has no features or none of the features have data for the field`);return{min:e.min,max:e.max}}),t.then(t=>Y(this,{min:t.min,max:t.max},e.field,e.numBins??void 0,e.view,e.filter,e.signal))}async _histogramFromQueryAttributeBinsFromMemory(e){let{field:t,normalizationType:n,signal:r}=e,i=await this._processStatsFromMemoryParams({...e,layerViewFunc:`queryAttributeBins`}),{featuresJSON:a,graphics:o,layerView:s,query:c}=i,l=n===`percent-of-total`?e.normalizationTotal??await this._getNormalizationTotalFromMemory(t,i,r):void 0;if(!s||!(`queryAttributeBins`in s)||a||o){let t=zt(e,i,l);return a?this.workerClient.histogram(t,a):P({attribute:t,features:o})}let{query:u,min:d,max:f}=await It(e,this,l,c);if(!u)return{bins:[],minValue:d,maxValue:f,normalizationTotal:l};let p=await s.queryAttributeBins(u,{signal:r});return Rt(p,t?this.getField(t):null,{minValue:d,maxValue:f,normalizationTotal:l})}async _histogramFromMemory(e){let{field:t,signal:n}=e,r=await this._processStatsFromMemoryParams({...e,layerViewFunc:`queryHistogram`}),{featuresJSON:i,graphics:a,layerView:o,query:s}=r,c=e.normalizationType===`percent-of-total`?e.normalizationTotal??await this._getNormalizationTotalFromMemory(t,r,n):void 0,l=zt(e,r,c);return!i&&!a&&o&&`queryHistogram`in o?o.queryHistogram(s,l,{signal:n}):i?this.workerClient.histogram(l,i):P({attribute:l,features:a})}_classBreaksFromInterpolation(e){let{minValue:t,maxValue:n}=e,r=e.numClasses||Bt,i=[],a=(n-t)/r;for(let e=0;e<r;e++){let n=t+e*a;i.push({minValue:n,maxValue:n+a})}i[r-1].maxValue=n;let o={classBreaks:i,normalizationTotal:e.normalizationTotal},s=Ce(o,e.classificationMethod);return Promise.resolve(s)}async _classBreaksFromMemory(e){let{view:t,field:n,valueExpression:r,signal:i}=e,{featuresJSON:a,graphics:o,layerView:s,query:c,fieldInfos:l}=await this._processStatsFromMemoryParams({...e,layerViewFunc:`queryClassBreaks`}),u={field:n,valueExpression:r,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,standardDeviationInterval:e.standardDeviationInterval,classificationMethod:e.classificationMethod,numClasses:e.numClasses};return r&&t&&(a||o)&&(u.viewInfoParams=K(t),u.timeZone=t.timeZone,u.fieldInfos=l),e.normalizationType===`percent-of-total`&&e.normalizationTotal==null&&(u.normalizationTotal=await this._getNormalizationTotalFromMemory(n,{featuresJSON:a,graphics:o,layerView:s,query:c},i)),!a&&!o&&s&&`queryClassBreaks`in s?s.queryClassBreaks(c,u,{signal:i}):a?this.workerClient.classBreaks(u,a):Ue({attribute:u,features:o})}async _heatmapStatsFromMemory(e){let{view:t,field:n,radius:r,signal:i}=e;fe(t,`InMemoryLayerAdapter: must have a view`);try{let n=await t.whenLayerView(this.layer);if(`queryHeatmapStatistics`in n&&!n.updating&&!e.filter)return await n.queryHeatmapStatistics({field:e.field,radius:e.radius})}catch{S(i)}let{featuresJSON:o,graphics:s}=await this._processStatsFromMemoryParams({...e,returnGeometry:!0}),c=new a({extent:t.extent,tolerance:t.type===`2d`?t.state.resolution:t.pixelSizeAt?.(t.center)}),l={field:n,radius:r,transform:De(c),spatialReference:t.spatialReference?.toJSON(),size:t.size};return o?.length||s?.length?o?this.workerClient.heatmapStatistics(l,o):Ve({attribute:l,features:s}):{min:null,max:null}}getField(e=``){return this.layer.getField(e)}getFieldUsageInfo(e){return this.getField(e)?{supportsLabelingInfo:!0,supportsRenderer:!0,supportsPopupTemplate:!0,supportsLayerQuery:!0,supportsStatistics:!0}:null}getFieldDomain(e,t){return this.layer.getFieldDomain(e,t)}createQuery(){return this.layer.createQuery()}async summaryStatistics(e){let{field:t,valueExpression:n,sqlExpression:r,features:i,view:a}=e,o=t?this.getField(t):null,s=!!n,c=a?.type===`3d`;if(!n&&r&&!this.supportsSQLExpression)throw new b(`${this.adapterName}:not-supported`,`Layer does not support standardized SQL expression for queries`);return s||i||c?this._summaryStatsFromMemory(e,o):this._summaryStatsFromClientQuery(e,o)}async uniqueValues(e){let{valueExpression:t,sqlExpression:n,features:r,view:i}=e,a=await G(e,this),o=!!t,s=i?.type===`3d`;if(!t&&n&&!this.supportsSQLExpression)throw new b(`${this.adapterName}:not-supported`,`Layer does not support standardized SQL expression for queries`);return o||r||s?this._uvFromMemory(e,a):this._uvFromClientQuery(e,a)}async histogram(e){let{features:t,valueExpression:n,normalizationType:r,sqlExpression:i}=e,a=t||!!n;if(!n&&i&&!this.supportsSQLExpression)throw new b(`${this.adapterName}:not-supported`,`Layer does not support standardized SQL expression for queries`);return a||r?this._histogramFromMemory(e):this._histogramForField(e)}async classBreaks(e){return!1===e.analyzeData?this._classBreaksFromInterpolation(e):this._classBreaksFromMemory(e)}async queryFeatureCount(e){let{whereClause:t,view:n,signal:r}=e;if(!n)throw new b(`${this.adapterName}:insufficient-data`,`view is required to fetch the features from layerView`);let i=this.layer.createQuery();i.where=M(i.where,t);let a=await n.whenLayerView(this.layer);return await l(()=>!a.updating,r),a.queryFeatureCount(i,{signal:r})}async generateRenderer(e,t){throw new b(`${this.adapterName}:not-supported`,`Layer does not support generateRenderer operation`)}async predominantCategories(e){let{fields:t,view:n,signal:r,filter:i}=e,a=at(t),o=await this._uvFromMemory({valueExpression:a,view:n,signal:r,filter:i});return yt(o.uniqueValueInfos,t)}async heatmapStatistics(e){return this._heatmapStatsFromMemory(e)}async getSampleFeatures(t,n){let{view:r,sampleSize:i,requiredFields:a,returnGeometry:o,filter:s,signal:c}=t,l=this.layer.createQuery();if(l.outSpatialReference=r?.spatialReference,l.returnGeometry=!!o,l.outFields=a,J(l,s),!r)throw new b(`${this.adapterName}:not-supported`,`view is required to get sample features for Layer`);let u=await r.whenLayerView(this.layer);if(V(this,a,u).length)throw new b(`${this.adapterName}:not-supported`,`Required fields need to be passed in the outFields for Layer`);let d=await this._fetchFeaturesFromMemory(u,l,c,n),f=i!=null&&i>0&&i<=d.length?i:d.length;return e(d,f,1)}load(e){let t=this.layer.load(e).then(async t=>{this.geometryType=t.geometryType,this.objectIdField=t.objectIdField,this.supportsSQLExpression=t.type===`stream`||!!t.capabilities?.query?.supportsSqlExpression,this.minScale=t.minScale,this.maxScale=t.maxScale,this.fullExtent=`fullExtent`in t?t.fullExtent:t.parent?.fullExtent,this._hasLocalSource=!1,this.hasQueryEngine=!0,this.workerClient=I.getInstance(),await this.workerClient.open(e.signal)});return this.addResolvingPromise(t),Promise.resolve(this)}};n([p({readOnly:!0})],Z.prototype,`adapterName`,void 0),n([p({constructOnly:!0})],Z.prototype,`layer`,void 0),Z=n([C(`esri.smartMapping.support.adapters.InMemoryLayerAdapter`)],Z);var Vt=5,Ht=2e4,Ut=4e5,Q=class extends Z{constructor(){super(...arguments),this.adapterName=`feature-layer-adapter`}_isStatsSupportedOnService(){let e=this.layer;if(!e.capabilities?.query?.supportsStatistics||this.geometryType===`multipatch`&&!oe(e.url)&&e.version<10.5)throw new b(`${this.adapterName}:not-supported`,`Layer does not support statistics query`);return Promise.resolve()}_fetchFeaturesFromService(e,t){return this.layer.queryFeatures(e,{signal:t}).then(e=>e.features)}_fetchFeaturesJSONFromService(e,t){return this._fetchFeaturesFromService(e,t).then(B)}_summaryStatsFromGenRend(e){let t=e.normalizationType,n=e.normalizationField;return this.classBreaks({field:e.field,numClasses:Vt,classificationMethod:`standard-deviation`,standardDeviationInterval:.25,normalizationType:t,normalizationField:t===`field`?n:void 0,minValue:e.minValue,maxValue:e.maxValue,filter:e.filter,signal:e.signal}).then(t=>{let n,r,i;if(t.classBreakInfos?.some(e=>(e.hasAvg&&(n=e),!!n)),n){let e=n.maxValue-n.minValue;r=n.minValue+e/2,i=4*e}let a={min:t.minValue,max:t.maxValue,avg:r,stddev:i};return E(a,e.outStatisticTypes)})}async _summaryStatsFromServiceQuery(e,t){await this._isStatsSupportedOnService(),e.normalizationType===`percent-of-total`&&(e.normalizationTotal=await this._getNormalizationTotal(e.field,e.normalizationType,e.filter));let n=O(t)||w(t),r=`capabilities`in this.layer?this.layer.capabilities:null,i=q(this,e,t,r?.query?.supportsPercentileStatistics??!1),a=await this.layer.queryFeatures(i,{signal:e.signal}),o=H(a,n);return E(o,e.outStatisticTypes)}async _summaryStatsForFieldsBasic(e){let{outStatisticTypes:t,fields:n}=e,r=[];for(let t=0;t<n.length;t+=50){let i=n.slice(t,t+50),a=Ct(this,e,i);r.push(this.layer.queryFeatures(a,{signal:e.signal}))}let i=(await Promise.all(r)).flatMap(e=>e.features).map(e=>e.attributes).reduce((e,t)=>Object.assign(e,t),{}),a={};for(let e in i){let t=e.match(/^(\w+)_value_/);if(!(i[e]==null||!t))switch(t[1]){case`min`:a.min=a.min==null?i[e]:Math.min(a.min,i[e]);break;case`max`:a.max=a.max==null?i[e]:Math.max(a.max,i[e]);break;case`sum`:a.sum=(a.sum||0)+i[e];break;case`count`:a.count=(a.count||0)+i[e]}}return E(a,t)}async _summaryStatsForFieldsAdvanced(e,t){let{outStatisticTypes:n,fields:r}=e,i=n?.exclude?.includes(`variance`)||n?.include&&!n.include.includes(`variance`),a=n?.exclude?.includes(`stddev`)||n?.include&&!n.include.includes(`stddev`);if(t.sum==null||!t.count||i&&a)return t;t.avg=t.sum/t.count;let o=[];for(let n=0;n<r.length;n+=50){let i=r.slice(n,n+50),a=Ct(this,e,i);a.outStatistics=[];for(let e of i){let n=`sumOfSquares_${e}`,r=`(power(${ke(this.layer,e)?A(e):e} - ${t.avg}, 2))`,i=new T({statisticType:`sum`,onStatisticField:r,outStatisticFieldName:n});a.outStatistics.push(i)}o.push(this.layer.queryFeatures(a,{signal:e.signal}))}return t.variance=(await Promise.all(o)).reduce((e,t)=>e+Object.values(t.features[0].attributes).reduce((e,t)=>e+t,0),0)/(t.count-1),t.stddev=Math.sqrt(t.variance),E(t,n)}async _summaryStatsForFields(e){let t=await this._summaryStatsForFieldsBasic(e);return this._summaryStatsForFieldsAdvanced(e,t)}async _summaryStatsUsingQueryPivot(e){await this._isStatsSupportedOnService();let t=`capabilities`in this.layer?this.layer.capabilities:null,n=Tt(this,e,t?.query?.supportsPercentileStatistics??!1),r=await this.layer.queryPivot(n,{signal:e.signal}),i=H(r,!1);return E(i,e.outStatisticTypes)}_uvFromGenRenderer(e,t){let n=e.field??void 0,r=new R({attributeField:n}),i=new L({classificationDefinition:r});return this.generateRenderer(i,e.signal).then(e=>{let t={},r=this.getField(n);return e.uniqueValues.forEach(e=>{let n=e.value;n!=null&&n!==``&&(typeof n!=`string`||n.trim()!==``&&n.toLowerCase()!==`<null>`)||(n=null),t[n]==null?t[n]={count:e.count,data:ee(r)&&n?Number(n):n}:t[n].count=t[n].count+e.count}),{count:t}}).then(n=>D(n,[t],e.returnAllCodedValues))}async _uvFromServiceQuery(e,t){return this._isStatsSupportedOnService().then(()=>this.layer.queryFeatures(Et(this,e),{signal:e.signal})).then(t=>pt(t,{layer:this,field:e.field,field2:e.field2,field3:e.field3,fieldDelimiter:`,`,view:e.view,signal:e.signal})).then(n=>D(n,t,e.returnAllCodedValues,`,`))}_getNormalizationTotal(e,t,n,r){return e&&t===`percent-of-total`?this.summaryStatistics({field:e,outStatisticTypes:{include:[`sum`]},filter:n,signal:r}).then(e=>e.sum):Promise.resolve(null)}_histogramForExpr(e){return this._getNormalizationTotal(e.field,e.normalizationType,e.filter,e.signal).then(t=>{let n=Mt(e,this,t);return Ft(n,this,e.minValue,e.maxValue).then(r=>{let i=r.min,a=r.max;if(i==null||a==null)return{bins:[],minValue:i,maxValue:a,normalizationTotal:t};let o=e.numBins||10,s=Se(i,a,o),c=Wt(n.sqlExpression,s,e.minValue!=null&&e.maxValue!=null),l=new T({statisticType:`count`,outStatisticFieldName:`countOFExpr`,onStatisticField:`1`}),u=this.layer.createQuery();return u.where=M(u.where,n.sqlWhere),u.sqlFormat=`standard`,u.outStatistics=[l],u.groupByFieldsForStatistics=[c],u.orderByFields=[c],J(u,e.filter),this._isStatsSupportedOnService().then(()=>this.layer.queryFeatures(u,{signal:n.signal})).then(e=>ft(e,i,a,o,t))})})}async _histogramForFields(e){let{min:t,max:n}=await Ft({fields:e.fields,sqlWhere:e.sqlWhere,filter:e.filter,signal:e.signal},this,e.minValue,e.maxValue);if(t==null||n==null)return{bins:[],minValue:t,maxValue:n};let r=`newField`,i=e.numBins||10,a=Wt(r,Se(t,n,i),e.minValue!=null&&e.maxValue!=null),o=new T({statisticType:`count`,outStatisticFieldName:`countOFExpr`,onStatisticField:r}),s=new Be,{where:c,timeExtent:l}=this.createQuery();return s.where=M(c,e.sqlWhere),s.outPivots=[new ze({sourceFields:e.fields,valueFieldName:r})],s.outStatistics=[o],s.groupByFieldsForStatistics=[a],s.orderByFields=[a],s.timeExtent=l,J(s,e.filter),this._isStatsSupportedOnService().then(()=>this.layer.queryPivot(s,{signal:e.signal})).then(e=>ft(e,t,n,i))}async _histogramFromQueryAttributeBins(e){let{field:t,normalizationType:n,filter:r,signal:i}=e,a=await this._getNormalizationTotal(t,n,r,i),{query:o,min:s,max:c}=await It(e,this,a,this.createQuery());if(!o)return{bins:[],minValue:s,maxValue:c,normalizationTotal:a};let l=await this.layer.queryAttributeBins(o,{signal:i});return Rt(l,t?this.getField(t):null,{minValue:s,maxValue:c,normalizationTotal:a})}_classBreaksFromGenRend(e){let{field:t,normalizationType:n,normalizationField:r,normalizationTotal:i,signal:a}=e,o=N({field:t,normalizationType:n,normalizationField:r}),s=U({field:t,normalizationType:n,normalizationField:r,normalizationTotal:i,layer:this}),c=j(s,e.minValue,e.maxValue),l=ye({field:t,normalizationType:n,normalizationField:r,classificationMethod:e.classificationMethod,standardDeviationInterval:e.standardDeviationInterval,breakCount:e.numClasses||Vt}),u=new L({classificationDefinition:l});return u.where=M(o,c),this.generateRenderer(u,a).then(t=>Ce(t,e.classificationMethod))}async summaryStatistics(e){let{field:t,fields:n,normalizationType:r,valueExpression:i,sqlExpression:a,view:o,features:s,useFeaturesInView:c}=e,l=t?this.getField(t):null,u=O(l)||w(l),d=i&&!(a&&this.supportsSQLExpression),f=this._hasLocalSource||s||c,p=o&&o.type===`3d`;if(n?.length){let t={...e,fields:n};if(!this.layer.capabilities?.operations?.supportsQueryPivot)return await this._summaryStatsForFields(t);try{return await this._summaryStatsUsingQueryPivot(t)}catch{return await this._summaryStatsForFields(t)}}if(f||d)return d||s||c||p||this._hasLocalSource&&!this.layer.capabilities.query.supportsStatistics?this._summaryStatsFromMemory(e,l):this._summaryStatsFromClientQuery(e,l);if(!this.supportsSQLExpression&&(u||a||r===`natural-log`||r===`square-root`))throw new b(`${this.adapterName}:not-supported`,`Layer does not support standardized SQL expression for queries`);return(r&&!this.supportsSQLExpression?this._summaryStatsFromGenRend(e):this._summaryStatsFromServiceQuery(e,l)).catch(()=>(S(e.signal),this._summaryStatsFromMemory(e,l)))}async uniqueValues(e){let{valueExpression:t,sqlExpression:n,features:r,useFeaturesInView:i,signal:a}=e,o=t&&!(n&&this.supportsSQLExpression),s=this._hasLocalSource||r||i||o,c=e.view,l=c&&c.type===`3d`,u=await G(e,this);return s?o||r||i||l||this._hasLocalSource&&!this.layer.capabilities.query.supportsStatistics?this._uvFromMemory(e,u):this._uvFromClientQuery(e,u):this._uvFromServiceQuery(e,u).catch(t=>(S(a),!e.field||e.field2||e.field3||e.filter?t:this._uvFromGenRenderer(e,u[0]))).catch(()=>(S(a),l?this._uvFromMemory(e,u):this._uvFromClientQuery(e,u)))}async histogram(e){let{field:t,normalizationType:n,normalizationField:r,classificationMethod:i,view:a,filter:o,signal:s}=e,c=t?this.getField(t):null,l=O(c)||w(c),u=e.valueExpression||e.sqlExpression,d=e.valueExpression&&!(e.sqlExpression&&this.supportsSQLExpression),f=this._hasLocalSource||e.features||e.useFeaturesInView||d,p=this.supportsSQLExpression,m=!i||i===`equal-interval`,h=e.minValue,g=e.maxValue,_=h!=null&&g!=null,v=e.numBins||10;if(e.fields?.length){if(!p)throw new b(`${this.adapterName}:not-supported`,`Layer does not support standardized SQL expression for queries`);if(!this.layer.capabilities?.operations?.supportsQueryPivot)throw new b(`${this.adapterName}:not-supported`,`Layer does not support pivot queries`);return this._histogramForFields(e)}if(f)return this._histogramFromMemory(e);if(this.layer.capabilities?.operations?.supportsQueryBins&&e.useQueryAttributeBins)try{return await this._histogramFromQueryAttributeBins(e)}catch{return S(s),this._histogramFromQueryAttributeBinsFromMemory(e)}if((u||p)&&m){if(!p&&(u||n===`natural-log`||n===`square-root`))throw new b(`${this.adapterName}:not-supported`,`Layer does not support standardized SQL expression for queries`);return this._histogramForExpr(e)}if(l&&m)throw new b(`${this.adapterName}:not-supported`,`Normalization and date field are not allowed when layer does not support standardized SQL expression for queries`);return n||!m?Nt(e,this).then(i=>{if(!_)return Y(this,i,t,v,a,o,s);if(h>i.max||g<i.min)throw new b(`${this.adapterName}:insufficient-data`,`Range defined by 'minValue' and 'maxValue' does not intersect available data range of the field`);if(m)return Y(this,{min:h,max:g,sqlExpr:i.sqlExpr,excludeZerosExpr:i.excludeZerosExpr},t,v,a,o,s);{let c={field:t,normalizationType:n,normalizationField:r,normalizationTotal:i.normTotal,layer:this},l=U(c),u=j(l,h,g);return Nt(e,this,u).then(e=>Y(this,e,t,v,a,o,s))}}):this._histogramForField(e)}async classBreaks(e){let t=!1!==e.analyzeData,n=this._hasLocalSource||e.features||e.useFeaturesInView||e.valueExpression||e.filter;return t&&n?this._classBreaksFromMemory(e):(t?this._classBreaksFromGenRend(e):this._classBreaksFromInterpolation(e)).catch(()=>(S(e.signal),this._classBreaksFromMemory(e)))}async queryFeatureCount(e){if(this._hasLocalSource)throw new b(`${this.adapterName}:not-supported`,`Layer does not support count query`);let t=this.layer,n=t.createQuery();return n.where=M(n.where,e.whereClause),J(n,e.filter),t.queryFeatureCount(n,{signal:e.signal})}async generateRenderer(e,t){let n=this.layer;if(this._hasLocalSource||n.version<10.1)throw new b(`${this.adapterName}:not-supported`,`Layer does not support generateRenderer operation (requires ArcGIS Server version 10.1+)`);let r=n.createQuery();return e.where=M(e.where,r.where),Ze(n.parsedUrl?.path??``,{source:n.dynamicDataSource??void 0,gdbVersion:n.gdbVersion??void 0},e,{signal:t})}async predominantCategories(e){if(!this._hasLocalSource&&!this.supportsSQLExpression)throw new b(`${this.adapterName}:not-supported`,`Layer does not support advanced SQL expressions and standardized queries`);let{fields:t,view:n,signal:r,filter:i}=e,a=at(t),o=tt(t),s=n&&this._hasLocalSource?await this._uvFromMemory({valueExpression:a,view:n,signal:r,filter:i}):await this._uvFromServiceQuery({sqlExpression:o.expression,valueExpression:a,signal:r,filter:i});return yt(s.uniqueValueInfos,t)}async getSampleFeatures(t,n){let{view:r,requiredFields:i,returnGeometry:a,filter:s,signal:c}=t,l=t.sampleSize;if(l==null||l===0)return[];let u=this.layer.createQuery(),d=n===`json`;u.outSpatialReference=r?.spatialReference,u.returnGeometry=!!a,u.outFields=i,J(u,s);let p=[],m=!1;if(r)try{let a=await r.whenLayerView(this.layer);if(m=!V(this,i,a).length,m){if(l>=1&&!t.filter&&`getSampleFeatures`in a){await this._waitForLayerViewUpdate(a);let e=await a.getSampleFeatures({minFeatureCount:l,sampleSize:l});if(e!=null)return d?e:e.map(e=>f.fromJSON(e))}if(p=await this._fetchFeaturesFromMemory(a,u,c,n),p.length>=l&&l>0)return e(p,l,1)}}catch{S(c)}try{if(this._hasLocalSource)return m?p:d?await this._fetchFeaturesJSONFromService(u,c):await this._fetchFeaturesFromService(u,c);let n=await this.queryFeatureCount({view:r,filter:s,signal:c}),i=this.layer.capabilities.query.maxRecordCount,a=l===-1?n:l;if(a=i&&a>i?i:a,n<=p.length||p.length>=i)return p;if(u.maxAllowableOffset=t.resolution||(r?r.extent.width/r.width/r.scale:o(this.layer.spatialReference))*Ut,n<=a)return d?await this._fetchFeaturesJSONFromService(u,c):await this._fetchFeaturesFromService(u,c);if(n<=Ht){let t=this.layer.createQuery();J(t,s);let n=await this.layer.queryObjectIds();return u.objectIds=e(n,a,1),d?await this._fetchFeaturesJSONFromService(u,c):await this._fetchFeaturesFromService(u,c)}return this.layer.capabilities?.query?.supportsPagination&&(u.num=Math.min(a,Ht)),d?await this._fetchFeaturesJSONFromService(u,c):await this._fetchFeaturesFromService(u,c)}catch{return S(c),p}}load(e){let t=this.layer.load(e).then(async t=>{this.geometryType=t.geometryType,this.objectIdField=t.objectIdField,this.supportsSQLExpression=t.capabilities?.query?.supportsSqlExpression,this._hasLocalSource=t.type===`parquet`||!t.url&&!!t.source,this.hasQueryEngine=this._hasLocalSource,this.minScale=t.minScale,this.maxScale=t.maxScale,this.fullExtent=t.fullExtent,this.workerClient=I.getInstance(),await this.workerClient.open(e.signal)});return this.addResolvingPromise(t),Promise.resolve(this)}};function Wt(e,t,n){let r=[],i=t.length;return t.forEach((t,a)=>{let[o,s]=t,c=null;c=a!==0||n?a!==i-1||n?M(`${e} >= ${o}`,`${e} ${a===i-1?` <= `:` < `} ${s}`):`${e} >= ${o}`:`${e} < ${s}`,r.push(`WHEN (`+c+`) THEN `+(a+1))}),[`CASE`,r.join(` `),`ELSE 0`,`END`].join(` `)}n([p({readOnly:!0})],Q.prototype,`adapterName`,void 0),n([p({constructOnly:!0})],Q.prototype,`layer`,void 0),Q=n([C(`esri.smartMapping.support.adapters.FeatureLayerAdapter`)],Q);var Gt=class extends Q{constructor(){super(...arguments),this.adapterName=`csv-layer-adapter`}async _createGenerateRendererResult(e,t,n,r,i){let a=e?.features;if(!a?.length)throw new b(`csv-layer-adapter:insufficient-data`,`No features are available to calculate statistics`);let o=B(a),s=null;if(r===`percent-of-total`&&(s=(await this.workerClient.summaryStatistics({field:t},o)).sum,s==null))throw new b(`csv-layer-adapter:invalid`,`invalid normalizationTotal`);if(i?.type===`class-breaks-definition`){let e=(await Me({field:t,normalizationType:r,normalizationField:n,normalizationTotal:s},o)).filter(e=>Number.isFinite(e));return ve({definition:i,values:e,normalizationTotal:s})}let c=(await Me({field:t},o)).filter(e=>e!=null&&typeof e==`string`&&e.trim()!==``);return _e(c)}generateRenderer(e,t){let n=e.classificationDefinition,r=null,i=null,a=null;n?.type===`class-breaks-definition`?(r=n.classificationField,i=n.normalizationField,a=n.normalizationType):r=n?.attributeField;let o=this.layer;return k({field:r,normalizationField:i}).then(s=>{let c=o.createQuery();return c.returnGeometry=!1,c.outFields=s,c.where=M(c.where,e.where),o.queryFeatures(c,{signal:t}).then(e=>this._createGenerateRendererResult(e,r,i,a,n))})}load(e){let t=this.layer.load(e).then(async t=>{this.geometryType=t.geometryType,this.objectIdField=t.objectIdField,this.supportsSQLExpression=!0,this._hasLocalSource=!1,this.hasQueryEngine=!0,this.workerClient=I.getInstance(),await this.workerClient.open(e.signal)});return this.addResolvingPromise(t),Promise.resolve(this)}};n([p({readOnly:!0})],Gt.prototype,`adapterName`,void 0),Gt=n([C(`esri.smartMapping.support.adapters.CSVLayerAdapter`)],Gt);var Kt=class extends Q{constructor(){super(...arguments),this.adapterName=`feature-layer-binning-adapter`}async _getNormalizationTotalFromMemory(e,t,n){let{featuresJSON:r,graphics:i,layerView:a,query:o}=t,s={include:[`sum`]},c=(!r&&!i&&a&&`queryAggregateSummaryStatistics`in a?await a.queryAggregateSummaryStatistics(o,{field:e,outStatisticTypes:s},{signal:n}):r?await this.workerClient.summaryStatistics({field:e},r):await F({attribute:{field:e,outStatisticTypes:s},features:i})).sum;if(c==null)throw new b(`${this.adapterName}:invalid`,`invalid normalizationTotal`);return c}async _processStatsFromMemoryParams(e){let{features:t,filter:n}=e;if(t?.length)return this._getFilteredFeatures(t,n);let{view:r,field:i,field2:a,field3:o,normalizationField:s,valueExpression:c,returnGeometry:l,layerViewFunc:u,signal:d}=e,f=null,p=null,m=null,h=null,g=null;if(r)try{if(f=await r.whenLayerView(this.layer),fe(f),p=u!=null&&u in f&&typeof f[u]==`function`,p){await this._waitForLayerViewUpdate(f);let e=await k({field:i,field2:a,field3:o,normalizationField:s,valueExpression:c});lt(this,e).length?p=!1:(m=`createAggregateQuery`in f?f.createAggregateQuery():null,m?(m.outFields=e,m.returnGeometry=!1,J(m,n)):p=!1),f.suspended&&(p=!1)}}catch{p=!1}if(!p&&(g=bt(this.layer).map(e=>e.toJSON()),h=await this._fetchFeaturesForStats({field:i,field2:a,field3:o,valueExpression:c,normalizationField:s,returnGeometry:l,filter:n,view:r,signal:d},`json`),!h?.length))throw new b(`${this.adapterName}:insufficient-data`,`No features are available to calculate statistics`);return{layerView:f,query:m,featuresJSON:h,fieldInfos:g}}async _summaryStatsFromMemory(e,t){let{view:n,field:r,valueExpression:i,normalizationType:a,signal:o}=e,s={field:r,valueExpression:i,normalizationType:a,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,outStatisticTypes:e.outStatisticTypes},{featuresJSON:c,graphics:l,layerView:u,query:d,fieldInfos:f}=await this._processStatsFromMemoryParams({...e,layerViewFunc:`queryAggregateSummaryStatistics`});return i&&n&&(c||l)&&(s.fieldType=t?.type?ae.toJSON(t.type):null,s.viewInfoParams=K(n),s.timeZone=n.timeZone,s.fieldInfos=f),a===`percent-of-total`&&e.normalizationTotal==null&&(s.normalizationTotal=await this._getNormalizationTotalFromMemory(r,{featuresJSON:c,graphics:l,layerView:u,query:d},o)),!c&&!l&&u&&`queryAggregateSummaryStatistics`in u?u.queryAggregateSummaryStatistics(d,s,{signal:o}):c?this.workerClient.summaryStatistics(s,c):F({attribute:s,features:l})}async _uvFromMemory(e,t){let{view:n,field:r,valueExpression:i,returnAllCodedValues:a,signal:o}=e,{featuresJSON:s,graphics:c,layerView:l,query:u,fieldInfos:d}=await this._processStatsFromMemoryParams({...e,layerViewFunc:`queryAggregateUniqueValues`}),f={field:r,field2:e.field2,field3:e.field3,fieldDelimiter:`,`,valueExpression:i,domains:t,returnAllCodedValues:a};return i&&n&&(s||c)&&(f.viewInfoParams=K(n),f.timeZone=n.timeZone,f.fieldInfos=d),!s&&!c&&l&&`queryAggregateUniqueValues`in l?l.queryAggregateUniqueValues(u,f,{signal:o}):s?this.workerClient.uniqueValues(f,s):He({attribute:f,features:c})}async _histogramFromMemory(e){let{view:t,field:n,valueExpression:r,signal:i}=e,{featuresJSON:a,graphics:o,layerView:s,query:c,fieldInfos:l}=await this._processStatsFromMemoryParams({...e,layerViewFunc:`queryAggregateHistogram`}),u={field:n,valueExpression:r,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,standardDeviationInterval:e.standardDeviationInterval,classificationMethod:e.classificationMethod,numBins:e.numBins};return r&&t&&(a||o)&&(u.viewInfoParams=K(t),u.timeZone=t.timeZone,u.fieldInfos=l),e.normalizationType===`percent-of-total`&&e.normalizationTotal==null&&(u.normalizationTotal=await this._getNormalizationTotalFromMemory(n,{featuresJSON:a,graphics:o,layerView:s,query:c},i)),!a&&!o&&s&&`queryAggregateHistogram`in s?s.queryAggregateHistogram(c,u,{signal:i}):a?this.workerClient.histogram(u,a):P({attribute:u,features:o})}async _classBreaksFromMemory(e){let{view:t,field:n,valueExpression:r,signal:i}=e,{featuresJSON:a,graphics:o,layerView:s,query:c,fieldInfos:l}=await this._processStatsFromMemoryParams({...e,layerViewFunc:`queryAggregateClassBreaks`}),u={field:n,valueExpression:r,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,standardDeviationInterval:e.standardDeviationInterval,classificationMethod:e.classificationMethod,numClasses:e.numClasses};return r&&t&&(a||o)&&(u.viewInfoParams=K(t),u.timeZone=t.timeZone,u.fieldInfos=l),e.normalizationType===`percent-of-total`&&e.normalizationTotal==null&&(u.normalizationTotal=await this._getNormalizationTotalFromMemory(n,{featuresJSON:a,graphics:o,layerView:s,query:c},i)),!a&&!o&&s&&`queryAggregateClassBreaks`in s?s.queryAggregateClassBreaks(c,u,{signal:i}):a?this.workerClient.classBreaks(u,a):Ue({attribute:u,features:o})}getField(e=``){return bt(this.layer)?.find(t=>t.name.toLowerCase()===e?.toLowerCase())}getFieldUsageInfo(e){return this.getField(e)?{supportsLabelingInfo:!0,supportsRenderer:!0,supportsPopupTemplate:!0,supportsLayerQuery:!1,supportsStatistics:!0}:null}getFieldDomain(e,t){return null}async summaryStatistics(e){let{field:t}=e,n=t?this.getField(t):null,r=O(n)||w(n),i=e.sqlExpression&&!e.valueExpression&&!t;if(r||i)throw new b(`${this.adapterName}:not-supported`,`Date field and sqlExpression are not supported`);return this._summaryStatsFromMemory(e,n)}async uniqueValues(e){let t=await G(e,this);return this._uvFromMemory(e,t)}async histogram(e){let{field:t}=e,n=t?this.getField(t):null,r=O(n)||w(n),i=e.sqlExpression&&!e.valueExpression&&!t;if(r||i)throw new b(`${this.adapterName}:not-supported`,`Date field and sqlExpression are not supported`);return this._histogramFromMemory(e)}async classBreaks(e){return(!1===e.analyzeData?this._classBreaksFromInterpolation(e):this._classBreaksFromMemory(e)).catch(()=>(S(e.signal),this._classBreaksFromMemory(e)))}async queryFeatureCount(e){let t=await e.view?.whenLayerView(this.layer);if(!t||!(`queryAggregateCount`in t)||!t.queryAggregateCount)throw new b(`${this.adapterName}:not-supported`,`LayerView is not supported.`);await this._waitForLayerViewUpdate(t);let n=t.createAggregateQuery();return n.where=M(n.where,e.whereClause),J(n,e.filter),t.queryAggregateCount(n,{signal:e.signal})}generateRenderer(e,t){throw new b(`${this.adapterName}:not-supported`,`'generateRenderer' is not supported.`)}heatmapStatistics(e){throw new b(`${this.adapterName}:not-supported`,`'heatmapStatistics' is not supported.`)}async predominantCategories(e){let{fields:t,view:n,signal:r}=e,i=at(t),a=await this._uvFromMemory({valueExpression:i,view:n,signal:r});return yt(a.uniqueValueInfos,t)}async getSampleFeatures(t,n){let{view:r,sampleSize:i,requiredFields:a,returnGeometry:o,filter:s,signal:c}=t;if(!r)throw new b(`${this.adapterName}:not-supported`,`'view' is required to get sample features for binning.`);if(r.type===`3d`)throw new b(`${this.adapterName}:not-supported`,`3d 'view' is not supported to get sample features for binning.`);let l=await r.whenLayerView(this.layer);if(!(`queryAggregateJSON`in l&&l.queryAggregateJSON&&`queryAggregates`in l&&l.queryAggregates))throw new b(`${this.adapterName}:not-supported`,`LayerView is not supported.`);if(await this._waitForLayerViewUpdate(l),lt(this,a).length)throw new b(`${this.adapterName}:insufficient-data`,`Layer does not have required fields`);let u=n===`json`,d=l.createAggregateQuery();d.outSpatialReference=r?.spatialReference,d.returnGeometry=!!o,d.outFields=a,J(d,s);let{features:f}=u?await l.queryAggregateJSON(d,{signal:c}):await l.queryAggregates(d,{signal:c});return f.length&&i!=null&&i>0&&i<=f.length?e(f,i,1):f}load(e){let t=this.layer.load(e).then(async t=>{let n=`featureReduction`in t?t.featureReduction:null;if(n?.type!==`binning`&&n?.type!==`cluster`)throw new b(`${this.adapterName}:invalid-parameters`,`Feature reduction type ${n?.type} is not supported`);this.geometryType=n?.type===`cluster`?`point`:`polygon`,this.objectIdField=null,this.supportsSQLExpression=!1,this._hasLocalSource=!1,this.hasQueryEngine=!0,this.minScale=t.minScale,this.maxScale=t.maxScale,this.fullExtent=t.fullExtent,this.workerClient=I.getInstance(),await this.workerClient.open(e.signal)});return this.addResolvingPromise(t),Promise.resolve(this)}};n([p({readOnly:!0})],Kt.prototype,`adapterName`,void 0),Kt=n([C(`esri.smartMapping.support.adapters.FeatureLayerBinningAdapter`)],Kt);var qt=Kt,$=class extends z{constructor(e){super(e),this._featureLayerAdapter=null,this.workerClient=null,this.adapterName=`scene-layer-adapter`}destroy(){this.workerClient?.destroy()}_hasCachedStatistics(e){return this.layer.hasCachedStatistics(e)}_updateQuery(e,t=[],n=[]){if(!e||!n.length)return e;let r=this.layer.objectIdField,i=e.clone(),a=t.filter(e=>{let t=this.layer.getField(e);return!n.includes(t.name)});return i.outFields=a.some(e=>this.layer.getField(e).name===r)?a:[...a,r],i}async _fetchFeaturesFromMemory(e,t,n){if(!e)throw new b(`scene-layer-adapter:insufficient-data`,`view is required to fetch the features from layerView`);let r=await e.whenLayerView(this.layer),i=new AbortController,a=i.signal,o=l(()=>!r.updating,a);await u(o,5e3,i);let s=V(this,n,r);S(a);let c=this._updateQuery(t,n??[],s),d=await r.queryFeatures(c,{signal:a});S(a);let f=d.features;return s.length?r.whenGraphicAttributes(f,s):f}async _fetchFeaturesJSONFromMemory(e,t,n){return this._fetchFeaturesFromMemory(e,t,n).then(B)}_fetchFeaturesForStats(e,t){return k({field:e.field,normalizationField:e.normalizationField,valueExpression:e.valueExpression}).then(n=>this.getSampleFeatures({sampleSize:-1,view:e.view,returnGeometry:e.returnGeometry,requiredFields:n,signal:e.signal},t))}async _processStatsFromMemoryParams(e){let t=e.features;if(t?.length)return t.length&&`declaredClass`in t[0]&&t[0].declaredClass===`esri.Graphic`?{graphics:t}:{featuresJSON:t};let{view:n,field:r,normalizationField:i,valueExpression:a,signal:o}=e,s=await this._fetchFeaturesForStats({field:r,valueExpression:a,normalizationField:i,view:n,signal:o},null);if(!s?.length)throw new b(`scene-layer-adapter:insufficient-data`,`No features are available to calculate statistics`);return{graphics:s}}_getCachedStatistics(e,t){let n=this.layer;return e.valueExpression||e.sqlExpression||e.sqlWhere||e.minValue||e.maxValue?Promise.reject(new b(`scene-layer-adapter:not-supported`,`This Layer does not support calculating statistics when 'valueExpression', 'sqlExpression', 'sqlWhere', 'minValue' or 'maxValue' is specified`)):n.queryCachedStatistics(t?.name,{signal:e.signal}).then(e=>{let t=e.stats,{min:n,max:r,totalValuesCount:i}=t,{avg:a,stddev:o,sum:s,variance:c,count:l}=t;return n===0&&r===0||(a=a===0?null:a,s=s===0?null:s,o=o===0?null:o,c=c===0?null:c,l=l===0?null:l),l??(s!=null&&a!=null?l=Math.round(s/a):i!=null&&(l=i)),{avg:a,count:l,max:r,min:n,stddev:o,sum:s,variance:c}})}async _getNormalizationTotal(e,t,n){let r={include:[`sum`]},i=(t?await this.workerClient.summaryStatistics({field:e,outStatisticTypes:r},t):await F({attribute:{field:e,outStatisticTypes:r},features:n})).sum;if(i==null)throw new b(`scene-layer-adapter:invalid`,`invalid normalizationTotal`);return i}async _getSummaryStatisticsFromMemory(e,t){let{view:n,field:r,normalizationField:i,valueExpression:a}=e,{featuresJSON:o,graphics:s}=await this._processStatsFromMemoryParams(e),c={field:r,valueExpression:a,normalizationType:e.normalizationType,normalizationField:i,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,outStatisticTypes:e.outStatisticTypes};return e.valueExpression&&n&&o&&(c.fieldType=t?.type?ae.toJSON(t.type):null,c.viewInfoParams=K(n),c.timeZone=n.timeZone),e.normalizationType===`percent-of-total`&&e.normalizationTotal==null&&(c.normalizationTotal=await this._getNormalizationTotal(r,o,s)),o?this.workerClient.summaryStatistics(c,o):F({attribute:c,features:s})}_getCachedStatisticsForUniqueValues(e,t){let n=this.layer,r=t?.name,i=t&&e.field?this.getFieldDomain(e.field):null;return e.valueExpression||e.sqlExpression||e.sqlWhere?Promise.reject(new b(`scene-layer-adapter:not-supported`,`This Layer does not support calculating statistics when 'valueExpression', 'sqlExpression' or 'sqlWhere' is specified`)):n.queryCachedStatistics(r,{signal:e.signal}).then(i=>{let a=i.stats;if(!a.mostFrequentValues)throw Error();let o=i.labels?.labels,s={},c=[],l=`countOF`+r;a.mostFrequentValues.forEach(e=>{let i=new f({attributes:{}});i.attributes[r]=t&&t.name!==n.objectIdField&&(ee(t)||O(t))?Number(e.value):e.value,i.attributes[l]=e.count,c.push(i)}),o&&o.forEach(e=>{s[e.value]=e.label});let u=new _({features:c});return pt(u,{layer:this,field:e.field,labels:s,view:e.view,signal:e.signal})}).then(t=>D(t,[i],e.returnAllCodedValues))}async _getUniqueValuesFromMemory(e,t){let{view:n,field:r,field2:i,field3:a,valueExpression:o,returnAllCodedValues:s}=e,c={field:r,field2:i,field3:a,fieldDelimiter:`,`,valueExpression:o,domains:t,returnAllCodedValues:s},{featuresJSON:l,graphics:u}=await this._processStatsFromMemoryParams(e);return e.valueExpression&&n&&l&&(c.viewInfoParams=K(n),c.timeZone=n.timeZone),l?this.workerClient.uniqueValues(c,l):He({attribute:c,features:u})}_getCachedStatisticsForHistogram(e,t){let n=this.layer;return e.valueExpression||e.sqlExpression||e.sqlWhere||e.normalizationType?Promise.reject(new b(`scene-layer-adapter:not-supported`,`This Layer does not support calculating statistics when 'valueExpression' or 'sqlExpression' or 'sqlWhere' or 'normalizationType' is specified`)):n.queryCachedStatistics(t&&t.name,{signal:e.signal}).then(t=>{let n=t.stats,{minValue:r,maxValue:i}=e,a=r??n.min,o=i??n.max,s=e.numBins||10,c=Jt(n.histogram,a,o,s);return ft(c,a,o,s)})}async _getClassBreaksFromMemory(e){let{view:t,field:n,normalizationField:r,valueExpression:i}=e,{featuresJSON:a,graphics:o}=await this._processStatsFromMemoryParams(e),s={field:n,valueExpression:i,normalizationType:e.normalizationType,normalizationField:r,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,standardDeviationInterval:e.standardDeviationInterval,classificationMethod:e.classificationMethod,numClasses:e.numClasses};return e.valueExpression&&t&&a&&(s.viewInfoParams=K(t),s.timeZone=t.timeZone),e.normalizationType===`percent-of-total`&&e.normalizationTotal==null&&(s.normalizationTotal=await this._getNormalizationTotal(n,a,o)),a?this.workerClient.classBreaks(s,a):Ue({attribute:s,features:o})}async _getHistogramFromMemory(e){let{view:t,field:n}=e,{featuresJSON:r,graphics:i}=await this._processStatsFromMemoryParams(e),a={field:n,valueExpression:e.valueExpression,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,standardDeviationInterval:e.standardDeviationInterval,classificationMethod:e.classificationMethod,numBins:e.numBins};return e.valueExpression&&t&&r&&(a.viewInfoParams=K(t),a.timeZone=t.timeZone),e.normalizationType===`percent-of-total`&&e.normalizationTotal==null&&(a.normalizationTotal=await this._getNormalizationTotal(n,r,i)),r?this.workerClient.histogram(a,r):P({attribute:a,features:i})}getField(e){return this.layer.getField(e??``)}getFieldUsageInfo(e){let t=this.getField(e);if(!t)return null;let n=this.layer.getFieldUsageInfo(t.name);return{supportsLabelingInfo:n.supportsLabelingInfo,supportsPopupTemplate:n.supportsPopupTemplate,supportsRenderer:n.supportsRenderer,supportsLayerQuery:n.supportsLayerQuery,supportsStatistics:!0}}getFieldDomain(e,t){return this._featureLayerAdapter?this._featureLayerAdapter.getFieldDomain(e,t):null}createQuery(){return this.layer.createQuery()}summaryStatistics(e){let t=this.getField(e.field);if(this._featureLayerAdapter)return this._featureLayerAdapter.summaryStatistics(e);if(e.filter)throw new b(`scene-layer-adapter:not-supported`,`filter is not supported`);return this._hasCachedStatistics(t?.name)?this._getCachedStatistics(e,t).catch(()=>(S(e.signal),this._getSummaryStatisticsFromMemory(e,t))):this._getSummaryStatisticsFromMemory(e,t)}async uniqueValues(e){if(this._featureLayerAdapter)return this._featureLayerAdapter.uniqueValues(e);if(e.filter)throw new b(`scene-layer-adapter:not-supported`,`filter is not supported`);let t=await G(e,this),{field:n,field2:r}=e,i=n&&r,a=this.getField(n);return!i&&a&&this._hasCachedStatistics(a.name)?this._getCachedStatisticsForUniqueValues(e,a).catch(()=>(S(e.signal),this._getUniqueValuesFromMemory(e,t))):this._getUniqueValuesFromMemory(e,t)}histogram(e){let t=this.getField(e.field);if(this._featureLayerAdapter)return this._featureLayerAdapter.histogram(e);if(e.filter)throw new b(`scene-layer-adapter:not-supported`,`filter is not supported`);return t&&this._hasCachedStatistics(t.name)?this._getCachedStatisticsForHistogram(e,t).catch(()=>(S(e.signal),this._getHistogramFromMemory(e))):this._getHistogramFromMemory(e)}classBreaks(e){let t=this.getField(e.field);if(this._featureLayerAdapter)return this._featureLayerAdapter.classBreaks(e);if(e.filter)throw new b(`scene-layer-adapter:not-supported`,`filter is not supported`);return this._hasCachedStatistics(t?.name)?Promise.reject(new b(`scene-layer-adapter:not-supported`,`Cached stats not supported`)):this._getClassBreaksFromMemory(e)}queryFeatureCount(e){return this._featureLayerAdapter?this._featureLayerAdapter.queryFeatureCount(e):Promise.reject(new b(`scene-layer-adapter:not-supported`,`SceneLayer without associated FeatureLayer does not support count query`))}generateRenderer(e,t){return this._featureLayerAdapter?this._featureLayerAdapter.generateRenderer(e,t):Promise.reject(new b(`scene-layer-adapter:not-supported`,`SceneLayer without associated FeatureLayer does not support generateRenderer operation`))}heatmapStatistics(e){return this._featureLayerAdapter?this._featureLayerAdapter.heatmapStatistics(e):Promise.reject(new b(`scene-layer-adapter:not-supported`,`SceneLayer without associated FeatureLayer does not support heatmapStatistics operation`))}async predominantCategories(e){if(this._featureLayerAdapter)return this._featureLayerAdapter.predominantCategories(e);throw new b(`scene-layer-adapter:not-supported`,`SceneLayer without associated FeatureLayer does not support predominantCategories`)}async getSampleFeatures(t,n){if(t.filter)throw new b(`scene-layer-adapter:not-supported`,`filter is not supported`);let{view:r,sampleSize:i,requiredFields:a,returnGeometry:o,signal:s}=t,c=n===`json`,l=this.createQuery();l.outFields=a,l.returnGeometry=!!o,l.where=null,l.num=i;let u=[];try{if(u=c?await this._fetchFeaturesJSONFromMemory(r,l,a):await this._fetchFeaturesFromMemory(r,l,a),u.length&&i!=null&&i>0&&i<=u.length)return e(u,i,1)}catch{S(s)}let d=null;if(this._featureLayerAdapter){let e={...t};delete e.view,d=await this._featureLayerAdapter.getSampleFeatures(e,n)}return d?.length?d:e(u,u.length,1)}load(e){let t=this.layer.load(e).then(async t=>{this.workerClient=I.getInstance(),await this.workerClient.open(e.signal);let n=t.associatedLayer;if(this.geometryType=t.geometryType,n!=null)return this._featureLayerAdapter=new Q({layer:n}),this._featureLayerAdapter.load(e).then(()=>{this.objectIdField=this._featureLayerAdapter.objectIdField,this.supportsSQLExpression=this._featureLayerAdapter.supportsSQLExpression,this.minScale=this._featureLayerAdapter.minScale,this.maxScale=this._featureLayerAdapter.maxScale,this.fullExtent=this._featureLayerAdapter.fullExtent});this.objectIdField=t.objectIdField,this.supportsSQLExpression=!1,this.hasQueryEngine=!1,this.fullExtent=t.fullExtent});return this.addResolvingPromise(t),Promise.resolve(this)}};function Jt(e,t=e.minimum,n=e.maximum,r){let i=[];for(let e=0;e<r;e++)i[e]=0;let a=e.counts.length,o=e.minimum,s=e.maximum;for(let c=0;c<a;c++){let l=(c+.5)/a,u=((1-l)*o+l*s-t)/(n-t)*r;u>=0&&u<=r&&(i[u===r?r-1:Math.floor(u)]+=e.counts[c])}let c=[];return i.forEach((e,t)=>{let n=new f({attributes:{}});n.attributes.EXPR_1=t+1,n.attributes.countOFExpr=e,c.push(n)}),new _({features:c})}n([p({readOnly:!0})],$.prototype,`adapterName`,void 0),n([p({constructOnly:!0})],$.prototype,`layer`,void 0),$=n([C(`esri.smartMapping.support.adapters.SceneLayerAdapter`)],$);var Yt=class extends ${constructor(e){super(e),this.adapterName=`point-cloud-layer-adapter`}getField(e){return this.layer.fieldsIndex.get(e??``)}getFieldUsageInfo(e){let t=this.getField(e);if(!t)return null;let n=this._hasCachedStatistics(t.name);return{supportsLabelingInfo:n,supportsPopupTemplate:n,supportsRenderer:n,supportsLayerQuery:!1,supportsStatistics:n}}getFieldDomain(){return null}load(e){let t=this.layer.load(e).then(()=>{this.geometryType=`point`,this.objectIdField=null,this.supportsSQLExpression=!1,this.hasQueryEngine=!1});return this.addResolvingPromise(t),Promise.resolve(this)}};n([p({readOnly:!0})],Yt.prototype,`adapterName`,void 0),Yt=n([C(`esri.smartMapping.support.adapters.PointCloudLayerAdapter`)],Yt);var Xt=class extends Z{constructor(){super(...arguments),this.adapterName=`stream-layer-adapter`}async _summaryStatsFromClientQuery(e,t){let{signal:n,view:r}=e,i=q(this,e,t);i.outStatistics=i.outStatistics?.filter(e=>e.outStatisticFieldName!==`totalcount_value`);let a=await this._fetchFeatureSetFromMemory(i,r,n),o=H(a,O(t)||w(t));return E(o,e.outStatisticTypes)}};n([p({readOnly:!0})],Xt.prototype,`adapterName`,void 0),Xt=n([C(`esri.smartMapping.support.adapters.StreamLayerAdapter`)],Xt);var Zt={0:{adapter:Q,type:`catalog`,label:`CatalogLayer`},1:{adapter:Q,type:`catalog-footprint`,label:`CatalogFootprintLayer`},2:{adapter:Gt,type:`csv`,label:`CSVLayer`},3:{adapter:Q,type:`feature`,label:`FeatureLayer`},5:{adapter:Q,type:`imagery`,label:`ImageryLayer`},4:{adapter:Q,type:`geojson`,label:`GeoJSONLayer`},6:{adapter:Q,type:`knowledge-graph-sublayer`,label:`KnowledgeGraphSublayer`},7:{adapter:Z,type:`ogc-feature`,label:`OGCFeatureLayer`},8:{adapter:Q,type:`oriented-imagery`,label:`OrientedImageryLayer`},9:{adapter:Q,type:`parquet`,label:`ParquetLayer`},10:{adapter:Yt,type:`point-cloud`,label:`PointCloudLayer`},11:{adapter:$,type:`scene`,label:`SceneLayer`},12:{adapter:Xt,type:`stream`,label:`StreamLayer`},13:{adapter:Q,type:`subtype-group`,label:`SubtypeGroupLayer`},14:{adapter:Q,type:`subtype-sublayer`,label:`SubtypeSublayer`},15:{adapter:Q,type:`wfs`,label:`WFSLayer`}},Qt=[0,1,2,3,4,6,7,8,9,10,11,12,13,14,15],$t=[2,3,4,7,6,8,9,12,15];function en(e){return e.map(e=>Zt[e].label)}function tn(e,t=Qt,n){if(e instanceof z)return e;let r=nn(e,t);return r?n?new qt({layer:e}):new r({layer:e}):null}function nn(e,t=Qt){let n=null;return t.some(t=>{let r=e.type===Zt[t].type;return r&&(n=Zt[t].adapter),r}),n}async function rn(e){if(!e?.layer||!e.field&&!e.valueExpression)throw new b(`unique-values:missing-parameters`,`'layer' and 'field' or 'valueExpression' parameters are required`);let t=e.valueExpression||e.sqlExpression,n=t&&!e.sqlExpression;if(t){if(n){if(!e.view)throw new b(`unique-values:missing-parameters`,`View is required when 'valueExpression' is specified`)}else if(!e.valueExpression)throw new b(`unique-values:missing-parameters`,`'valueExpression' parameters are required`)}e.forBinning&&We(e,`unique-values`);let{layer:r,...i}=e,a=[...Qt,5],o=e.forBinning?$t:a,s=tn(r,o,e.forBinning);if(!s)throw new b(`unique-values:invalid-parameters`,`'layer' must be one of these types: `+en(o).join(`, `));let c={layerAdapter:s,...i},l=c.signal==null?null:{signal:c.signal};await s.load(l);let u=await k({field:c.field,field2:c.field2,field3:c.field3,valueExpression:c.valueExpression}),d=je(s,u,`unique-values:invalid-parameters`);if(d)throw d;c.filter&&!c.filter.spatialRelationship&&(c.filter.spatialRelationship=`intersects`);let f=Ne(c.filter,`summary-statistics:invalid-parameters`);if(f)throw f;return c}async function an(e){let{layerAdapter:t,...n}=await rn(e);return t.uniqueValues(n)}export{an as default};
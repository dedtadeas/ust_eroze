import{ET as e,Vw as t,Ww as n,aT as r}from"./index-BqmCqmfp.js";import{t as i}from"./QueueProcessor-C8_CgXms.js";function a(e,t,n,r){return new s(e,t,n,r)}var o=class{constructor(e,n,r){this._executor=e,this._data=n,this._impl=r,this._closed=!1,this._resolver=t(),this._impl.open(this)}assertOpen(){if(this._closed)throw Error(`Batch closed.`)}get data(){return this.assertOpen(),this._data}get results(){return this._resolver.promise}send(){try{this.assertOpen(),this._closed=!0,this._executor.resume(this),this._impl.close(this),n(this._resolver,this._impl.execute(this._data))}catch(e){this._resolver.reject(e)}}},s=class{constructor(e,r,a,o){if(this._runJob=r,this._maxRunning=a,this._abortSignal=o,this._jobIdSeq=0,this._running=new Set,this._blocked=new Set,this._openBatches=new Map,this._state=`ready`,this._runResolver=null,a<1)throw Error(`_maxRunning=${a} but cannot be < 1`);this._todo=e[Symbol.iterator](),this._queue=new i({concurrency:1,process:async e=>{if(e.type===`start`){let{id:r,args:i}=e,a=t(),o=t(),s={id:r,interrupt:a,finished:o.promise};n(o,this._runJob(i,{id:r,yieldFor:e=>this.yieldFor(s,e)}).then(()=>{this._blocked.has(r)&&this._fail(Error(`job ${r} completed before resuming`)),this._running.delete(r)||this._fail(Error(`job ${r} not running?`))})),await Promise.race([a.promise,s.finished]),this._tryQueue();return}if(e.type===`continue`)return e.job.interrupt=t(),e.data.status===`fulfilled`?e.continuation.resolve(e.data.value):e.continuation.reject(e.data.reason),await Promise.race([e.job.interrupt.promise,e.job.finished]),void this._tryQueue()}})}openBatch(e,t){return new o(this,e,t)}_fail(e,t=!1){if(this._runResolver?.reject(e),this._state=`stopped`,!t)throw e}_schedule(e){this._queue.push(e).catch(e=>this._fail(e,!0))}_tryQueue(){if(this._state===`running`)if(this._abortSignal?.aborted)this._fail(r(),!0);else{if(this._running.size<this._maxRunning){let e=this._todo.next();if(!e.done){let t=this._jobIdSeq++;this._running.add(t),this._schedule({type:`start`,id:t,args:e.value});return}}if(this._running.size===0)return this._runResolver?.resolve(),this._runResolver=null,void(this._state=`stopped`);if(this._blocked.size===this._running.size){let e=null,t=-1/0;for(let[n,r]of this._openBatches)r.size>t&&(e=n,t=r.size);e??this._fail(Error(`deadlock`)),e.send();return}}}resume(e){let t=this._openBatches.get(e);if(this._openBatches.delete(e),t!=null)for(let e of t)this._blocked.delete(e)||this._fail(Error(`job ${e} not suspended`))}async yieldFor(n,r){r.assertOpen(),this._running.has(n.id)||this._fail(Error(`job ${n.id} not running`)),this._blocked.has(n.id)&&this._fail(Error(`job ${n.id} already suspended`)),this._blocked.add(n.id),e(this._openBatches,r,()=>new Set).add(n.id),n.interrupt??this._fail(Error(`job ${n.id} hasn't resumed yet`)),n.interrupt.resolve(),n.interrupt=null;let i=t(),a;try{a={status:`fulfilled`,value:await r.results}}catch(e){a={status:`rejected`,reason:e}}return this._schedule({type:`continue`,continuation:i,data:a,job:n}),i.promise}run(){this._state!==`ready`&&this._fail(Error(`executor not ready to start. state=${this._state}`));let e=t();return this._state=`running`,this._runResolver=e,this._tryQueue(),e.promise}};export{a as createBatchExecutor};
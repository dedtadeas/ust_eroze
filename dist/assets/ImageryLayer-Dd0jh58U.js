const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/imageryUtils-Cn-r4wiv.js","assets/index-BqmCqmfp.js","assets/index-kIqmb12G.css","assets/originUtils-Xpg5-Q2D.js","assets/utils-yJnMCzaE.js","assets/saveUtils-DsVVlvmj.js","assets/datasetUtils-DSaKkE9z.js"])))=>i.map(i=>d[i]);
import{$m as e,AE as t,Ad as n,Ax as r,Bu as i,CD as a,Cd as o,Cw as s,Ea as c,FC as l,Fu as u,Gi as d,Hx as f,Hy as p,IC as m,Id as h,J as g,Ji as _,Jm as v,Kb as y,Kw as ee,L as te,La as ne,MC as b,Ma as re,Mb as x,Nb as ie,OS as ae,PC as oe,Pa as se,Q as ce,Qw as le,Ra as ue,Si as de,Sw as S,Sx as fe,Td as pe,Um as C,Un as me,Ux as w,Vu as T,WT as he,X as ge,Z as _e,Zi as ve,_E as E,aC as ye,ao as be,dS as xe,e_ as Se,ea as Ce,gS as we,gp as Te,kC as D,ka as Ee,oC as O,ra as De,rt as Oe,ta as ke,vC as k,vE as Ae,yS as je,yw as Me,z as Ne,zC as Pe,zu as A,zy as j}from"./index-BqmCqmfp.js";import"./memoryEstimations-O7VgDRVG.js";import"./OptimizedFeature-Dx4_lHip.js";import"./OptimizedGeometry-f3I9Z6C1.js";import"./OptimizedFeatureSet-DlHqIhoP.js";import"./_commonjsHelpers-D6ht1XAa.js";import{n as Fe}from"./imageBitmapUtils-B6x9ZCyg.js";import{a as Ie,p as Le,t as Re}from"./elevationInfoUtils-Df_uYU_q.js";import"./generateRendererUtils-BgK3c0Qk.js";import"./urlUtils-CtPsFIu4.js";import"./pbf-CwGh07vG.js";import"./pbfQueryUtils-DOeTJOP2.js";import"./queryUtils-GIY2oFHT.js";import"./query-D8IHih8e.js";import{n as ze,t as Be}from"./executeForIds-CFB4h9Bk.js";import{n as Ve}from"./executeQueryJSON-BAg2ttNX.js";import{t as He}from"./isImageryGraphicOrigin-Qwa2m0c8.js";import{i as Ue,n as We,o as Ge,p as Ke,s as qe}from"./multidimensionalUtils-yEWHc_se.js";import{$ as Je,E as Ye,G as Xe,H as Ze,K as Qe,Q as $e,R as et,T as tt,V as nt,X as rt,et as it,t as at,z as ot}from"./RasterSymbolizer-CkbjgVe_.js";import{_ as st,a as ct,c as lt,d as ut,h as dt,i as ft,l as pt,m as mt,n as ht,o as gt,p as _t,s as vt,t as yt,v as M,y as N}from"./RasterJobHandlerMixin-CZVDgRFD.js";import{s as bt}from"./pixelRangeUtils-DMjHgTK0.js";import"./colorUtils-uG2qTogT.js";import{t as xt}from"./PixelBlock-CjVaas_l.js";import{a as St,c as Ct,d as wt,f as Tt,i as Et,l as Dt,n as Ot,o as kt,p as At,r as jt,s as Mt,t as Nt,u as Pt}from"./rasterFieldUtils-BXl_hh-f.js";import{A as Ft,o as It}from"./vectorFieldUtils-yzcuu25U.js";import"./datasetUtils-DSaKkE9z.js";import"./cimSymbolUtils-1FVTTBxd.js";import"./gfxUtils-DZoKCRMw.js";import"./utils-5jlQHYup.js";import{i as Lt,n as Rt,r as zt,t as Bt}from"./RasterPresetRendererMixin-u_rjWqJG.js";import"./dataUtils-lUZ4DUuE.js";var Vt,Ht=class extends ne{get[(Vt=He,ue)](){return this.layer}constructor(e){super(),this[Vt]=!0,this.type=`imagery`,this.layer=e}get id(){return this.layer.id}},Ut={StretchFunction:{arguments:{ComputeGamma:{isDataset:!1,isPublic:!1,name:`ComputeGamma`,type:`RasterFunctionVariable`,value:!1},DRA:{isDataset:!1,isPublic:!1,name:`DRA`,type:`RasterFunctionVariable`,value:!1},EstimateStatsHistogram:{isDataset:!1,isPublic:!1,name:`EstimateStatsHistogram`,type:`RasterFunctionVariable`,value:!1},Gamma:{displayName:`Gamma`,isDataset:!1,isPublic:!1,name:`Gamma`,type:`RasterFunctionVariable`},Histograms:{isDataset:!1,isPublic:!1,name:`Histograms`,type:`RasterFunctionVariable`},Max:{isDataset:!1,isPublic:!1,name:`Max`,type:`RasterFunctionVariable`,value:255},MaxPercent:{isDataset:!1,isPublic:!1,name:`MaxPercent`,type:`RasterFunctionVariable`,value:.5},Min:{isDataset:!1,isPublic:!1,name:`Min`,type:`RasterFunctionVariable`,value:0},MinPercent:{isDataset:!1,isPublic:!1,name:`MinPercent`,type:`RasterFunctionVariable`,value:.25},NumberOfStandardDeviations:{isDataset:!1,isPublic:!1,name:`NumberOfStandardDeviation`,type:`RasterFunctionVariable`,value:2},Raster:{isDataset:!0,isPublic:!1,name:`Raster`,type:`RasterFunctionVariable`},SigmoidStrengthLevel:{isDataset:!1,isPublic:!1,name:`SigmoidStrengthLevel`,type:`RasterFunctionVariable`,value:2},Statistics:{isDataset:!1,isPublic:!1,name:`Statistics`,type:`RasterFunctionVariable`},StretchType:{isDataset:!1,isPublic:!1,name:`StretchType`,type:`RasterFunctionVariable`,value:0},type:`StretchFunctionArguments`,UseGamma:{isDataset:!1,isPublic:!1,name:`UseGamma`,type:`RasterFunctionVariable`,value:!1}},description:`Enhances an image by adjusting the range of values displayed. This does not alter the underlying pixel values. If a pixel has a value outside of the specified range, it will appear as either the minimum or maximum value.`,function:{description:`Enhances an image by adjusting the range of values displayed. This does not alter the underlying pixel values. If a pixel has a value outside of the specified range, it will appear as either the minimum or maximum value.`,name:`Stretch`,pixelType:`UNKNOWN`,type:`StretchFunction`},functionType:0,name:`Stretch`,thumbnail:``},RemapFunction:{name:`Remap`,description:`Changes pixel values by assigning new values to ranges of pixel values or using an external table.`,function:{type:`RemapFunction`,pixelType:`UNKNOWN`,name:`Remap`,description:`Changes pixel values by assigning new values to ranges of pixel values or using an external table.`},arguments:{Raster:{name:`Raster`,isPublic:!1,isDataset:!0,type:`RasterFunctionVariable`},UseTable:{name:`UseTable`,isPublic:!1,isDataset:!1,value:!1,type:`RasterFunctionVariable`},InputRanges:{name:`InputRanges`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`,displayName:`Input Ranges`},OutputValues:{name:`OutputValues`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`,displayName:`Output Values`},NoDataRanges:{name:`NoDataRanges`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`,displayName:`NoData Ranges`},Table:{name:`Table`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`},InputField:{name:`InputField`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`},OutputField:{name:`OutputField`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`},InputMaxField:{name:`InputMaxField`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`},RemapTableType:{name:`RemapTableType`,isPublic:!1,isDataset:!1,value:1,type:`RasterFunctionVariable`},AllowUnmatched:{name:`AllowUnmatched`,isPublic:!1,isDataset:!1,value:!0,type:`RasterFunctionVariable`},type:`RemapFunctionArguments`},functionType:0,thumbnail:``},ColormapFunction:{name:`Colormap`,description:`Changes pixel values to display the raster data as either a grayscale or a red, green, blue (RGB) image, based on a colormap or a color ramp.`,function:{type:`ColormapFunction`,pixelType:`UNKNOWN`,name:`Colormap`,description:`Changes pixel values to display the raster data as either a grayscale or a red, green, blue (RGB) image, based on a colormap or a color ramp.`},arguments:{Raster:{name:`Raster`,isPublic:!1,isDataset:!0,type:`RasterFunctionVariable`},ColorSchemeType:{name:`ColorSchemeType`,isPublic:!1,isDataset:!1,value:1,type:`RasterFunctionVariable`},Colormap:{name:`Colormap`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`},ColormapName:{name:`ColormapName`,isPublic:!1,isDataset:!1,value:`Gray`,type:`RasterFunctionVariable`},ColorRamp:{name:`ColorRamp`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`},type:`ColormapFunctionArguments`},functionType:0,thumbnail:``},ShadedReliefFunction:{name:`Shaded Relief`,description:`Creates a multiband, color coded, 3D representation of the surface, with the sun's relative position taken into account for shading the image.`,function:{type:`ShadedReliefFunction`,pixelType:`UNKNOWN`,name:`Shaded Relief`,description:`Creates a multiband, color coded, 3D representation of the surface, with the sun's relative position taken into account for shading the image.`},arguments:{Raster:{name:`Raster`,isPublic:!1,isDataset:!0,type:`RasterFunctionVariable`},ColorSchemeType:{name:`ColorSchemeType`,isPublic:!1,isDataset:!1,value:1,type:`RasterFunctionVariable`},ColorRamp:{name:`ColorRamp`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`},HillshadeType:{name:`HillshadeType`,isPublic:!1,isDataset:!1,value:0,type:`RasterFunctionVariable`},Colormap:{name:`Colormap`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`},Azimuth:{name:`Azimuth`,isPublic:!1,isDataset:!1,value:315,type:`RasterFunctionVariable`},Altitude:{name:`Altitude`,isPublic:!1,isDataset:!1,value:45,type:`RasterFunctionVariable`},SlopeType:{name:`SlopeType`,isPublic:!1,isDataset:!1,value:1,type:`RasterFunctionVariable`},ZFactor:{name:`ZFactor`,isPublic:!1,isDataset:!1,value:1,type:`RasterFunctionVariable`},PSPower:{name:`PSPower`,isPublic:!1,isDataset:!1,value:.664,type:`RasterFunctionVariable`},PSZFactor:{name:`PSZFactor`,isPublic:!1,isDataset:!1,value:.024,type:`RasterFunctionVariable`},RemoveEdgeEffect:{name:`RemoveEdgeEffect`,isPublic:!1,isDataset:!1,value:!1,type:`RasterFunctionVariable`},type:`ShadedReliefFunctionArguments`},functionType:0,thumbnail:``},HillshadeFunction:{name:`Hillshade`,description:`Creates a 3D representation of the surface, with the sun's relative position taken into account for shading the image`,function:{type:`HillshadeFunction`,pixelType:`UNKNOWN`,name:`Hillshade`,description:`Creates a 3D representation of the surface, with the sun's relative position taken into account for shading the image`},arguments:{DEM:{name:`DEM`,isPublic:!1,isDataset:!0,type:`RasterFunctionVariable`},HillshadeType:{name:`HillshadeType`,isPublic:!1,isDataset:!1,value:0,type:`RasterFunctionVariable`},Azimuth:{name:`Azimuth`,isPublic:!1,isDataset:!1,value:315,type:`RasterFunctionVariable`},Altitude:{name:`Altitude`,isPublic:!1,isDataset:!1,value:45,type:`RasterFunctionVariable`},SlopeType:{name:`SlopeType`,isPublic:!1,isDataset:!1,value:1,type:`RasterFunctionVariable`},ZFactor:{name:`ZFactor`,isPublic:!1,isDataset:!1,value:1,type:`RasterFunctionVariable`},PSPower:{name:`PSPower`,isPublic:!1,isDataset:!1,value:.664,type:`RasterFunctionVariable`},PSZFactor:{name:`PSZFactor`,isPublic:!1,isDataset:!1,value:.024,type:`RasterFunctionVariable`},RemoveEdgeEffect:{name:`RemoveEdgeEffect`,isPublic:!1,isDataset:!1,value:!1,type:`RasterFunctionVariable`},type:`HillshadeFunctionArguments`},functionType:0,thumbnail:``},ResampleFunction:{name:`Resample`,description:`Changes the cell size of a raster.`,function:{type:`ResampleFunction`,pixelType:`UNKNOWN`,name:`Resample`,description:`Changes the cell size of a raster.`},arguments:{Raster:{name:`Raster`,isPublic:!1,isDataset:!0,type:`RasterFunctionVariable`},ResamplingType:{name:`ResamplingType`,isPublic:!1,isDataset:!1,value:0,type:`RasterFunctionVariable`},InputCellSize:{name:`InputCellsize`,isPublic:!1,isDataset:!1,value:{x:0,y:0},type:`RasterFunctionVariable`},OutputCellSize:{name:`OutputCellsize`,isPublic:!1,isDataset:!1,value:{x:0,y:0},type:`RasterFunctionVariable`},type:`ResampleFunctionArguments`},functionType:0,thumbnail:``}},Wt=new Set([`u1`,`u2`,`u4`,`u8`,`s8`,`u16`,`s16`]),Gt={simple_scalar:`Simple Scalar`,wind_barb:`Wind Barb`,single_arrow:`Single Arrow`,beaufort_kn:`Beaufort Wind (Knots)`,beaufort_m:`Beaufort Wind (MetersPerSecond)`,ocean_current_m:`Ocean Current (MetersPerSecond)`,ocean_current_kn:`Ocean Current (Knots)`},Kt=new Set([`raster-stretch`,`unique-value`,`class-breaks`,`raster-shaded-relief`,`vector-field`,`raster-colormap`]);function qt(e){return Kt.has(e.type)}function Jt(e,n){if(!e||!n)return t(e||n);let r=t(e);if(r.functionDefinition&&n.rasterFunctionDefinition){let e=n.rasterFunctionDefinition;(e.thumbnail||e.thumbnailEx)&&(e.thumbnail=e.thumbnailEx=void 0),Yt(r.functionDefinition.arguments,n),r.rasterFunctionDefinition=r.functionDefinition.toJSON()}else n.functionName?.toLowerCase()!==`none`&&(Zt(r.functionArguments).Raster=n);return r}function Yt(e,t){for(let n in e)n.toLowerCase()===`raster`&&(e[n].type===`RasterFunctionVariable`?(e[n]=t.rasterFunctionDefinition,e[n].type=`RasterFunctionTemplate`):e[n].type===`RasterFunctionTemplate`&&Yt(e[n].arguments,t))}function P(e){let n=t(Ut[e.functionName+`Function`]),r=e.functionArguments;for(let e in r)e.toLowerCase()===`raster`?(n.arguments[e]=P(r[e]),n.arguments[e].type=`RasterFunctionTemplate`):e.toLowerCase()===`colormap`?(n.arguments[e].value=ln(r[e]),n.arguments.ColorSchemeType.value=0):n.arguments[e].value=r[e];return n}function Xt(e,t){switch(t||={},e.type){case`raster-stretch`:return tn(e,t);case`class-breaks`:return nn(e,t);case`unique-value`:return on(e,t);case`raster-colormap`:return cn(e,t);case`vector-field`:return $t(e,t);case`raster-shaded-relief`:return en(e,t);case`flow`:throw Error(`Unsupported rendering rule.`)}}function Zt(e){let t=e?.Raster??e?.raster;return t&&t.declaredClass===`esri.layers.support.RasterFunction`?Zt(t.functionArguments):e}var Qt={none:0,standardDeviation:3,histogramEqualization:4,minMax:5,percentClip:6,sigmoid:9};function $t(e,t){let n=new N;n.functionName=`VectorFieldRenderer`;let{dataType:r,bandNames:i}=t,a=r===`vector-uv`,o,s;if(i&&i.length===2){let e=i.map(e=>e.toLowerCase());o=e.indexOf(`magnitude`),s=e.indexOf(`direction`)}o!==-1&&o!==null||(o=0,s=1);let c=e.rotationType===`arithmetic`?1:2,l=e.flowRepresentation===`flow-from`?0:1,u=e.visualVariables?e.visualVariables.find(e=>e.field===`Magnitude`):new de;n.functionArguments={magnitudeBandID:o,directionBandID:s,isUVComponents:a,referenceSystem:c,massFlowAngleRepresentation:l,symbolTileSize:50,symbolTileSizeUnits:100,calculationMethod:`Vector Average`,symbologyName:Gt[e.style.toLowerCase().replace(`-`,`_`)],minimumMagnitude:u.minDataValue,maximumMagnitude:u.maxDataValue,minimumSymbolSize:u.minSize,maximumSymbolSize:u.maxSize};let d=P(n);return t.convertToRFT?N.fromJSON({rasterFunctionDefinition:d}):n}function en(e,t){let n=t.convertToRFT;if(t.dataType!==`elevation`&&(t.dataType!==`generic`||t.bandCount!==1||t.pixelType!==`s16`&&t.pixelType!==`s32`&&t.pixelType!==`f32`&&t.pixelType!==`f64`))return new N;let r=new N;r.functionName=`Hillshade`;let i=e.hillshadeType===`traditional`?0:1,a=e.scalingType===`none`?1:3,o={HillshadeType:i,SlopeType:a,ZFactor:e.zFactor};return i===0&&(o.Azimuth=e.azimuth,o.Altitude=e.altitude),a===3&&(o.PSPower=e.pixelSizePower,o.PSZFactor=e.pixelSizeFactor),r.functionArguments=o,r.variableName=`Raster`,e.colorRamp&&(r.functionName=`ShadedRelief`,n?o.ColorRamp=Xe(e.colorRamp):o.Colormap=Ze(e.colorRamp)),n?new N({rasterFunctionDefinition:P(r)}):r}function tn(e,t){let n=t.convertToRFT,r=new N;r.functionName=`Stretch`;let i=Qt[nt.toJSON(e.stretchType)],a=e.customStatistics?.map(e=>[e.min,e.max,e.avg??0,e.stddev??1]),o={StretchType:i,Statistics:a,DRA:e.dynamicRangeAdjustment,UseGamma:e.useGamma,Gamma:e.gamma,ComputeGamma:e.computeGamma};if(e.outputMin!=null&&(o.Min=e.outputMin),e.outputMax!=null&&(o.Max=e.outputMax),i===Qt.standardDeviation?(o.NumberOfStandardDeviations=e.numberOfStandardDeviations,r.outputPixelType=`u8`):i===Qt.percentClip?(o.MinPercent=e.minPercent,o.MaxPercent=e.maxPercent,r.outputPixelType=`u8`):i===Qt.minMax?r.outputPixelType=`u8`:i===Qt.sigmoid&&(o.SigmoidStrengthLevel=e.sigmoidStrengthLevel),r.functionArguments=o,r.variableName=`Raster`,e.colorRamp){let i=e.colorRamp,a=new N;if(n)a.functionArguments={ColorRamp:Xe(i)};else{let n=rt(i,!0);if(n)a.functionArguments={colorRampName:n};else if(!t.convertColorRampToColormap||i.type!==`algorithmic`&&i.type!==`multipart`){let t=e.colorRamp.toJSON();t.type===`algorithmic`?t.algorithm=t.algorithm||`esriCIELabAlgorithm`:t.type===`multipart`&&t.colorRamps?.length&&t.colorRamps.forEach(e=>e.algorithm=e.algorithm||`esriCIELabAlgorithm`),a.functionArguments={colorRamp:t}}else a.functionArguments={Colormap:Ze(i)}}return a.variableName=`Raster`,a.functionName=`Colormap`,a.functionArguments.Raster=r,n?new N({rasterFunctionDefinition:P(a)}):a}return n?new N({rasterFunctionDefinition:P(r)}):r}function nn(e,t){let n=[],r=[],i=[],a=[],o=1e-4,{pixelType:s,rasterAttributeTable:c}=t,l=c==null?null:c.features,u=an(c);if(u&&l&&Array.isArray(l)&&e.classBreakInfos){e.classBreakInfos.forEach((t,n)=>{let r=t.symbol?.color,i;r?.a&&t.minValue!=null&&t.maxValue!=null&&l.forEach(o=>{t.minValue!=null&&t.maxValue!=null&&(i=o.attributes[e.field],(i>=t.minValue&&i<t.maxValue||n===e.classBreakInfos.length-1&&i>=t.minValue)&&a.push([o.attributes[u],r.r,r.g,r.b]))})});let n=s?rn(a,s):a,r=new N;return r.functionName=`Colormap`,r.functionArguments={},r.functionArguments.Colormap=n,r.variableName=`Raster`,t.convertToRFT?new N({rasterFunctionDefinition:P(r)}):r}e.classBreakInfos.forEach((e,t)=>{if(e.minValue==null||e.maxValue==null)return;let s=e.symbol&&e.symbol.color;s?.a?(t===0?n.push(e.minValue,e.maxValue+o):n.push(e.minValue+o,e.maxValue+o),r.push(t),a.push([t,s.r,s.g,s.b])):i.push(e.minValue,e.maxValue)});let d=s?rn(a,s):a,f=new N;f.functionName=`Remap`,f.functionArguments={InputRanges:n,OutputValues:r,NoDataRanges:i},f.variableName=`Raster`;let p=new N;return p.functionName=`Colormap`,p.functionArguments={Colormap:d,Raster:f},t.convertToRFT?new N({rasterFunctionDefinition:P(p)}):p}function rn(e,t){let n=Wt.has(t)?bt(t):null;return n&&e.push([Math.floor(n[0]-1),0,0,0],[Math.ceil(n[1]+1),0,0,0]),e}function an(e){if(e==null)return;let{fields:t}=e;return t?.find(e=>e?.name&&e.name.toLowerCase()===`value`)?.name}function on(e,t){let n=[],{pixelType:r,rasterAttributeTable:i}=t,a=i==null?null:i.features,o=an(i),s=e.defaultSymbol?.color?.toRgb(),c=e.uniqueValueInfos;if(c)if(a){if(o){let t=new Map;c.forEach(e=>{let n=e.value,r=sn(e);n!=null&&r?.a&&t.set(String(n),r.toRgb())});let r=e.field;r&&a.forEach(({attributes:e})=>{let i=String(e[r]),a=e[o],c=t.get(i);c?n.push([a,...c]):s&&n.push([a,...s])})}}else for(let e=0;e<c.length;e++){let t=c[e],r=sn(t),i=+t.value;if(r?.a){if(isNaN(i))return null;n.push([i,r.r,r.g,r.b])}}let l=r?rn(n,r):n,u=new N;return u.functionName=`Colormap`,u.functionArguments={},u.functionArguments.Colormap=l,u.variableName=`Raster`,t.convertToRFT?new N({rasterFunctionDefinition:P(u)}):u}function sn(e){return e.symbol?.type===`polygon-3d`?e.symbol.symbolLayers?.find(e=>e.type===`fill`)?.material?.color:e.symbol?.color}function cn(e,t){let n=e.extractColormap();if(!n||n.length===0)return null;let{pixelType:r}=t,i=r?rn(n,r):n,a=new N;return a.functionName=`Colormap`,a.functionArguments={},a.functionArguments.Colormap=i,t.convertToRFT?new N({rasterFunctionDefinition:P(a)}):a}function ln(e){let t=[],n=[];return e.forEach(e=>{t.push(e[0]),n.push(Qe([...e.slice(1),255]))}),{type:`RasterColormap`,values:t,colors:n}}var F=class extends k{constructor(){super(...arguments),this.layer=null,this.requestRawData=!1,this.compression=void 0,this.lercVersion=2}get adjustAspectRatio(){return this.layer.adjustAspectRatio}writeAdjustAspectRatio(e,t,n){this.layer.version<10.3||(t[n]=e)}get bandIds(){return this.layer.bandIds}get compressionQuality(){return this.layer.compressionQuality}writeCompressionQuality(e,t,n){this.format&&this.format.toLowerCase().includes(`jpg`)&&e!=null&&(t[n]=e)}get compressionTolerance(){return this.layer.compressionTolerance}writeCompressionTolerance(e,t,n){this.format===`lerc`&&e!=null&&(t[n]=e)}get format(){return this.requestRawData||this.layer.renderer?.type===`vector-field`?`lerc`:this.layer.format}get interpolation(){return this.layer.interpolation}get noData(){return this.layer.noData}get noDataInterpretation(){return this.layer.noDataInterpretation}get pixelType(){let{layer:e}=this;return e.pixelType===e.serviceRasterInfo.pixelType?void 0:e.pixelType}writeLercVersion(e,t,n){this.format===`lerc`&&this.layer.version>=10.5&&(t[n]=e)}get version(){let e=this.layer;return e.commitProperty(`bandIds`),e.commitProperty(`format`),e.commitProperty(`compressionQuality`),e.commitProperty(`compressionTolerance`),e.commitProperty(`interpolation`),e.commitProperty(`noData`),e.commitProperty(`noDataInterpretation`),e.commitProperty(`mosaicRule`),e.commitProperty(`rasterFunction`),e.commitProperty(`adjustAspectRatio`),e.commitProperty(`pixelFilter`),e.commitProperty(`pixelType`),e.commitProperty(`definitionExpression`),e.commitProperty(`multidimensionalSubset`),(this._get(`version`)||0)+1}set version(e){this._set(`version`,e)}get mosaicRule(){let e=this.layer,t=e.mosaicRule,n=e.definitionExpression;return t?n&&n!==t.where&&(t=t.clone(),t.where=n):n&&(t=new M({where:n})),t}get rasterFunction(){let e=this.layer,{rasterFunction:t}=e,n=e.pixelFilter,r=!e.format||e.format.includes(`jpg`)||e.format.includes(`png`);this.requestRawData||(t=this._addResampleRasterFunction(t));let i=e.multidimensionalSubset?.areaOfInterest;return i&&(t=un(t,i)),this.requestRawData||!r||n||e.renderer?.type===`vector-field`||(t=this.combineRendererWithRenderingRule(t)),t}combineRendererWithRenderingRule(e){let t=this.layer,{rasterInfo:n,renderer:r}=t;return e||=t.rasterFunction,!r||!qt(r)?e:Jt(Xt(r,{rasterAttributeTable:n.attributeTable,pixelType:n.pixelType,dataType:n.dataType,bandNames:n.bandInfos.map(({name:e})=>e),convertColorRampToColormap:t.version<10.6,convertToRFT:!!e?.rasterFunctionDefinition,bandCount:n.bandCount}),e)}_addResampleRasterFunction(e){if(this.layer.renderer?.type!==`vector-field`||e?.functionName===`Resample`)return e;let t=this.layer.serviceDataType===`esriImageServiceDataTypeVector-UV`?7:10,n=this.layer.serviceRasterInfo.pixelSize,r=new N({functionName:`Resample`,functionArguments:{ResamplingType:t,InputCellSize:n}});return r=e?.rasterFunctionDefinition?new N({rasterFunctionDefinition:P(r)}):r,Jt(r,e)}};function un(e,t){let n=new N({functionName:`Clip`,functionArguments:{ClippingGeometry:t.toJSON(),ClippingType:1}});return Jt(n,e)}a([b()],F.prototype,`layer`,void 0),a([b()],F.prototype,`requestRawData`,void 0),a([b({json:{write:!0}})],F.prototype,`adjustAspectRatio`,null),a([O(`adjustAspectRatio`)],F.prototype,`writeAdjustAspectRatio`,null),a([b({json:{write:!0}})],F.prototype,`bandIds`,null),a([b({json:{write:!0}})],F.prototype,`compression`,void 0),a([b({json:{write:!0}})],F.prototype,`compressionQuality`,null),a([O(`compressionQuality`)],F.prototype,`writeCompressionQuality`,null),a([b({json:{write:!0}})],F.prototype,`compressionTolerance`,null),a([O(`compressionTolerance`)],F.prototype,`writeCompressionTolerance`,null),a([b({json:{write:!0}})],F.prototype,`format`,null),a([b({type:String,json:{read:{reader:$e.read},write:{writer:$e.write}}})],F.prototype,`interpolation`,null),a([b({json:{write:!0}})],F.prototype,`noData`,null),a([b({type:String,json:{read:{reader:Je.read},write:{writer:Je.write}}})],F.prototype,`noDataInterpretation`,null),a([b({type:it.apiValues,json:{read:it.read,write:it.write}})],F.prototype,`pixelType`,null),a([b({json:{write:!0}})],F.prototype,`lercVersion`,void 0),a([O(`lercVersion`)],F.prototype,`writeLercVersion`,null),a([b({type:Number})],F.prototype,`version`,null),a([b({json:{write:!0}})],F.prototype,`mosaicRule`,null),a([b({json:{write:!0,name:`renderingRule`}})],F.prototype,`rasterFunction`,null),F=a([D(`esri.layers.support.ExportImageServiceParameters`)],F);var I=class extends j(k){constructor(e){super(e),this.fromGeometry=null,this.toGeometry=null,this.objectIds=null,this.where=null,this.maxCount=null}};a([b({type:r,json:{read:!0}})],I.prototype,`fromGeometry`,void 0),a([b({type:r,json:{read:!0,write:!0}})],I.prototype,`toGeometry`,void 0),a([b({json:{write:!0}})],I.prototype,`objectIds`,void 0),a([b({type:String,json:{write:!0}})],I.prototype,`where`,void 0),a([b({type:Number,json:{write:!0}})],I.prototype,`maxCount`,void 0),I=a([D(`esri.rest.support.FindImagesParameters`)],I);var dn=e=>{let t=e,n=class extends t{constructor(){super(...arguments),this.make=null,this.model=null,this.focalLength=null,this.pixelSize=null,this.rows=null,this.cols=null}};return a([b({json:{write:!0}})],n.prototype,`make`,void 0),a([b({json:{write:!0}})],n.prototype,`model`,void 0),a([b({json:{write:!0}})],n.prototype,`focalLength`,void 0),a([b({json:{write:!0}})],n.prototype,`pixelSize`,void 0),a([b({json:{write:!0}})],n.prototype,`rows`,void 0),a([b({json:{write:!0}})],n.prototype,`cols`,void 0),n=a([D(`esri.rest.support.CameraInfoMixin`)],n),n},L=class extends dn(k){constructor(){super(...arguments),this.id=null,this.referenceUri=null,this.acquisitionDate=null,this.cameraID=null,this.center=null,this.perspectiveCenter=null,this.orientation=null}writeAcquisitionDate(e,t){t.acquisitionDate=e?.getTime()}};a([b({json:{write:!0}})],L.prototype,`id`,void 0),a([b({json:{name:`uri`,write:!0}})],L.prototype,`referenceUri`,void 0),a([b({type:Date,json:{write:!0}})],L.prototype,`acquisitionDate`,void 0),a([O(`acquisitionDate`)],L.prototype,`writeAcquisitionDate`,null),a([b({json:{write:!0}})],L.prototype,`cameraID`,void 0),a([b({type:r,json:{write:!0}})],L.prototype,`center`,void 0),a([b({type:r,json:{write:!0}})],L.prototype,`perspectiveCenter`,void 0),a([b({json:{write:!0}})],L.prototype,`orientation`,void 0),L=a([D(`esri.rest.support.ImageInspectionInfo`)],L);var fn=L,pn=class extends k{constructor(){super(...arguments),this.images=null}};a([b({type:[fn],json:{write:!0}})],pn.prototype,`images`,void 0),pn=a([D(`esri.rest.support.FindImagesResult`)],pn);var mn,hn=mn=class extends k{constructor(e){super(e),this.angleNames=null,this.point=null,this.spatialReference=null,this.rasterId=null}clone(){return new mn(t({angleNames:this.angleNames,point:this.point,spatialReference:this.spatialReference,rasterId:this.rasterId}))}};a([b({type:[String],json:{name:`angleName`,write:!0}})],hn.prototype,`angleNames`,void 0),a([b({type:r,json:{write:!0}})],hn.prototype,`point`,void 0),a([b({type:w,json:{write:!0}})],hn.prototype,`spatialReference`,void 0),a([b({type:Pe,json:{write:!0}})],hn.prototype,`rasterId`,void 0),hn=mn=a([D(`esri.rest.support.ImageAngleParameters`)],hn);var gn=class extends k{constructor(e){super(e),this.north=null,this.up=null,this.spatialReference=null}};a([b({type:Number,json:{write:!0}})],gn.prototype,`north`,void 0),a([b({type:Number,json:{write:!0}})],gn.prototype,`up`,void 0),a([b({type:w,json:{write:!0}})],gn.prototype,`spatialReference`,void 0),gn=a([D(`esri.rest.support.ImageAngleResult`)],gn);var R=new ye({esriMensurationPoint:`point`,esriMensurationCentroid:`centroid`,esriMensurationDistanceAndAngle:`distance-and-angle`,esriMensurationAreaAndPerimeter:`area-and-perimeter`,esriMensurationHeightFromBaseAndTop:`base-and-top`,esriMensurationHeightFromBaseAndTopShadow:`base-and-top-shadow`,esriMensurationHeightFromTopAndTopShadow:`top-and-top-shadow`,esriMensurationPoint3D:`point-3D`,esriMensurationCentroid3D:`centroid-3D`,esriMensurationDistanceAndAngle3D:`distance-and-angle-3D`,esriMensurationAreaAndPerimeter3D:`area-and-perimeter-3D`}),z=class extends k{constructor(){super(...arguments),this.value=null,this.displayValue=null,this.uncertainty=null}};a([b({type:Number,json:{read:!0,write:!0}})],z.prototype,`value`,void 0),a([b({type:String,json:{read:!0,write:!0}})],z.prototype,`displayValue`,void 0),a([b({type:Number,json:{read:!0,write:!0}})],z.prototype,`uncertainty`,void 0),z=a([D(`esri.rest.support.imageMeasureUtils.BaseImageMeasureResultValue`)],z);var _n=class extends z{constructor(){super(...arguments),this.unit=null}};a([b({type:String,json:{read:je.read,write:je.write}})],_n.prototype,`unit`,void 0),_n=a([D(`esri.rest.support.imageMeasureUtils.ImageMeasureResultLengthValue`)],_n);var vn=class extends z{constructor(){super(...arguments),this.unit=null}};a([b({type:String,json:{read:we.read,write:we.write}})],vn.prototype,`unit`,void 0),vn=a([D(`esri.rest.support.imageMeasureUtils.ImageMeasureResultAreaValue`)],vn);var yn=class extends z{constructor(){super(...arguments),this.unit=null}};a([b({type:String,json:{read:xe.read,write:xe.write}})],yn.prototype,`unit`,void 0),yn=a([D(`esri.rest.support.imageMeasureUtils.ImageMeasureResultAngleValue`)],yn);var B=class extends k{constructor(e){super(e),this.type=null,this.measureOperation=null,this.mosaicRule=null,this.pixelSize=null,this.raster=void 0}};a([b()],B.prototype,`type`,void 0),a([b({type:R.apiValues,json:{read:R.read,write:R.write}})],B.prototype,`measureOperation`,void 0),a([b({type:M,json:{write:!0}})],B.prototype,`mosaicRule`,void 0),a([b({type:r,json:{write:!0}})],B.prototype,`pixelSize`,void 0),a([b({json:{write:!0}})],B.prototype,`raster`,void 0),B=a([D(`esri.rest.support.BaseImageMeasureParameters`)],B);var bn,V=bn=class extends B{constructor(e){super(e),this.type=`area-perimeter`,this.geometry=null,this.is3D=!1,this.linearUnit=`meters`,this.areaUnit=`square-meters`}writeGeometry(t,n,r){t!=null&&(n.geometryType=e(t),n[r]=t.toJSON())}get measureOperation(){return this.is3D?`area-and-perimeter-3D`:`area-and-perimeter`}clone(){return new bn(t({geometry:this.geometry,is3D:this.is3D,linearUnit:this.linearUnit,areaUnit:this.areaUnit,mosaicRule:this.mosaicRule,pixelSize:this.pixelSize,raster:this.raster}))}};a([b({types:C,json:{name:`fromGeometry`,read:!0,write:!0}})],V.prototype,`geometry`,void 0),a([O(`geometry`)],V.prototype,`writeGeometry`,null),a([b({type:R.apiValues,json:{write:R.write}})],V.prototype,`measureOperation`,null),a([b({json:{read:!0}})],V.prototype,`is3D`,void 0),a([b({type:String,json:{read:je.read,write:je.write}})],V.prototype,`linearUnit`,void 0),a([b({type:String,json:{read:we.read,write:we.write}})],V.prototype,`areaUnit`,void 0),V=bn=a([D(`esri.rest.support.ImageAreaParameters`)],V);var xn=class extends k{constructor(e){super(e),this.name=null,this.sensorName=null}};a([b({type:String,json:{read:!0,write:!0}})],xn.prototype,`name`,void 0),a([b({type:String,json:{read:!0,write:!0}})],xn.prototype,`sensorName`,void 0),xn=a([D(`esri.rest.support.BaseImageMeasureResult`)],xn);var Sn=class extends xn{constructor(){super(...arguments),this.area=null,this.perimeter=null}};a([b({type:vn,json:{read:!0,write:!0}})],Sn.prototype,`area`,void 0),a([b({type:_n,json:{read:!0,write:!0}})],Sn.prototype,`perimeter`,void 0),Sn=a([D(`esri.rest.support.ImageAreaResult`)],Sn);var Cn=class extends j(k){constructor(e){super(e),this.outSpatialReference=null}};a([b({type:w,json:{name:`outSR`,write:!0}})],Cn.prototype,`outSpatialReference`,void 0),Cn=a([D(`esri.rest.support.ImageBoundaryParameters`)],Cn);var wn=class extends k{constructor(){super(...arguments),this.area=null,this.geometry=null}readGeometry(e,t){return e==null?null:e.rings?Se.fromJSON(e):fe.fromJSON(e)}};a([b({type:Number,json:{write:!0}})],wn.prototype,`area`,void 0),a([b({types:C,json:{name:`shape`,write:!0}})],wn.prototype,`geometry`,void 0),a([f(`geometry`)],wn.prototype,`readGeometry`,null),wn=a([D(`esri.rest.support.ImageBoundaryResult`)],wn);var Tn,H=Tn=class extends B{constructor(e){super(e),this.type=`distance-angle`,this.fromGeometry=null,this.toGeometry=null,this.is3D=!1,this.linearUnit=`meters`,this.angularUnit=`degrees`}writeFromGeometry(t,n,r){t!=null&&(n.geometryType=e(t),n[r]=t.toJSON())}get measureOperation(){return this.is3D?`distance-and-angle-3D`:`distance-and-angle`}clone(){return new Tn(t({fromGeometry:this.fromGeometry,toGeometry:this.toGeometry,is3D:this.is3D,linearUnit:this.linearUnit,angularUnit:this.angularUnit,mosaicRule:this.mosaicRule,pixelSize:this.pixelSize,raster:this.raster}))}};a([b({type:r,json:{read:!0,write:!0}})],H.prototype,`fromGeometry`,void 0),a([O(`fromGeometry`)],H.prototype,`writeFromGeometry`,null),a([b({type:r,json:{read:!0,write:!0}})],H.prototype,`toGeometry`,void 0),a([b({type:R.apiValues,json:{write:R.write}})],H.prototype,`measureOperation`,null),a([b({json:{read:!0}})],H.prototype,`is3D`,void 0),a([b({type:String,json:{read:je.read,write:je.write}})],H.prototype,`linearUnit`,void 0),a([b({type:String,json:{read:xe.read,write:xe.write}})],H.prototype,`angularUnit`,void 0),H=Tn=a([D(`esri.rest.support.ImageDistanceParameters`)],H);var En=class extends xn{constructor(){super(...arguments),this.distance=null,this.azimuthAngle=null,this.elevationAngle=null}};a([b({type:_n,json:{read:!0,write:!0}})],En.prototype,`distance`,void 0),a([b({type:yn,json:{read:!0,write:!0}})],En.prototype,`azimuthAngle`,void 0),a([b({type:yn,json:{read:!0,write:!0}})],En.prototype,`elevationAngle`,void 0),En=a([D(`esri.rest.support.ImageDistanceResult`)],En);var U=class extends j(k){constructor(e){super(e),this.geometry=null,this.objectIds=null,this.spatialRelationship=`intersects`,this.timeExtent=null,this.where=null}writeGeometry(t,n,r){t!=null&&(n.geometryType=e(t),n[r]=JSON.stringify(t.toJSON()))}};a([b({types:C,json:{read:v,write:!0}})],U.prototype,`geometry`,void 0),a([O(`geometry`)],U.prototype,`writeGeometry`,null),a([b({json:{write:!0}})],U.prototype,`objectIds`,void 0),a([p(pe,{ignoreUnknown:!1,name:`spatialRel`})],U.prototype,`spatialRelationship`,void 0),a([b({type:ie,json:{name:`time`,write:!0}})],U.prototype,`timeExtent`,void 0),a([b({type:String,json:{write:!0}})],U.prototype,`where`,void 0),U=a([D(`esri.rest.support.ImageGPSInfoParameters`)],U);var Dn=class extends dn(k){constructor(){super(...arguments),this.id=null}};a([b({json:{write:!0}})],Dn.prototype,`id`,void 0),Dn=a([D(`esri.rest.support.CameraInfo`)],Dn);var On=Dn,W=class extends k{constructor(){super(...arguments),this.id=null,this.name=null,this.acquisitionDate=null,this.cameraID=null,this.center=null,this.gps=null,this.orientation=null}writeAcquisitionDate(e,t){t.acquisitionDate=e?.getTime()}};a([b({json:{write:!0}})],W.prototype,`id`,void 0),a([b({json:{write:!0}})],W.prototype,`name`,void 0),a([b({type:Date,json:{write:!0}})],W.prototype,`acquisitionDate`,void 0),a([O(`acquisitionDate`)],W.prototype,`writeAcquisitionDate`,null),a([b({json:{write:!0}})],W.prototype,`cameraID`,void 0),a([b({type:r,json:{write:!0}})],W.prototype,`center`,void 0),a([b({json:{write:!0}})],W.prototype,`gps`,void 0),a([b({json:{write:!0}})],W.prototype,`orientation`,void 0),W=a([D(`esri.rest.support.ImageGPSInfo`)],W);var kn=W,An=class extends k{constructor(){super(...arguments),this.images=null,this.cameras=null}};a([b({type:[kn],json:{write:!0}})],An.prototype,`images`,void 0),a([b({type:[On],json:{write:!0}})],An.prototype,`cameras`,void 0),An=a([D(`esri.rest.support.ImageGPSInfoResult`)],An);var jn,G=jn=class extends B{constructor(e){super(e),this.type=`height`,this.fromGeometry=null,this.toGeometry=null,this.operationType=`base-and-top`,this.linearUnit=`meters`}writeFromGeometry(t,n,r){t!=null&&(n.geometryType=e(t),n[r]=t.toJSON())}get measureOperation(){return this.operationType}clone(){return new jn(t({fromGeometry:this.fromGeometry,toGeometry:this.toGeometry,operationType:this.operationType,linearUnit:this.linearUnit,mosaicRule:this.mosaicRule,pixelSize:this.pixelSize,raster:this.raster}))}};a([b({type:r,json:{read:!0}})],G.prototype,`fromGeometry`,void 0),a([O(`fromGeometry`)],G.prototype,`writeFromGeometry`,null),a([b({type:r,json:{read:!0,write:!0}})],G.prototype,`toGeometry`,void 0),a([b({type:R.apiValues,json:{write:R.write}})],G.prototype,`measureOperation`,null),a([b({json:{read:!0}})],G.prototype,`operationType`,void 0),a([b({type:String,json:{read:je.read,write:je.write}})],G.prototype,`linearUnit`,void 0),G=jn=a([D(`esri.rest.support.ImageHeightParameters`)],G);var Mn=class extends xn{constructor(){super(...arguments),this.height=null}};a([b({type:_n,json:{read:!0,write:!0}})],Mn.prototype,`height`,void 0),Mn=a([D(`esri.rest.support.ImageHeightResult`)],Mn);var Nn,K=Nn=class extends k{constructor(e){super(e),this.geometry=null,this.rasterFunctions=null,this.pixelSize=null,this.returnGeometry=!0,this.returnCatalogItems=!0,this.returnPixelValues=!0,this.maxItemCount=null,this.timeExtent=null,this.raster=void 0,this.viewId=void 0,this.processAsMultidimensional=!1}writeGeometry(t,n,r){t!=null&&(n.geometryType=e(t),n[r]=JSON.stringify(t.toJSON()))}set mosaicRule(e){let t=e;t?.mosaicMethod&&(t=M.fromJSON({...t.toJSON(),mosaicMethod:t.mosaicMethod,mosaicOperation:t.mosaicOperation})),this._set(`mosaicRule`,t)}writeMosaicRule(e,t,n){e!=null&&(t[n]=JSON.stringify(e.toJSON()))}set rasterFunction(e){let t=e;t?.rasterFunction&&(t=N.fromJSON({...t.toJSON(),rasterFunction:t.rasterFunction,rasterFunctionArguments:t.rasterFunctionArguments})),this._set(`rasterFunction`,t)}writeRasterFunction(e,t,n){e!=null&&(t[n]=JSON.stringify(e.toJSON())),e.rasterFunctionDefinition&&(t[n]=JSON.stringify(e.rasterFunctionDefinition))}writeRasterFunctions(e,t,n){e!=null&&(t[n]=JSON.stringify(e.map(e=>e.rasterFunctionDefinition||e.toJSON())))}writePixelSize(e,t,n){e!=null&&(t[n]=JSON.stringify(e))}writeTimeExtent(e,t,n){if(e!=null){let r=e.start==null?null:e.start.getTime(),i=e.end==null?null:e.end.getTime();t[n]=r==null?null:i==null?`${r}`:`${r},${i}`}}clone(){return new Nn(t({geometry:this.geometry,mosaicRule:this.mosaicRule,rasterFunction:this.rasterFunction,rasterFunctions:this.rasterFunctions,pixelSize:this.pixelSize,returnGeometry:this.returnGeometry,returnCatalogItems:this.returnCatalogItems,returnPixelValues:this.returnPixelValues,maxItemCount:this.maxItemCount,processAsMultidimensional:this.processAsMultidimensional,raster:this.raster,viewId:this.viewId,timeExtent:this.timeExtent}))}};a([b({types:C,json:{write:!0}})],K.prototype,`geometry`,void 0),a([O(`geometry`)],K.prototype,`writeGeometry`,null),a([b({type:M,json:{write:!0}})],K.prototype,`mosaicRule`,null),a([O(`mosaicRule`)],K.prototype,`writeMosaicRule`,null),a([b({type:N,json:{write:!0,name:`renderingRule`}})],K.prototype,`rasterFunction`,null),a([O(`rasterFunction`)],K.prototype,`writeRasterFunction`,null),a([b({type:[N],json:{write:!0,name:`renderingRules`}})],K.prototype,`rasterFunctions`,void 0),a([O(`rasterFunctions`)],K.prototype,`writeRasterFunctions`,null),a([b({type:r,json:{write:!0}})],K.prototype,`pixelSize`,void 0),a([O(`pixelSize`)],K.prototype,`writePixelSize`,null),a([b({type:Boolean,json:{write:!0}})],K.prototype,`returnGeometry`,void 0),a([b({type:Boolean,json:{write:!0}})],K.prototype,`returnCatalogItems`,void 0),a([b({type:Boolean,json:{write:!0}})],K.prototype,`returnPixelValues`,void 0),a([b({type:Number,json:{write:!0}})],K.prototype,`maxItemCount`,void 0),a([b({type:ie,json:{write:{target:`time`}}})],K.prototype,`timeExtent`,void 0),a([O(`timeExtent`)],K.prototype,`writeTimeExtent`,null),a([b({json:{write:!0}})],K.prototype,`raster`,void 0),a([b({json:{write:!0}})],K.prototype,`viewId`,void 0),a([b({type:Boolean,json:{write:!0}})],K.prototype,`processAsMultidimensional`,void 0),K=Nn=a([D(`esri.rest.support.ImageIdentifyParameters`)],K);var q=class extends k{constructor(){super(...arguments),this.catalogItemVisibilities=null,this.catalogItems=null,this.location=null,this.name=null,this.objectId=null,this.processedValues=null,this.properties=null,this.value=null}};a([b({json:{write:!0}})],q.prototype,`catalogItemVisibilities`,void 0),a([b({type:se,json:{write:!0}})],q.prototype,`catalogItems`,void 0),a([b({type:r,json:{write:!0}})],q.prototype,`location`,void 0),a([b({json:{write:!0}})],q.prototype,`name`,void 0),a([b({json:{write:!0}})],q.prototype,`objectId`,void 0),a([b({json:{write:!0}})],q.prototype,`processedValues`,void 0),a([b({json:{write:!0}})],q.prototype,`properties`,void 0),a([b({json:{write:!0}})],q.prototype,`value`,void 0),q=a([D(`esri.rest.support.ImageIdentifyResult`)],q);var Pn,Fn=Pn=class extends k{constructor(e){super(e),this.geometries=null,this.rasterId=null}writeGeometry(e,t,n){t.geometries={geometryType:`esriGeometryPoint`,geometries:e.map(e=>e.toJSON())}}clone(){return new Pn({geometries:this.geometries?.map(e=>e.clone())??[],rasterId:this.rasterId})}};a([b({type:[r],json:{write:!0}})],Fn.prototype,`geometries`,void 0),a([O(`geometries`)],Fn.prototype,`writeGeometry`,null),a([b({type:Pe,json:{write:!0}})],Fn.prototype,`rasterId`,void 0),Fn=Pn=a([D(`esri.rest.support.ImagePixelLocationParameters`)],Fn);var In=class extends k{constructor(){super(...arguments),this.geometries=null}};a([b({json:{write:!0}})],In.prototype,`geometries`,void 0),In=a([D(`esri.rest.support.ImagePixelLocationResult`)],In);var Ln,Rn=Ln=class extends B{constructor(e){super(e),this.type=`point`,this.geometry=null,this.is3D=!1}writeGeometry(t,n,r){t!=null&&(n.geometryType=e(t),n[r]=t.toJSON())}get measureOperation(){let{is3D:e,geometry:t}=this;return t.type===`point`?e?`point-3D`:`point`:e?`centroid-3D`:`centroid`}clone(){return new Ln(t({geometry:this.geometry,is3D:this.is3D,mosaicRule:this.mosaicRule,pixelSize:this.pixelSize,raster:this.raster}))}};a([b({types:C,json:{name:`fromGeometry`,read:v}})],Rn.prototype,`geometry`,void 0),a([O(`geometry`)],Rn.prototype,`writeGeometry`,null),a([b({type:R.apiValues,json:{read:R.read,write:R.write}})],Rn.prototype,`measureOperation`,null),a([b({json:{read:!0}})],Rn.prototype,`is3D`,void 0),Rn=Ln=a([D(`esri.rest.support.ImagePointParameters`)],Rn);var zn=class extends xn{constructor(){super(...arguments),this.point=null}};a([b({type:r,json:{name:`point.value`,read:!0,write:!0}})],zn.prototype,`point`,void 0),zn=a([D(`esri.rest.support.ImagePointResult`)],zn);var Bn=class extends j(k){constructor(e){super(e),this.geometries=[],this.rasterIds=null,this.outSpatialReference=null}writeGeometries(t,n,r){n.geometries=t?.length?{geometryType:e(t[0]),geometries:t.map(e=>({...e.toJSON(),spatialReference:void 0}))}:null}};a([b({types:[C]})],Bn.prototype,`geometries`,void 0),a([O(`geometries`)],Bn.prototype,`writeGeometries`,null),a([b({type:[Pe],json:{write:!0}})],Bn.prototype,`rasterIds`,void 0),a([b({type:w,json:{name:`outSR`,write:!0}})],Bn.prototype,`outSpatialReference`,void 0),Bn=a([D(`esri.rest.support.ImageToMapMultirayParameters`)],Bn);var J=class extends j(k){constructor(e){super(e),this.geometry=null,this.rasterId=null,this.outSpatialReference=null,this.depthOffset=0,this.adjust=!1}writeGeometry(t,n,r){t!=null&&(n.geometryType=e(t),n[r]={...t.toJSON(),spatialReference:void 0})}};a([b({types:C,json:{read:v,write:!0}})],J.prototype,`geometry`,void 0),a([O(`geometry`)],J.prototype,`writeGeometry`,null),a([b({json:{write:!0}})],J.prototype,`rasterId`,void 0),a([b({type:w,json:{name:`outSR`,write:!0}})],J.prototype,`outSpatialReference`,void 0),a([b({json:{name:`options.DOff`,write:!0}})],J.prototype,`depthOffset`,void 0),a([b({json:{name:`options.Adjust`,write:!0}})],J.prototype,`adjust`,void 0),J=a([D(`esri.rest.support.ImageToMapParameters`)],J);var Vn=class extends j(k){constructor(e){super(e),this.referenceUri=null,this.rasterId=null}};a([b({type:String,json:{name:`uri`,write:!0}})],Vn.prototype,`referenceUri`,void 0),a([b({type:Number,json:{write:!0}})],Vn.prototype,`rasterId`,void 0),Vn=a([D(`esri.rest.support.ImageUrlParameters`)],Vn);var Hn=class extends k{constructor(){super(...arguments),this.url=null}};a([b({json:{name:`imageURL`,write:!0}})],Hn.prototype,`url`,void 0),Hn=a([D(`esri.rest.support.ImageUrlResult`)],Hn);var Un=new ye({0:`constant`,1:`plane`,2:`minimum`,3:`maximum`,4:`average`},{useNumericKeys:!0}),Y=class extends j(k){constructor(){super(...arguments),this.geometries=[],this.mosaicRule=null,this.pixelSize=null,this.constantZ=null,this.baseType=`plane`}writeGeometries(t,n,r){t?.length&&(n.geometryType=e(t[0]),n.geometries=t.map(e=>e.toJSON()))}};a([b({types:[C]})],Y.prototype,`geometries`,void 0),a([O(`geometries`)],Y.prototype,`writeGeometries`,null),a([b({type:M,json:{write:!0}})],Y.prototype,`mosaicRule`,void 0),a([b({type:r,json:{write:!0}})],Y.prototype,`pixelSize`,void 0),a([b({json:{write:!0}})],Y.prototype,`constantZ`,void 0),a([b({type:Un.apiValues,json:{read:Un.read,write:Un.write}})],Y.prototype,`baseType`,void 0),Y=a([D(`esri.rest.support.ImageVolumeParameters`)],Y);var X=class extends k{constructor(){super(...arguments),this.area=null,this.cut=null,this.fill=null,this.maxZ=null,this.minZ=null,this.meanZ=null,this.cutCellCount=null,this.fillCellCount=null}};a([b({json:{write:!0}})],X.prototype,`area`,void 0),a([b({json:{write:!0}})],X.prototype,`cut`,void 0),a([b({json:{write:!0}})],X.prototype,`fill`,void 0),a([b({json:{name:`maxz`,write:!0}})],X.prototype,`maxZ`,void 0),a([b({json:{name:`minz`,write:!0}})],X.prototype,`minZ`,void 0),a([b({json:{name:`meanz`,write:!0}})],X.prototype,`meanZ`,void 0),a([b({json:{write:!0}})],X.prototype,`cutCellCount`,void 0),a([b({json:{write:!0}})],X.prototype,`fillCellCount`,void 0),X=a([D(`esri.rest.support.ImageVolume`)],X);var Wn=X,Gn=class extends k{constructor(){super(...arguments),this.volumes=[]}};a([b({type:[Wn],json:{write:!0}})],Gn.prototype,`volumes`,void 0),Gn=a([D(`esri.rest.support.ImageVolumeResult`)],Gn);var Kn=class extends j(k){constructor(e){super(e),this.geometry=null,this.rasterId=null,this.visibleOnly=!1}writeGeometry(t,n,r){t!=null&&(n.geometryType=e(t),n[r]=JSON.stringify(t))}};a([b({types:C,json:{read:v,write:!0}})],Kn.prototype,`geometry`,void 0),a([O(`geometry`)],Kn.prototype,`writeGeometry`,null),a([b({json:{write:!0}})],Kn.prototype,`rasterId`,void 0),a([b({json:{name:`options.VisibleOnly`,write:!0}})],Kn.prototype,`visibleOnly`,void 0),Kn=a([D(`esri.rest.support.MapToImageParameters`)],Kn);var Z=class extends k{constructor(){super(...arguments),this.geometry=null,this.length=null,this.area=null,this.center=null}readCenter(e,t){return e.spatialReference||(e={...e,spatialReference:t.Shape.spatialReference}),r.fromJSON(e)}};a([b({types:C,json:{name:`Shape`,read:v,write:!0}})],Z.prototype,`geometry`,void 0),a([b({json:{name:`Length`,write:!0}})],Z.prototype,`length`,void 0),a([b({json:{name:`Area`,write:!0}})],Z.prototype,`area`,void 0),a([b({type:r,json:{name:`Center`,write:!0}})],Z.prototype,`center`,void 0),a([f(`center`)],Z.prototype,`readCenter`,null),Z=a([D(`esri.rest.support.MeasureAreaFromImageResult`)],Z);var qn,Jn=qn=class extends k{constructor(e){super(e),this.geometry=null,this.rasterId=void 0}writeGeometry(t,n,r){t!=null&&(n.geometryType=e(t),n[r]={...t.toJSON(),spatialReference:void 0})}clone(){let e=t({geometry:this.geometry,rasterId:this.rasterId});return new qn(e)}};a([b({types:C,json:{name:`fromGeometry`,read:v,write:!0}})],Jn.prototype,`geometry`,void 0),a([O(`geometry`)],Jn.prototype,`writeGeometry`,null),a([b({json:{write:!0}})],Jn.prototype,`rasterId`,void 0),Jn=qn=a([D(`esri.rest.support.MeasureFromImageParameters`)],Jn);var Yn=class extends k{constructor(){super(...arguments),this.geometry=null,this.length=null}};a([b({types:C,json:{name:`Shape`,read:v,write:!0}})],Yn.prototype,`geometry`,void 0),a([b({json:{name:`Length`,write:!0}})],Yn.prototype,`length`,void 0),Yn=a([D(`esri.rest.support.MeasureLengthFromImageResult`)],Yn);function Xn(e){let t=e?.time;if(t&&(t.start!=null||t.end!=null)){let n=[];t.start!=null&&n.push(t.start),t.end==null||n.includes(t.end)||n.push(t.end),e.time=n.join(`,`)}}async function Zn(e,t,n){t=m(ct,t);let r=A(e),a=t.geometry?[t.geometry]:[],o=await u(a),s=t.toJSON();Xn(s);let c=o?.[0];c!=null&&(s.geometry=Q(c));let l=T({...r.query,f:`json`,...s});return i(l,n)}async function Qn(e,t,n){let r=(t=m(Y,t)).toJSON();r.geometries=JSON.stringify(r.geometries);let a=A(e),o=T({...a.query,f:`json`,...r}),s=i(o,n),{data:c}=await S(`${a.path}/calculateVolume`,s);return Gn.fromJSON({volumes:c.results})}async function $n(e,t,n){let r=(t=m(hn,t)).toJSON();r.angleName!=null&&(r.angleName=r.angleName.join(`,`)),t?.point?.spatialReference?.imageCoordinateSystem&&(r.point.spatialReference=pr(t.point.spatialReference)),t?.spatialReference?.imageCoordinateSystem&&(r.spatialReference=mr(t.spatialReference));let a=A(e),o=T({...a.query,f:`json`,...r}),s=i(o,n),{data:c}=await S(`${a.path}/computeAngles`,s);return c.spatialReference=c.spatialReference?c.spatialReference.geodataXform==null?w.fromJSON(c.spatialReference):new w({wkid:0,imageCoordinateSystem:c.spatialReference}):null,c.north===`NaN`&&(c.north=null),c.up===`NaN`&&(c.up=null),new gn(c)}async function er(e,t,n){let r=(t=m(Fn,t)).toJSON(),{geometries:a}=t;if(a)for(let e=0;e<a.length;e++)a[e].spatialReference?.imageCoordinateSystem&&(r.geometries.geometries[e].spatialReference=pr(a[e].spatialReference));let o=A(e),s=T({...o.query,f:`json`,...r}),c=i(s,n),{data:l}=await S(`${o.path}/computePixelLocation`,c);return In.fromJSON(l)}async function tr(e,t,n){let r=await Zn(e,t,n),i=A(e),{data:a}=await S(`${i.path}/computeStatisticsHistograms`,r),{statistics:o}=a;return o?.length&&o.forEach(e=>{e.avg=e.mean,e.stddev=e.standardDeviation}),{statistics:o,histograms:a.histograms}}async function nr(e,t,n){let r=await Zn(e,t,n),i=A(e),{data:a}=await S(`${i.path}/computeHistograms`,r);return{histograms:a.histograms}}async function rr(e,t,n){let r=(t=m(ft,t)).toJSON();Xn(r),r.outFields?.length&&(r.outFields=r.outFields.join(`,`));let a=(await u(t.geometry))?.[0];a!=null&&(r.geometry=Q(a));let o=A(e),s=T({...o.query,f:`json`,...r}),c=i(s,n),{data:l}=await S(`${o.path}/getSamples`,c),d=l.samples.map(e=>{let t=e.value===`NaN`||e.value===``?null:e.value.split(` `).map(e=>Number(e));return{...e,pixelValue:t}});return ht.fromJSON({samples:d})}async function ir(e,t,n){t=m(K,t);let r=A(e),a=t.geometry?[t.geometry]:[];return u(a).then(e=>{let a=t.toJSON(),o=e?.[0];o!=null&&(a.geometry=JSON.stringify(Q(o)));let s=T({...r.query,f:`json`,...a}),c=i(s,n);return S(r.path+`/identify`,c)}).then(e=>q.fromJSON(e.data))}async function ar(e,t,n){t=m(G,t);let r=await lr(e,t,[t.fromGeometry,t.toGeometry],n);return Mn.fromJSON(r)}async function or(e,t,n){t=m(V,t);let r=await lr(e,t,[t.geometry],n);return Sn.fromJSON(r)}async function sr(e,t,n){t=m(Rn,t);let r=await lr(e,t,[t.geometry],n);return zn.fromJSON(r)}async function cr(e,t,n){t=m(H,t);let r=await lr(e,t,[t.fromGeometry,t.toGeometry],n);return En.fromJSON(r)}async function lr(e,t,n,r){let a=A(e),o=await u(n),s=t.toJSON();o[0]!=null&&(s.fromGeometry=JSON.stringify(Q(o[0]))),o[1]!=null&&(s.toGeometry=JSON.stringify(Q(o[1])));let c=T({...a.query,f:`json`,...s}),l=i(c,r),{data:d}=await S(a.path+`/measure`,l);return d}async function ur(e,t,n){let r=await fr(e,t,n);return Yn.fromJSON(r)}async function dr(e,t,n){let r=await fr(e,t,n);return Z.fromJSON(r)}async function fr(e,t,n){t=m(Jn,t);let r=A(e),a=t.toJSON(),o=T({...r.query,f:`json`,...a}),s=i(o,n),{data:c}=await S(r.path+`/measureFromImage`,s);return c}function Q(e){let t=e.toJSON();return e.spatialReference?.imageCoordinateSystem&&(t.spatialReference=pr(e.spatialReference)),t}function pr(e){let{imageCoordinateSystem:t}=e;if(t){let{id:e,referenceServiceName:n}=t;return e==null?{ics:t}:n?{icsid:e,icsns:n}:{icsid:e}}return e.toJSON()}function mr(e,t){if(!e.imageCoordinateSystem)return ae(e);let n=pr(e),{icsid:r,icsns:i}=n;return r==null||i!=null&&!t?.toLowerCase().includes(`/`+i.toLowerCase()+`/`)?JSON.stringify(n):`0:${r}`}async function hr(e,t,n){t=m(Cn,t);let r=A(e),a=t.toJSON();t.outSpatialReference&&(a.outSR=mr(t.outSpatialReference));let o=T({...r.query,f:`json`,...a}),s=i(o,n),{data:c}=await S(r.path+`/queryBoundary`,s);return wn.fromJSON(c)}async function gr(e,t,n){let r=(t=m(U,t)).toJSON();Xn(r),r.objectIds?.length&&(r.objectIds=r.objectIds.join(`,`)),r.geometry||r.objectIds||r.time||r.where||(r.where=`1=1`);let a=(await u(t.geometry))?.[0];a!=null&&(r.geometry=Q(a));let o=a?.spatialReference??t.geometry?.spatialReference;o&&(r.inSR=mr(o));let s=A(e),c=T({...s.query,f:`json`,...r}),l=i(c,n),{data:d}=await S(`${s.path}/queryGPSInfo`,l);return An.fromJSON(d)}async function _r(e,t,n){let r=(t=m(J,t)).toJSON();t.geometry.spatialReference.imageCoordinateSystem&&(r.geometry=Q(t.geometry)),t.depthOffset&&t.adjust||delete r.options;let a=A(e),o=T({...a.query,f:`json`,...r}),s=i(o,n),{data:c}=await S(`${a.path}/imageToMap`,s);return v(c)}async function vr(e,t,n){let r=(t=m(Bn,t)).toJSON();t.rasterIds?.length&&(r.rasterIds=t.rasterIds.join(`,`));let a=A(e),o=T({...a.query,f:`json`,...r}),s=i(o,n),{data:c}=await S(`${a.path}/imageToMapMultiray`,s);return v(c)}async function yr(e,t,n){let r=(t=m(Kn,t)).toJSON(),a=(await u(t.geometry))?.[0];a!=null&&(r.geometry=Q(a)),t.visibleOnly||delete r.options;let o=a?.spatialReference??t.geometry?.spatialReference;o&&(r.inSR=mr(o));let s=A(e),c=T({...s.query,f:`json`,...r}),l=i(c,n),{data:d}=await S(`${s.path}/mapToImage`,l);return v(d)}async function br(e,t,n){let r=(t=m(Vn,t)).toJSON(),a=A(e),o=T({...a.query,f:`json`,...r}),s=i(o,n),{data:c}=await S(`${a.path}/getImageUrl`,s);return Hn.fromJSON(c)}async function xr(e,t,n){let r=(t=m(I,t)).toJSON(),a=await u([t.fromGeometry,t.toGeometry]);a[0]!=null&&(r.fromGeometry=Q(a[0]),a[0].spatialReference&&(r.inSR=mr(a[0].spatialReference))),a[1]!=null&&(r.toGeometry=Q(a[1])),t.objectIds?.length&&(r.objectIds=r.objectIds.join(`,`));let o=A(e),s=T({...o.query,f:`json`,...r}),c=i(s,n),{data:l}=await S(`${o.path}/find`,c);return pn.fromJSON(l)}async function Sr(e,t,n){let a=A(e),o=T({...a?.query,f:`json`}),s=i(o,n),c=`${a?.path}/${t}/info`,l=S(`${c}`,s),u=S(`${c}/keyProperties`,s),d=await Promise.allSettled([l,u]),f=d[0].status===`fulfilled`?d[0].value.data:null,p=d[1].status===`fulfilled`?d[1].value.data:null,m=null;f.statistics?.length&&(m=f.statistics.map(e=>({min:e[0],max:e[1],avg:e[2],stddev:e[3]})));let h=fe.fromJSON(f.extent),g=Math.ceil(h.width/f.pixelSizeX-.1),_=Math.ceil(h.height/f.pixelSizeY-.1),v=h.spatialReference,y=new r({x:f.pixelSizeX,y:f.pixelSizeY,spatialReference:v}),ee=f.histograms?.length?f.histograms:null,te=new ot({origin:f.origin,blockWidth:f.blockWidth,blockHeight:f.blockHeight,firstPyramidLevel:f.firstPyramidLevel,maximumPyramidLevel:f.maxPyramidLevel});return new et({width:g,height:_,bandCount:f.bandCount,extent:h,spatialReference:v,pixelSize:y,pixelType:f.pixelType.toLowerCase(),statistics:m,histograms:ee,keyProperties:p,storageInfo:te})}var Cr=new Set([`png`,`png8`,`png24`,`png32`,`jpg`,`bmp`,`gif`,`jpgpng`,`lerc`,`tiff`]),wr=l(oe,{min:0,max:255});function Tr(e){let t=JSON.stringify(e),n=t.includes(`"rasterFunctionDefinition":{`),r=(n?t.match(/"type":"(.*?FunctionArguments")/gi):t.match(/"rasterFunction":"(.*?")/gi))?.map(e=>n?e.slice(8,-18):e.slice(18,-1));return r?r.join(`/`):null}var Er=e=>{let r=e,i=class extends r{constructor(){super(...arguments),this._functionRasterInfos={},this._serviceSupportsMosaicRule=null,this.adjustAspectRatio=null,this.bandIds=void 0,this.capabilities=null,this.compressionQuality=void 0,this.compressionTolerance=.01,this.copyright=null,this.defaultMosaicRule=null,this.definitionExpression=null,this.exportImageServiceParameters=null,this.rasterInfo=null,this.fields=null,this.fullExtent=null,this.hasMultidimensions=!1,this.imageMaxHeight=4100,this.imageMaxWidth=4100,this.interpolation=void 0,this.minScale=0,this.maxScale=0,this.multidimensionalInfo=null,this.multidimensionalSubset=null,this.noData=null,this.noDataInterpretation=void 0,this.objectIdField=null,this.geometryType=`polygon`,this.typeIdField=null,this.types=[],this.pixelFilter=null,this.raster=void 0,this.sourceType=null,this.viewId=void 0,this.symbolizer=null,this.rasterFunctionInfos=null,this.serviceDataType=null,this.spatialReference=null,this.pixelType=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.url=null,this.version=void 0}initialize(){this._set(`exportImageServiceParameters`,new F({layer:this}))}readServiceSupportsMosaicRule(e,t){return this._isMosaicRuleSupported(t)}get _rasterFunctionNamesIndex(){let e=new Map;return!this.rasterFunctionInfos||this.rasterFunctionInfos!=null&&this.rasterFunctionInfos.length<1||this.rasterFunctionInfos!=null&&this.rasterFunctionInfos.forEach(t=>{e.set(t.name.toLowerCase().replaceAll(/ /gi,`_`),t.name)}),e}readBandIds(e,t){if(Array.isArray(e)&&e.length>0&&e.every(e=>typeof e==`number`))return e}readCapabilities(e,t){return this._readCapabilities(t)}writeCompressionQuality(e,t,n){e!=null&&this.format!==`lerc`&&(t[n]=e)}writeCompressionTolerance(e,t,n){this.format===`lerc`&&e!=null&&(t[n]=e)}readDefaultMosaicRule(e,t){return this._serviceSupportsMosaicRule?M.fromJSON(t):null}get fieldsIndex(){return this.fields?new me(this.fields):null}set format(e){e&&Cr.has(e.toLowerCase())&&this._set(`format`,e.toLowerCase())}readFormat(e,t){return t.serviceDataType===`esriImageServiceDataTypeVector-UV`||t.serviceDataType===`esriImageServiceDataTypeVector-MagDir`||this.pixelFilter!=null?`lerc`:`jpgpng`}readMinScale(e,t){return t.minLOD!=null&&t.maxLOD!=null?e:0}readMaxScale(e,t){return t.minLOD!=null&&t.maxLOD!=null?e:0}set mosaicRule(e){let t=e;t?.mosaicMethod&&(t=M.fromJSON({...t.toJSON(),mosaicMethod:t.mosaicMethod,mosaicOperation:t.mosaicOperation})),this._set(`mosaicRule`,t)}readMosaicRule(e,t){let n=e||t.mosaicRule;return n?M.fromJSON(n):this._isMosaicRuleSupported(t)?M.fromJSON(t):null}writeMosaicRule(e,t,n){let{mosaicRule:r}=this;this._isValidCustomizedMosaicRule(r)&&(t[n]=r.toJSON())}writeNoData(e,t,n){e!=null&&typeof e==`number`&&(t[n]=wr(e))}readObjectIdField(e,t){return e||=t.fields.find(e=>e.type===`esriFieldTypeOID`||e.type===`oid`)?.name,e}get parsedUrl(){return he(this.url)}readSourceType(e,t){return this._isMosaicDataset(t)?`mosaic-dataset`:`raster-dataset`}get renderer(){let{activePresetRendererName:e,presetRenderers:t}=this;return e?(t?.find(({name:t})=>t===e))?.renderer.clone():this.internalRenderer}set renderer(e){this.activePresetRendererName=null,this.internalRenderer=e}set internalRenderer(e){this.loaded&&(e=this._configRenderer(e)),this._set(`internalRenderer`,e)}readRenderer(e,t,n){let r=t?.layerDefinition?.drawingInfo?.renderer,i=gt(r,n);return i==null?null:(i.type===`vector-field`&&t.symbolTileSize&&!r.symbolTileSize&&(i.symbolTileSize=t.symbolTileSize),qt(i)||Ae.getLogger(this).warn(`ArcGISImageService`,`Imagery layer doesn't support given renderer type.`),i)}writeRenderer(e,t,n){t.layerDefinition=t.layerDefinition||{},t.layerDefinition.drawingInfo=t.layerDefinition.drawingInfo||{},t.layerDefinition.drawingInfo.renderer=e.toJSON(),e.type===`vector-field`&&(t.symbolTileSize=e.symbolTileSize)}get rasterFields(){let e=this.fields?.map(e=>e.clone())??[];e.push(wt()),this.sourceType===`mosaic-dataset`&&this.fields?.length&&e.push(Dt()),this.version>=10.4&&this.rasterFunctionInfos!=null&&this.rasterFunctionInfos.some(({name:e})=>e.toLowerCase()===`none`)&&e.push(St()),this.rasterFunctionInfos!=null&&this.rasterFunctionInfos.filter(({name:e})=>e.toLowerCase()!==`none`).forEach(({name:t})=>e.push(Mt(t)));let{rasterInfo:t}=this;if(this._isVectorDataSet()){let n=t?.multidimensionalInfo?.variables[0].unit?.trim(),r=kt(n),i=Nt();e.push(r,i)}if(t?.multidimensionalInfo&&this.sourceType===`raster-dataset`){let n=Tt(t.multidimensionalInfo);e.push(...n)}let n=t?.attributeTable;if(n!=null){let t=At(n);e.push(...t)}return e}set rasterFunction(e){let t=e;t?.rasterFunction&&(t=N.fromJSON({...t.toJSON(),rasterFunction:t.rasterFunction,rasterFunctionArguments:t.rasterFunctionArguments})),this._set(`rasterFunction`,t)}readRasterFunction(e,t){let n=t.rasterFunctionInfos;return t.renderingRule||n?.length&&n[0].name!==`None`?this._isRFTJson(t.renderingRule)?N.fromJSON({rasterFunctionDefinition:t.renderingRule}):N.fromJSON(t.renderingRule||{rasterFunctionInfos:t.rasterFunctionInfos}):null}readSpatialReference(e,t){let n=e||t.extent.spatialReference;return n?w.fromJSON(n):null}writePixelType(e,t,n){this.serviceRasterInfo!=null&&this.pixelType===this.serviceRasterInfo.pixelType||(t[n]=it.toJSON(e))}readVersion(e,t){let n=t.currentVersion;return n||=t.hasOwnProperty(`fields`)||t.hasOwnProperty(`timeInfo`)?10:9.3,n}applyFilter(e){let t=e;return this.pixelFilter&&(t=this._clonePixelData(e),this.pixelFilter(t)),t}async applyRenderer(e,t){let n=e,{renderer:r,symbolizer:i,pixelFilter:a}=this,{isRawData:o}=e;if(o&&this.format!==`lerc`&&(r??=pt(this.rasterInfo,{bandIds:this.bandIds,variableName:this.rasterFunction?null:this.mosaicRule?.multidimensionalDefinition?.[0].variableName}),i||=(this.symbolizer=new at({rendererJSON:r.toJSON(),rasterInfo:this.rasterInfo}),this.symbolizer)),(o||!this._isPicture())&&r&&i&&!a){await this._updateSymbolizer(i,r);let{bandIds:a}=this;n=await this._symbolize({pixelData:e,bandIds:a,symbolizer:i},t)}return n}async highlightPixels(e,t){let n=e.highlightOptions.map(e=>{let t={...e},{bandId:n}=t;if(n==null)t.bandId=0;else{let e=this.bandIds?.length?this.bandIds.indexOf(n):n;if(e<0||e>2)return;t.bandId=e}return t}).filter(e=>e!=null),r=this._rasterJobHandler;r?await r.highlightPixels({...e,highlightOptions:n},t):Ft(e.pixelBlock,e.renderedPixelBlock,n)}destroy(){this._shutdownJobHandler()}async calculateVolume(e,n){if(!(await this._fetchCapabilities(n?.signal)).operations.supportsCalculateVolume)throw new E(`imagery-layer:compute-pixel-space-locations`,`this operation is not supported on the input image service`);return e=t(e),this.mosaicRule&&e.mosaicRule==null&&(e.mosaicRule=this.mosaicRule),Qn(this.url,e,this._getRequestOptions(n))}async computeAngles(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsComputeAngles)throw new E(`imagery-layer:compute-angles`,`this operation is not supported on the input image service`);return $n(this.url,e,this._getRequestOptions(t))}async computePixelSpaceLocations(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsComputePixelLocation)throw new E(`imagery-layer:compute-pixel-space-locations`,`this operation is not supported on the input image service`);return er(this.url,e,this._getRequestOptions(t))}async computeHistograms(e,n){if(!(await this._fetchCapabilities(n?.signal)).operations.supportsComputeHistograms)throw new E(`imagery-layer:compute-histograms`,`this operation is not supported on the input image service`);return e=t(e),this._applyMosaicAndRenderingRules(e),nr(this.url,e,this._getRequestOptions(n))}async computeStatisticsHistograms(e,n){if(!(await this._fetchCapabilities(n?.signal)).operations.supportsComputeStatisticsHistograms)throw new E(`imagery-layer:compute-statistics-histograms`,`this operation is not supported on the input image service`);return e=t(e),this._applyMosaicAndRenderingRules(e),tr(this.url,e,this._getRequestOptions(n))}async measureHeight(e,n){let r=await this._fetchCapabilities(n?.signal);if(!(e.operationType===`base-and-top`?r.mensuration.supportsHeightFromBaseAndTop:e.operationType===`base-and-top-shadow`?r.mensuration.supportsHeightFromBaseAndTopShadow:r.mensuration.supportsHeightFromTopAndTopShadow))throw new E(`imagery-layer:measure-height`,`this operation is not supported on the input image service`);return e=t(e),this._applyMosaicRule(e),ar(this.url,e,this._getRequestOptions(n))}async measureAreaAndPerimeter(e,n){let r=await this._fetchCapabilities(n?.signal);if(!(r.mensuration.supportsAreaAndPerimeter&&(!e.is3D||r.mensuration.supports3D)))throw new E(`imagery-layer:measure-area-and-perimeter`,`this operation is not supported on the input image service`);return e=t(e),this._applyMosaicRule(e),or(this.url,e,this._getRequestOptions(n))}async measureDistanceAndAngle(e,n){let r=await this._fetchCapabilities(n?.signal);if(!(r.mensuration.supportsDistanceAndAngle&&(!e.is3D||r.mensuration.supports3D)))throw new E(`imagery-layer:measure-distance-and-angle`,`this operation is not supported on the input image service`);return e=t(e),this._applyMosaicRule(e),cr(this.url,e,this._getRequestOptions(n))}async measurePointOrCentroid(e,n){let r=await this._fetchCapabilities(n?.signal);if(!(r.mensuration.supportsPointOrCentroid&&(!e.is3D||r.mensuration.supports3D)))throw new E(`imagery-layer:measure-point-or-centroid`,`this operation is not supported on the input image service`);return e=t(e),this._applyMosaicRule(e),sr(this.url,e,this._getRequestOptions(n))}async measureLengthFromImage(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsMeasureFromImage)throw new E(`imagery-layer:measure-length-from-image`,`this operation is not supported on the input image service`);if(e.geometry.type!==`polyline`)throw new E(`imagery-layer:measure-length-from-image`,`this input geometry must be a polyline`);return ur(this.url,e,this._getRequestOptions(t))}async measureAreaFromImage(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsMeasureFromImage)throw new E(`imagery-layer:measure-area-from-image`,`this operation is not supported on the input image service`);if(e.geometry.type!==`polygon`)throw new E(`imagery-layer:measure-area-from-image`,`this input geometry must be a polygon`);return dr(this.url,e,this._getRequestOptions(t))}getField(e){let{fieldsIndex:t}=this;return t?.get(e)}getFieldDomain(e,t){let n=this.getField(e);return n?n.domain:null}fetchImage(e,t,n,r={}){if(Me(Ae.getLogger(this),"`ImageryLayer.fetchImage` is deprecated in favor of 'ImageryLayer.fetchPixels'.",{replacement:`ImageryLayer.fetchPixels`,version:`4.33`,warnOnce:!0}),e==null||t==null||n==null)throw new E(`imagery-layer:fetch-image`,`Insufficient parameters for requesting an image. A valid extent, width and height values are required.`);return this.internalFetchImage(e,t,n,r)}async internalFetchImage(e,t,n,r={}){await this._updateCurrentRasterInfo();let{exportImageServiceParameters:i}=this,a=!1;r.requestRawData&&(await this._initJobHandler(),i.requestRawData||this.format===`lerc`||(a=!0,i.requestRawData=!0));let o=this.getExportImageServiceParameters(e,t,n,r.timeExtent);if(a&&(i.requestRawData=!1),o==null){if(r.requestAsImageElement&&this._canRequestImageElement(this.format)){let e=document.createElement(`canvas`);return e.width=t,e.height=n,r.returnImageBitmap?{imageBitmap:await Fe(e,`${s(this.parsedUrl)}/exportImage`,r.signal)}:{imageOrCanvasElement:e}}let{bandIds:i,rasterInfo:a}=this,o=(i?.length||a.bandCount)??0,c=t*n,l=a.pixelType,u=[];for(let e=0;e<o;e++)u.push(xt.createEmptyBand(l,c));return{pixelData:{pixelBlock:new xt({width:t,height:n,pixels:u,mask:new Uint8Array(c),pixelType:l}),extent:e}}}let c=!!r.requestAsImageElement&&!this.pixelFilter,l=c&&!!r.returnImageBitmap,u={imageServiceParameters:o,imageProps:{extent:e,width:t,height:n,format:this.format},requestAsImageElement:c,returnImageBitmap:l,signal:r.signal};return this._requestArrayBuffer(u)}async fetchPixels(e,t,n,r={}){await this._initJobHandler(),r.applyRendering&&this._updateCurrentRasterInfo();let i=r.applyRendering?void 0:new F({layer:this,requestRawData:!0,interpolation:r.interpolation??`nearest`,bandIds:r.bandIds??[]}),a=this.getExportImageServiceParameters(e,t,n,r.timeExtent,i);if(a==null)return{extent:e,pixelBlock:null};delete a.pixelType,r.bandIds||delete a.bandIds,delete a.compressionQuality;let o={imageServiceParameters:a,imageProps:{extent:e,width:t,height:n,format:this.format},requestAsImageElement:!1,returnImageBitmap:!1,signal:r.signal},{pixelData:s}=await this._requestArrayBuffer(o);return s??{extent:e,pixelBlock:null}}fetchKeyProperties(e){return S(s(this.parsedUrl)+`/keyProperties`,{query:this._getQueryParams({renderingRule:this.version>=10.3?e?.rasterFunction:null})}).then(e=>e.data)}fetchRasterAttributeTable(e){return this.version<10.1?Promise.reject(new E(`#fetchRasterAttributeTable()`,`Failed to get rasterAttributeTable`)):S(s(this.parsedUrl)+`/rasterAttributeTable`,{query:this._getQueryParams({renderingRule:this.version>=10.3?e?.rasterFunction:null})}).then(e=>se.fromJSON(e.data))}getCatalogItemRasterInfo(e,t){let n={...t,query:this._getQueryParams()};return Sr(s(this.parsedUrl),e,n)}async getCatalogItemICSInfo(e,t){let{data:n}=await S(s(this.parsedUrl)+`/`+e+`/info/ics`,{query:this._getQueryParams(),...t}),r=n?.ics;if(!r)return;let i=null;try{i=(await S(s(this.parsedUrl)+`/`+e+`/info`,{query:this._getQueryParams(),...t})).data.extent}catch{}if(!i?.spatialReference)return{ics:r,icsToPixelTransform:null,icsExtent:null,northDirection:null};let a=this.version>=10.7?S(s(this.parsedUrl)+`/`+e+`/info/icstopixel`,{query:this._getQueryParams(),...t}).then(e=>e.data).catch(()=>({})):{},o=i.spatialReference,c={geometries:JSON.stringify({geometryType:`esriGeometryEnvelope`,geometries:[i]}),inSR:ae(o),outSR:`0:`+e},l=S(s(this.parsedUrl)+`/project`,{query:this._getQueryParams(c),...t}).then(e=>e.data).catch(()=>({})),u=(i.xmin+i.xmax)/2,d=(i.ymax-i.ymin)/6,f=i.ymin+d,p=[];for(let e=0;e<5;e++)p.push({x:u,y:f+d*e});let m={geometries:JSON.stringify({geometryType:`esriGeometryPoint`,geometries:p}),inSR:ae(o),outSR:`0:`+e},h=S(s(this.parsedUrl)+`/project`,{query:this._getQueryParams(m),...t}).then(e=>e.data).catch(()=>({})),g=await Promise.all([a,l,h]),_=g[0].ipxf;if(_==null){let e=r.geodataXform?.xf_0;e?.name?.toLowerCase()===`topup`&&e?.coefficients?.length===6&&(_={affine:{name:`ics [sensor: Frame] to pixel (column, row) transformation`,coefficients:e.coefficients,cellsizeRatio:0,type:`GeometricXform`}})}let v=fe.fromJSON(g[1]?.geometries?.[0]);v&&(v.spatialReference=new w({wkid:0,imageCoordinateSystem:r}));let y=g[2].geometries?g[2].geometries.filter(e=>e?.x!=null&&e.y!=null&&e.x!==`NaN`&&e.y!==`NaN`):[],ee=y.length;if(ee<3)return{ics:r,icsToPixelTransform:_,icsExtent:v,northDirection:null};let te=0,ne=0,b=0,re=0;for(let e=0;e<ee;e++)te+=y[e].x,ne+=y[e].y,b+=y[e].x*y[e].x,re+=y[e].x*y[e].y;let x=(ee*re-te*ne)/(ee*b-te*te),ie=0,oe=y[4].x>y[0].x,se=y[4].y>y[0].y;return x===1/0?ie=se?90:270:x===0?ie=oe?0:180:x>0?ie=oe?180*Math.atan(x)/Math.PI:180*Math.atan(x)/Math.PI+180:x<0&&(ie=se?180+180*Math.atan(x)/Math.PI:360+180*Math.atan(x)/Math.PI),{ics:r,icsToPixelTransform:_,icsExtent:v,northDirection:ie}}async generateRasterInfo(e,t){e=m(N,e);let n={...t,query:this._getQueryParams()};if(!e||e.functionName?.toLowerCase()===`none`||this._isVectorFieldResampleFunction(e))return this.serviceRasterInfo??zt(s(this.parsedUrl),this.sourceJSON,n);let r=Tr(e);if(!r)throw new E(`imagery-layer:generate-raster-info`,`the rendering rule is not supported`);if(this._functionRasterInfos[r])return this._functionRasterInfos[r];let i=Lt(s(this.parsedUrl),e,n);this._functionRasterInfos[r]=i;try{return await i}catch(e){throw this._functionRasterInfos[r]=null,e}}getExportImageServiceParameters(e,t,n,r,i){e=e.clone().shiftCentralMeridian();let a=mr(e.spatialReference,s(this.parsedUrl));i??=this.exportImageServiceParameters;let o=i.toJSON(),{bandIds:c,noData:l}=o,{renderingRule:u}=o,d=this.rasterFunction?.rasterFunctionDefinition,f=this.renderer?.type,p=!f||f===`raster-stretch`||f===`raster-colormap`||f===`unique-value`||f===`class-breaks`||f===`raster-shaded-relief`;if(c?.length&&this._hasRasterFunction(this.rasterFunction)&&!d&&p){let e={rasterFunction:`ExtractBand`,rasterFunctionArguments:{BandIds:c}};if(u.rasterFunction===`Stretch`)e.rasterFunctionArguments.Raster=u.rasterFunctionArguments.Raster,u.rasterFunctionArguments.Raster=e;else if(u.rasterFunction===`Colormap`){let t=u.rasterFunctionArguments.Raster;t?.rasterFunction===`Stretch`?(e.rasterFunctionArguments.Raster=t.rasterFunctionArguments.Raster,t.rasterFunctionArguments.Raster=e):(e.rasterFunctionArguments.Raster=t,u.rasterFunctionArguments.Raster=e)}else e.rasterFunctionArguments.Raster=u,u=e;o.bandIds=void 0}else o.bandIds=c?.join(`,`);Array.isArray(l)&&l.length>0&&(o.noData=l.join(`,`));let m=this._processMultidimensionalIntersection(null,r,i.mosaicRule);if(m.isOutSide)return null;o.mosaicRule=m.mosaicRule==null?null:JSON.stringify(m.mosaicRule),r=m.timeExtent,o.renderingRule=this._getRenderingRuleString(N.fromJSON(u));let h={};if(r!=null){let{start:e,end:t}=r.toJSON();e&&t&&e===t?h.time=``+e:e==null&&t==null||(h.time=`${e??`null`},${t??`null`}`)}return{bbox:e.xmin+`,`+e.ymin+`,`+e.xmax+`,`+e.ymax,bboxSR:a,imageSR:a,size:t+`,`+n,...o,...h}}async getSamples(e,n){if(!(await this._fetchCapabilities(n?.signal))?.operations.supportsGetSamples)throw new E(`imagery-layer:get-samples`,`getSamples operation is not supported on the input image service`);e=t(e);let{raster:r}=this;return r&&e.raster==null&&(e.raster=r),rr(this.url,e,this._getRequestOptions(n))}async identify(e,n){if(!(await this._fetchCapabilities(n?.signal)).operations.supportsIdentify)throw new E(`imagery-layer:identify`,`identify operation is not supported on the input image service`);e=t(e),this.version<10.91&&e.geometry?.type===`extent`&&(e.geometry=Se.fromExtent(e.geometry));let r=this._processMultidimensionalIntersection(e.geometry,e.timeExtent,e.mosaicRule||this.mosaicRule);if(r.isOutSide)throw new E(`imagery-layer:identify`,`the request cannot be fulfilled when falling outside of the multidimensional subset`);e.timeExtent=r.timeExtent,e.mosaicRule=r.mosaicRule;let{raster:i,rasterFunction:a}=this;return a&&e.rasterFunction==null&&(e.rasterFunction=a),i&&e.raster==null&&(e.raster=i),ir(this.url,e,this._getRequestOptions(n))}async imageToMap(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsImageToMap)throw new E(`imagery-layer:image-to-map`,`imageToMap operation is not supported on the input image service`);return _r(s(this.parsedUrl),e,this._getRequestOptions(t))}async imageToMapMultiray(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsImageToMapMultiray)throw new E(`imagery-layer:image-to-map-multiray`,`imageToMapMultiray operation is not supported on the input image service`);return vr(s(this.parsedUrl),e,this._getRequestOptions(t))}async mapToImage(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsMapToImage)throw new E(`imagery-layer:map-to-image`,`mapToImage operation is not supported on the input image service`);return yr(s(this.parsedUrl),e,this._getRequestOptions(t))}async findImages(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsFindImages)throw new E(`imagery-layer:find-images`,`findImages operation is not supported on the input image service`);return xr(s(this.parsedUrl),e,this._getRequestOptions(t))}async getImageUrl(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsGetImageUrl)throw new E(`imagery-layer:get-image-url`,`getImageUrl operation is not supported on the input image service`);return br(s(this.parsedUrl),e,this._getRequestOptions(t))}createQuery(){return new o({outFields:[`*`],returnGeometry:!0,where:this.definitionExpression||`1=1`})}async queryBoundary(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsQueryBoundary)throw new E(`imagery-layer:query-boundary`,`queryBoundary operation is not supported on the input image service`);return e??={outSpatialReference:this.spatialReference},hr(s(this.parsedUrl),e,this._getRequestOptions(t))}async queryRasters(e,t){({query:e,requestOptions:t}=await this._prepareForQuery(e,t));let n=await Ve(this.url,e,t),r=this.graphicOrigin;return n.features.forEach(e=>{e.layer=this,e.origin=r}),n}async queryObjectIds(e,t){return{query:e,requestOptions:t}=await this._prepareForQuery(e,t),Be(this.url,e,t)}async queryGPSInfo(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsQueryGPSInfo)throw new E(`imagery-layer:query-gps-info`,`queryGPSInfo operation is not supported on the input image service`);return e??={where:`1=1`},gr(s(this.parsedUrl),e,this._getRequestOptions(t))}async queryRasterCount(e,t){return{query:e,requestOptions:t}=await this._prepareForQuery(e,t),ze(this.url,e,t)}async queryVisibleRasters(e,t){if(!e)throw new E(`imagery-layer: query-visible-rasters`,`missing query parameter`);await this.load();let{pixelSize:n,returnDomainValues:r,returnTopmostRaster:i,showNoDataRecords:a}=t||{pixelSize:null,returnDomainValues:!1,returnTopmostRaster:!1,showNoDataRecords:!1},s=!1,c=null,l=null,u=Ct.servicePixelValue.toLowerCase(),d=this._rasterFunctionNamesIndex;if(e.outFields!=null&&(s=e.outFields.some(e=>!e.toLowerCase().startsWith(u)),this.version>=10.4)){let t=e.outFields.filter(e=>e.toLowerCase().startsWith(u)&&e.length>u.length).map(e=>{let t=e.slice(u.length+1);return[this._updateRenderingRulesFunctionName(t,d),t]});c=t.map(e=>new N({functionName:e[0]})),l=t.map(e=>e[1]);let{rasterFunction:n}=this;c.length===0?n?.functionName?(c.push(n),l.push(n.functionName)):c=null:n?.functionName&&!c.some(e=>e.functionName===n.functionName)&&(c.push(n),l.push(n.functionName))}let f=e.outSpatialReference==null||e.outSpatialReference.equals(this.spatialReference),{multidimensionalSubset:p}=this,m=e.timeExtent||this.timeExtent;if(p){let{isOutside:t,intersection:n}=Ge(p,{geometry:e.geometry,timeExtent:e.timeExtent,multidimensionalDefinition:this.exportImageServiceParameters.mosaicRule?.multidimensionalDefinition});if(t)throw new E(`imagery-layer:query-visible-rasters`,`the request cannot be fulfilled when falling outside of the multidimensional subset`);n?.timeExtent!=null&&(m=n.timeExtent)}let h=this._combineMosaicRuleWithTimeExtent(this.exportImageServiceParameters.mosaicRule,m),g=e.geometry;this.version<10.91&&g?.type===`extent`&&(g=Se.fromExtent(g));let _=this._getQueryParams({geometry:g,timeExtent:m,mosaicRule:h,rasterFunction:this.version<10.4?this.rasterFunction:null,rasterFunctions:c,pixelSize:n,returnCatalogItems:s,returnGeometry:f,raster:this.raster,maxItemCount:i?1:null});delete _.f;let v=new K(_);try{await this._generateRasterInfo(this.rasterFunction);let n=await ir(this.url,v,{signal:t?.signal,query:{...this.customParameters}}),i=e.outFields,c=n.value!=null&&n.value.toLowerCase().includes(`nodata`),u=s&&!f&&n?.catalogItems?.features.length&&(a||!c),d=this.multidimensionalInfo&&this.sourceType===`raster-dataset`?qe({rasterInfo:this.rasterInfo,multidimensionalDefinition:h?.multidimensionalDefinition,timeExtent:m,multidimensionalSubset:this.multidimensionalSubset}):null;if(!u)return this._processVisibleRastersResponse(n,{returnDomainValues:r,templateRRFunctionNames:l,showNoDataRecords:a,templateFields:i,effectiveMultidimensionalDefinition:d});let p=this.objectIdField||`ObjectId`,g=n.catalogItems?.features??[],_=g.map(e=>e.attributes?.[p]),y=new o({objectIds:_,returnGeometry:!0,outSpatialReference:e.outSpatialReference,outFields:[p]}),ee=await this.queryRasters(y);return ee?.features?.length&&ee.features.forEach(t=>{g.forEach(n=>{n.attributes[p]===t.attributes[p]&&t.geometry&&(n.geometry=t.geometry.clone(),e.outSpatialReference!=null&&(n.geometry.spatialReference=e.outSpatialReference))})}),this._processVisibleRastersResponse(n,{returnDomainValues:r,templateRRFunctionNames:l,showNoDataRecords:a,templateFields:i,effectiveMultidimensionalDefinition:d})}catch{throw new E(`imagery-layer:query-visible-rasters`,`encountered error when querying visible rasters`)}}async fetchVariableStatisticsHistograms(e,t){let n=S(s(this.parsedUrl)+`/statistics`,{query:this._getQueryParams({variable:e}),signal:t}).then(e=>e.data?.statistics),r=S(s(this.parsedUrl)+`/histograms`,{query:this._getQueryParams({variable:e}),signal:t}).then(e=>e.data?.histograms),i=await Promise.all([n,r]);return i[0]&&i[0].forEach(e=>{e.avg=e.mean,e.stddev=e.standardDeviation}),{statistics:i[0]||null,histograms:i[1]||null}}getMultidimensionalSubsetVariables(e){let t=e??this.serviceRasterInfo.multidimensionalInfo;return We(this.multidimensionalSubset,t)}async _fetchService(e){await this._fetchServiceInfo(e),this.rasterInfo||=this.serviceRasterInfo;let t=this.sourceJSON,n=this.serviceRasterInfo==null?zt(s(this.parsedUrl),t,{signal:e,query:this._getQueryParams()}).then(e=>(this._set(`serviceRasterInfo`,e),this._set(`multidimensionalInfo`,e.multidimensionalInfo),Rt(e,t),e)):Promise.resolve(this.serviceRasterInfo),r=this._hasRasterFunction(this.rasterFunction)?this._generateRasterInfo(this.rasterFunction,{signal:e}):null,i=this._getRasterFunctionInfos();return Promise.all([n,r,i]).then(e=>{e[1]?this._set(`rasterInfo`,e[1]):this._set(`rasterInfo`,e[0]),e[2]&&this._set(`rasterFunctionInfos`,e[2]),this.internalRenderer&&!this._isSupportedRenderer(this.internalRenderer)&&(this._set(`internalRenderer`,null),Ae.getLogger(this).warn(`ArcGISImageService`,`Switching to the default renderer. Renderer applied is not valid for this Imagery Layer`)),this._set(`internalRenderer`,this._configRenderer(this.renderer)),this.addHandles([y(()=>this.rasterFunction,e=>{(this.renderer||this.symbolizer||this.popupEnabled&&this.popupTemplate)&&this._generateRasterInfo(e).then(e=>{e&&(this.rasterInfo=e)})})]);let{serviceRasterInfo:t}=this;t.multidimensionalInfo!=null&&this._updateMultidimensionalDefinition(t)})}_combineMosaicRuleWithTimeExtent(e,t){let n=this.timeInfo,{multidimensionalInfo:r}=this.serviceRasterInfo;if(e==null||r==null||t==null||n?.startField==null)return e;let{startField:i}=n,a=r.variables.some(e=>e.dimensions.some(e=>e.name===i))?i:`StdTime`;if(e=e.clone(),this.sourceType===`mosaic-dataset`)return e.multidimensionalDefinition=e.multidimensionalDefinition?.filter(e=>e.dimensionName!==a),this._cleanupMultidimensionalDefinition(e);e.multidimensionalDefinition=e.multidimensionalDefinition||[];let o=e.multidimensionalDefinition.filter(e=>e.dimensionName===a),s=t.start==null?null:t.start.getTime(),c=t.end==null?null:t.end.getTime(),l=s==null||c==null||s===c,u=l?[s||c]:[[s,c]],d=this.version>=10.8;if(o.length)o.forEach(e=>{e.dimensionName===a&&(d?(e.dimensionName=null,e.isSlice=!1,e.values=[]):(e.isSlice=l,e.values=u))});else if(!d){let t=e.multidimensionalDefinition.filter(e=>e.variableName!=null&&e.dimensionName==null);t.length?t.forEach(e=>{e.dimensionName=a,e.isSlice=l,e.values=u}):e.multidimensionalDefinition.push(new Ke({variableName:``,dimensionName:a,isSlice:l,values:u}))}return this._cleanupMultidimensionalDefinition(e)}_cleanupMultidimensionalDefinition(e){return e==null?null:(e.multidimensionalDefinition&&(e.multidimensionalDefinition=e.multidimensionalDefinition.filter(e=>!(!e.variableName&&!e.dimensionName)),e.multidimensionalDefinition.length===0&&(e.multidimensionalDefinition=null)),this.sourceType!==`mosaic-dataset`&&e.multidimensionalDefinition==null?null:e)}async _prepareForQuery(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsQuery)throw new E(`imagery-layer:query-rasters`,`query operation is not supported on the input image service`);return e=e==null?this.createQuery():m(o,e),t=this._getRequestOptions(t),this.raster&&(t.query={...t.query,raster:this.raster}),{query:e,requestOptions:t}}_isSupportedRenderer(e){let{rasterInfo:t,rasterFunction:n}=this;return e.type===`unique-value`&&this._hasRasterFunction(n)&&t?.bandCount===1&&[`u8`,`s8`].includes(t.pixelType)||t!=null&&e!=null&&ut(t).includes(e.type)}async _fetchCapabilities(e){return this.capabilities||await this._fetchServiceInfo(e),this.capabilities}async _fetchServiceInfo(e){let t=this.sourceJSON;if(!t){let{data:n,ssl:r}=await S(s(this.parsedUrl),{query:this._getQueryParams(),signal:e});t=n,this.sourceJSON=t,r&&(this.url=this.url.replace(/^http:/i,`https:`))}if(t.capabilities?.toLowerCase().split(`,`).map(e=>e.trim()).indexOf(`tilesonly`)>-1)throw new E(`imagery-layer:fetch-service-info`,`use ImageryTileLayer to open tiles-only image services`);this.read(t,{origin:`service`,url:this.parsedUrl})}_isMosaicDataset(e){return e.serviceSourceType?e.serviceSourceType===`esriImageServiceSourceTypeMosaicDataset`:e.fields?.length>0}_isMosaicRuleSupported(e){if(!e)return!1;let t=this._isMosaicDataset(e),n=e.currentVersion>=10.71&&e.hasMultidimensions&&!(e.fields?.length>1);return t||n}_isVectorFieldResampleFunction(e){if(e==null)return!1;let{functionName:t,functionArguments:n}=e,r=t?.toLowerCase()===`resample`,i=n?.ResampleType||n?.resampleType;return r&&(i===7||i===10)}_isPicture(){return!this.format||this.format.includes(`jpg`)||this.format.includes(`png`)}_configRenderer(e){let t=this._isPicture(),{rasterInfo:n}=this;if(!t&&!this.pixelFilter||this._isVectorDataSet()){let t=this.mosaicRule?.multidimensionalDefinition?.[0].variableName,r=dt({variableName:t,rasterFunctionName:this.rasterFunction?.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&n.bandCount>=3){let e=r?.bandIds??_t(n);!e||n.bandCount===3&&e[0]===0&&e[1]===1&&e[2]===2||(this.bandIds=e)}e||=r?.renderer??pt(n,{bandIds:this.bandIds,variableName:this.rasterFunction?null:t});let i=mt(e.toJSON());this.symbolizer?(this.symbolizer.rendererJSON=i,this.symbolizer.rasterInfo=n):this.symbolizer=new at({rendererJSON:i,rasterInfo:n}),this.symbolizer.bind().success||(this.symbolizer=null)}return e}_clonePixelData(e){return e==null?e:{extent:e.extent&&e.extent.clone(),pixelBlock:e.pixelBlock==null?null:e.pixelBlock.clone()}}_getQueryParams(e){e?.renderingRule!=null&&typeof e.renderingRule!=`string`&&(e.renderingRule=this._getRenderingRuleString(e.renderingRule));let{raster:t,viewId:n}=this;return{raster:t,viewId:n,f:`json`,...e,...this.customParameters}}_getRequestOptions(e){return{...e,query:{...e?.query,...this.customParameters}}}_decodePixelBlock(e,t,n){return this._rasterJobHandler?this._rasterJobHandler.decode({data:e,options:t}):Ye(e,t,n)}async _getRasterFunctionInfos(e){let t=this.sourceJSON.rasterFunctionInfos;return this.loaded?t:t&&this.version>=10.3?t.length===1&&t[0].name.toLowerCase()===`none`?t:(await S(s(this.parsedUrl)+`/rasterFunctionInfos`,{query:this._getQueryParams(),signal:e})).data?.rasterFunctionInfos:null}_canRequestImageElement(e){return!this.pixelFilter&&(!e||e.includes(`png`))}async _requestArrayBuffer(e){let{imageProps:t,requestAsImageElement:n,returnImageBitmap:r,signal:i}=e;if(n&&this._canRequestImageElement(t.format)){let n=`${s(this.parsedUrl)}/exportImage`,{data:a}=await S(n,{responseType:r?`blob`:`image`,query:this._getQueryParams({f:`image`,...this.refreshParameters,...e.imageServiceParameters}),signal:i});return a instanceof Blob?{imageBitmap:await Fe(a,n,i),params:t}:{imageOrCanvasElement:a,params:t}}let a=this._initJobHandler(),o=S(s(this.parsedUrl)+`/exportImage`,{responseType:`array-buffer`,query:this._getQueryParams({f:`image`,...e.imageServiceParameters}),signal:i}),c=(await Promise.all([o,a]))[0].data,l=t.format||`jpgpng`,u=l;if(u!==`bsq`&&u!==`bip`&&(u=tt(c)),!u)throw new E(`imagery-layer:fetch-image`,`unsupported format signature `+String.fromCharCode.apply(null,new Uint8Array(c)));let d={signal:i};return{pixelData:{pixelBlock:await(l===`gif`||l===`bmp`||l.includes(`png`)&&(u===`png`||u===`jpg`)?Ye(c,{useCanvas:!0,...t},d):this._decodePixelBlock(c,{width:t.width,height:t.height,planes:null,pixelType:null,noDataValue:null,format:l},d)),extent:t.extent},params:t}}_generateRasterInfo(e,t){return this.generateRasterInfo(e,t).catch(()=>null)}_isValidCustomizedMosaicRule(e){return e&&JSON.stringify(e.toJSON())!==JSON.stringify(this.defaultMosaicRule?.toJSON())}_updateMultidimensionalDefinition(e){if(this._isValidCustomizedMosaicRule(this.mosaicRule))return;let t=Ue(e,{multidimensionalSubset:this.multidimensionalSubset});if(t!=null&&t.length>0){this.mosaicRule=this.mosaicRule||new M;let e=this.mosaicRule.multidimensionalDefinition;!this.sourceJSON.defaultVariableName&&this.rasterFunction&&this.rasterFunction.functionName?.toLowerCase()!==`none`&&t.forEach(e=>e.variableName=``),t=t.filter(({variableName:e,dimensionName:t})=>e&&e!==`*`||t),!e?.length&&t.length&&(this.mosaicRule.multidimensionalDefinition=t)}}_processVisibleRastersResponse(e,t){t||={};let n=e.value,{templateRRFunctionNames:r,showNoDataRecords:i,returnDomainValues:a,templateFields:o}=t,s=e.processedValues,c=e.catalogItems?.features,l=e.properties?.Values?.map(e=>e.replaceAll(/ /gi,`, `))||[],u=this.objectIdField||`ObjectId`,d=typeof n==`string`&&n.toLowerCase().includes(`nodata`),f=[];if(n&&!c&&(!d||i)){let e={};e[u]=0,l=[n],c=[new h({geometry:this.fullExtent,attributes:e})],this.multidimensionalInfo&&this.sourceType===`raster-dataset`&&Ot(this.rasterFields,e,t.effectiveMultidimensionalDefinition)}if(!c)return[];this._updateResponseFieldNames(c,o),d&&!i&&(c=[]);let{itemPixelValue:p,servicePixelValue:m}=Ct,g=this.rasterFields.some(e=>e.name===p),_=this.graphicOrigin;for(let e=0;e<c.length;e++){let t=c[e];if(n!=null){let a=l[e],o=this.rasterFunction&&s&&s.length>0&&r&&r.length>0&&r.includes(this.rasterFunction.functionName)?s[r.indexOf(this.rasterFunction.functionName)]:n;if(a.toLowerCase()===`nodata`&&!i)continue;g&&(t.attributes[p]=a),t.attributes[m]=o,this._updateFeatureWithMagDirValues(t,a);let c=this.fields&&this.fields.length>0,u=this.rasterFunction&&this.serviceRasterInfo.attributeTable!=null?c?a:n:o;this.rasterFunction||(u=c?a:n),this._updateFeatureWithRasterAttributeTableValues(t,u)}if(t.sourceLayer=t.layer=this,t.origin=_,a&&this._updateFeatureWithDomainValues(t),r&&s&&r.length===s.length)for(let e=0;e<r.length;e++){let n=`${Ct.servicePixelValue}.${r[e]}`;t.attributes[n]=s[e]}f.push(c[e])}return f}_processMultidimensionalIntersection(e,t,n){let{multidimensionalSubset:r}=this;if(!r)return{isOutSide:!1,timeExtent:t,mosaicRule:n=this._combineMosaicRuleWithTimeExtent(n,t)};if(r){let{isOutside:n,intersection:i}=Ge(r,{geometry:e,timeExtent:t});if(n)return{isOutSide:!0,timeExtent:null,mosaicRule:null};i?.timeExtent!=null&&(t=i.timeExtent)}if(n=this._combineMosaicRuleWithTimeExtent(n,t),n?.multidimensionalDefinition){let{isOutside:e}=Ge(r,{multidimensionalDefinition:n.multidimensionalDefinition});if(e)return{isOutSide:!0,timeExtent:null,mosaicRule:null}}return{isOutSide:!1,timeExtent:t,mosaicRule:n}}_updateFeatureWithRasterAttributeTableValues(e,t){let n=this.rasterInfo.attributeTable||this.serviceRasterInfo.attributeTable;if(n==null)return;let{features:r,fields:i}=n,a=i.map(e=>e.name).find(e=>e.toLowerCase()===`value`);if(!a)return;let o=r.filter(e=>e.attributes[a]===(t==null?null:parseInt(t,10)));o&&o[0]&&i.forEach(t=>{let n=`Raster.`+t.name;e.attributes[n]=o[0].attributes[t.name]})}_updateFeatureWithMagDirValues(e,t){if(!this._isVectorDataSet())return;let n=t.split(/,\s*/).map(e=>parseFloat(e)),r=n.map(e=>[e]),i=n.map(e=>({minValue:e,maxValue:e,noDataValue:null})),a=new xt({height:1,width:1,pixelType:`f32`,pixels:r,statistics:i});this.pixelFilter!=null&&this.pixelFilter({pixelBlock:a,extent:new fe(0,0,0,0,this.spatialReference)});let o=this.serviceDataType===`esriImageServiceDataTypeVector-MagDir`?[a.pixels[0][0],a.pixels[1][0]]:It([a.pixels[0][0],a.pixels[1][0]]);e.attributes[Ct.magnitude]=o[0],e.attributes[Ct.direction]=o[1]}_updateFeatureWithDomainValues(e){(this.fields&&this.fields.filter(e=>e.domain&&e.domain.type===`coded-value`))?.forEach(t=>{let n=e.attributes[t.name];if(n!=null){let r=t.domain.codedValues.find(e=>e.code===n);r&&(e.attributes[t.name]=r.name)}})}_updateResponseFieldNames(e,t){if(!t||t.length<1)return;let n=this.fieldsIndex;n!=null&&e.forEach(e=>{if(e?.attributes)for(let r of t){let t=n.get(r)?.name;t&&t!==r&&(e.attributes[r]=e.attributes[t],delete e.attributes[t])}})}_getRenderingRuleString(e){if(e){let t=e.toJSON();return t=t.rasterFunctionDefinition??t,(t.thumbnail||t.thumbnailEx)&&(t.thumbnail=t.thumbnailEx=null),JSON.stringify(t)}return null}_hasRasterFunction(e){return e?.functionName!=null&&e.functionName.toLowerCase()!==`none`}_updateRenderingRulesFunctionName(e,t){if(!e||e.length<1)return;if(e===`Raw`)return e.replace(`Raw`,`None`);let n=e.toLowerCase().replaceAll(/ /gi,`_`);return t.has(n)?t.get(n):e}_isRFTJson(e){return e?.name&&e.arguments&&e.function&&e.hasOwnProperty(`functionType`)}_isVectorDataSet(){return this.serviceDataType===`esriImageServiceDataTypeVector-UV`||this.serviceDataType===`esriImageServiceDataTypeVector-MagDir`}_applyMosaicAndRenderingRules(e){let{raster:t,mosaicRule:n,rasterFunction:r}=this;r&&e.rasterFunction==null&&(e.rasterFunction=r),n&&e.mosaicRule==null&&(e.mosaicRule=n),t&&e.raster==null&&(e.raster=t)}async _updateCurrentRasterInfo(e){if(this.renderer||this.symbolizer){let t=await this._generateRasterInfo(this.rasterFunction,{signal:e});t&&(this.rasterInfo=t)}}_applyMosaicRule(e){let{raster:t,mosaicRule:n}=this;n&&e.mosaicRule==null&&(e.mosaicRule=n),t&&e.raster==null&&(e.raster=t)}_readCapabilities(e){let t=e.capabilities?e.capabilities.toLowerCase().split(`,`).map(e=>e.trim()):[`image`,`catalog`],{currentVersion:n,maxRecordCount:r}=e,i=t.includes(`image`),a=e.serviceDataType===`esriImageServiceDataTypeElevation`,o=!(!e.spatialReference&&!e.extent?.spatialReference),s=t.includes(`edit`),c=t.includes(`mensuration`)&&o,l=e.mensurationCapabilities==null?[]:e.mensurationCapabilities.toLowerCase().split(`,`).map(e=>e.trim()),u=c&&l.includes(`basic`),d=this._isMosaicDataset(e)&&t.includes(`catalog`),f=t.includes(`download`),p=n>=10.7&&a||n>=11.4&&(a||c&&l.includes(`3d`)),m=d&&e.fields&&e.fields.length>0,h=m&&e.supportsAdvancedQueries?e.advancedQueryCapabilities:void 0;return{data:{supportsAttachment:!1},operations:{supportsComputeHistograms:i,supportsExportImage:i,supportsIdentify:i,supportsImageToMap:n>=11.2&&d,supportsImageToMapMultiray:n>=11.2&&d,supportsMapToImage:n>=11.2&&d,supportsFindImages:n>=11.2&&d,supportsGetImageUrl:n>=11.3&&f,supportsMeasure:c,supportsMeasureFromImage:n>=11.2,supportsDownload:f,supportsQuery:m,supportsGetSamples:n>=10.2&&i,supportsProject:n>=10.3&&i,supportsComputeStatisticsHistograms:n>=10.4&&i,supportsQueryBoundary:n>=10.6&&i,supportsCalculateVolume:p,supportsComputePixelLocation:n>=10.7&&d,supportsComputeAngles:n>=10.91,supportsQueryGPSInfo:n>=11.2&&d,supportsAdd:s,supportsDelete:s,supportsEditing:s,supportsUpdate:s,supportsCalculate:!1,supportsTruncate:!1,supportsValidateSql:!1,supportsChangeTracking:!1,supportsQueryAttachments:!1,supportsResizeAttachments:!1,supportsSync:!1,supportsExceedsLimitStatistics:!1,supportsQueryAnalytics:!1,supportsQueryBins:!1,supportsQueryPivot:!1,supportsQueryTopFeatures:!1,supportsAsyncConvert3D:!1},query:{maxRecordCount:r,maxRecordCountFactor:void 0,maxUniqueIDCount:void 0,supportsStatistics:!!h?.supportsStatistics,supportsOrderBy:!!h?.supportsOrderBy,supportsDistinct:!!h?.supportsDistinct,supportsPagination:!!h?.supportsPagination,supportsPaginationOnAggregatedQueries:!!h?.supportsPaginationOnAggregatedQueries,supportsStandardizedQueriesOnly:!!h?.useStandardizedQueries,supportsPercentileStatistics:!!h?.supportsPercentileStatistics,supportsCentroid:!!h?.supportsReturningGeometryCentroid,supportsCentroidOnDegeneratedQuantizedGeometry:!1,supportsCurrentUser:!1,supportsDegeneratedQuantizedGeometry:!1,supportsDistance:!!h?.supportsQueryWithDistance,supportsExtent:!!h?.supportsReturningQueryExtent,supportsGeometryProperties:!!h?.supportsReturningGeometryProperties,supportsHavingClause:!!h?.supportsHavingClause,supportsQuantization:!1,supportsQuantizationEditMode:!1,supportsQueryGeometry:!1,supportsResultType:!1,supportsReturnMesh:!1,supportsMaxRecordCountFactor:!1,supportsSqlExpression:h?.supportsSqlExpression??!!h,supportsTopFeaturesQuery:!1,supportsQueryByAnonymous:!1,supportsQueryByOthers:!1,supportsHistoricMoment:!1,supportsFormatPBF:!1,supportsDisjointSpatialRelationship:!1,supportsCacheHint:!1,supportsSpatialAggregationStatistics:!1,supportedSpatialAggregationStatistics:{envelope:!1,centroid:!1,convexHull:!1},supportsDefaultSpatialReference:!!h?.supportsDefaultSR,supportsFullTextSearch:!1,supportsCompactGeometry:!1,standardMaxRecordCount:void 0,tileMaxRecordCount:void 0,supportsTrueCurve:!1},mensuration:{supportsDistanceAndAngle:u,supportsAreaAndPerimeter:u,supportsPointOrCentroid:u,supportsHeightFromBaseAndTop:c&&l.includes(`base-top height`),supportsHeightFromBaseAndTopShadow:c&&l.includes(`base-top shadow height`),supportsHeightFromTopAndTopShadow:c&&l.includes(`top-top shadow height`),supports3D:c&&l.includes(`3d`)}}}};function s(e){return e?.path??``}return a([b({clonable:!1})],i.prototype,`_functionRasterInfos`,void 0),a([b({readOnly:!0})],i.prototype,`_serviceSupportsMosaicRule`,void 0),a([f(`_serviceSupportsMosaicRule`,[`currentVersion`,`fields`])],i.prototype,`readServiceSupportsMosaicRule`,null),a([b({readOnly:!0})],i.prototype,`_rasterFunctionNamesIndex`,null),a([b()],i.prototype,`adjustAspectRatio`,void 0),a([b({type:[Pe],json:{write:!0}})],i.prototype,`bandIds`,void 0),a([f(`bandIds`)],i.prototype,`readBandIds`,null),a([b({readOnly:!0,json:{read:!1}})],i.prototype,`capabilities`,void 0),a([f(`service`,`capabilities`,[`capabilities`,`currentVersion`,`serviceDataType`])],i.prototype,`readCapabilities`,null),a([b({type:Number})],i.prototype,`compressionQuality`,void 0),a([O(`compressionQuality`)],i.prototype,`writeCompressionQuality`,null),a([b({type:Number})],i.prototype,`compressionTolerance`,void 0),a([O(`compressionTolerance`)],i.prototype,`writeCompressionTolerance`,null),a([b({json:{read:{source:`copyrightText`}}})],i.prototype,`copyright`,void 0),a([b({readOnly:!0,dependsOn:[`_serviceSupportsMosaicRule`]})],i.prototype,`defaultMosaicRule`,void 0),a([f(`defaultMosaicRule`,[`defaultMosaicMethod`])],i.prototype,`readDefaultMosaicRule`,null),a([b({type:String,json:{name:`layerDefinition.definitionExpression`,write:{enabled:!0,allowNull:!0}}})],i.prototype,`definitionExpression`,void 0),a([b({readOnly:!0,constructOnly:!0})],i.prototype,`exportImageServiceParameters`,void 0),a([b()],i.prototype,`rasterInfo`,void 0),a([b({readOnly:!0,type:[n]})],i.prototype,`fields`,void 0),a([b({readOnly:!0})],i.prototype,`fieldsIndex`,null),a([b({type:[`png`,`png8`,`png24`,`png32`,`jpg`,`bmp`,`gif`,`jpgpng`,`lerc`,`tiff`,`bip`,`bsq`],json:{write:!0}})],i.prototype,`format`,null),a([f(`service`,`format`,[`serviceDataType`])],i.prototype,`readFormat`,null),a([b({type:fe})],i.prototype,`fullExtent`,void 0),a([b({readOnly:!0})],i.prototype,`hasMultidimensions`,void 0),a([b({json:{read:{source:`maxImageHeight`}}})],i.prototype,`imageMaxHeight`,void 0),a([b({json:{read:{source:`maxImageWidth`}}})],i.prototype,`imageMaxWidth`,void 0),a([b({type:String,json:{type:$e.jsonValues,read:$e.read,write:$e.write}})],i.prototype,`interpolation`,void 0),a([b()],i.prototype,`minScale`,void 0),a([f(`service`,`minScale`)],i.prototype,`readMinScale`,null),a([b()],i.prototype,`maxScale`,void 0),a([f(`service`,`maxScale`)],i.prototype,`readMaxScale`,null),a([b({type:M})],i.prototype,`mosaicRule`,null),a([f(`mosaicRule`,[`mosaicRule`,`defaultMosaicMethod`])],i.prototype,`readMosaicRule`,null),a([O(`mosaicRule`)],i.prototype,`writeMosaicRule`,null),a([b()],i.prototype,`multidimensionalInfo`,void 0),a([b({type:st,json:{write:!0}})],i.prototype,`multidimensionalSubset`,void 0),a([b({json:{type:Pe}})],i.prototype,`noData`,void 0),a([O(`noData`)],i.prototype,`writeNoData`,null),a([b({type:String,json:{type:Je.jsonValues,read:Je.read,write:Je.write}})],i.prototype,`noDataInterpretation`,void 0),a([b({type:String,readOnly:!0,json:{read:{source:[`fields`]}}})],i.prototype,`objectIdField`,void 0),a([f(`objectIdField`)],i.prototype,`readObjectIdField`,null),a([b({readOnly:!0})],i.prototype,`geometryType`,void 0),a([b({})],i.prototype,`typeIdField`,void 0),a([b({})],i.prototype,`types`,void 0),a([b({readOnly:!0})],i.prototype,`parsedUrl`,null),a([b({type:Function})],i.prototype,`pixelFilter`,void 0),a([b()],i.prototype,`raster`,void 0),a([b({readOnly:!0})],i.prototype,`sourceType`,void 0),a([f(`sourceType`,[`serviceSourceType`,`fields`])],i.prototype,`readSourceType`,null),a([b()],i.prototype,`viewId`,void 0),a([b()],i.prototype,`renderer`,null),a([b({types:vt,json:{name:`layerDefinition.drawingInfo.renderer`,origins:{"web-scene":{types:lt,name:`layerDefinition.drawingInfo.renderer`,write:{overridePolicy:e=>({enabled:e&&e.type!==`vector-field`})}}}}})],i.prototype,`internalRenderer`,null),a([f(`internalRenderer`)],i.prototype,`readRenderer`,null),a([O(`internalRenderer`)],i.prototype,`writeRenderer`,null),a([b({clonable:!1})],i.prototype,`symbolizer`,void 0),a([b(Ce)],i.prototype,`opacity`,void 0),a([b({readOnly:!0})],i.prototype,`rasterFields`,null),a([b({constructOnly:!0})],i.prototype,`rasterFunctionInfos`,void 0),a([b({type:N,json:{name:`renderingRule`}})],i.prototype,`rasterFunction`,null),a([f(`rasterFunction`,[`renderingRule`,`rasterFunctionInfos`])],i.prototype,`readRasterFunction`,null),a([b({readOnly:!0})],i.prototype,`serviceDataType`,void 0),a([b({readOnly:!0,type:w})],i.prototype,`spatialReference`,void 0),a([f(`spatialReference`,[`spatialReference`,`extent`])],i.prototype,`readSpatialReference`,null),a([b({type:it.apiValues,json:{read:it.read,type:it.jsonValues}})],i.prototype,`pixelType`,void 0),a([O(`pixelType`)],i.prototype,`writePixelType`,null),a([b({constructOnly:!0,type:et})],i.prototype,`serviceRasterInfo`,void 0),a([b()],i.prototype,`sourceJSON`,void 0),a([b(ke)],i.prototype,`url`,void 0),a([b({readOnly:!0})],i.prototype,`version`,void 0),a([f(`version`,[`currentVersion`,`fields`,`timeInfo`])],i.prototype,`readVersion`,null),i=a([D(`esri.layers.mixins.ArcGISImageService`)],i),i},$=class extends Ee(g(ge(Oe(ce(Bt(Er(yt(_e(c(re(be(j(x))))))))))))){constructor(...e){super(...e),this.graphicOrigin=new Ht(this),this.isReference=null,this.operationalLayerType=`ArcGISImageServiceLayer`,this.popupEnabled=!0,this.popupTemplate=null,this.screenSizePerspectiveEnabled=!0,this.type=`imagery`,this._debouncedSaveOperations=ee(async(e,t,n)=>{let{save:r,saveAs:i}=await s(async()=>{let{save:e,saveAs:t}=await import(`./imageryUtils-Cn-r4wiv.js`);return{save:e,saveAs:t}},__vite__mapDeps([0,1,2,3,4,5,6]));switch(e){case 0:return r(this,t);case 1:return i(this,n,t)}})}normalizeCtorArgs(e,t){return typeof e==`string`?{url:e,...t}:e}load(e){let t=e==null?null:e.signal;return this.addResolvingPromise(this.loadFromPortal({supportedTypes:[`Image Service`]},e).catch(le).then(()=>this._fetchService(t))),Promise.resolve(this)}set elevationInfo(e){e?.mode!==`relative-to-scene`&&this._set(`elevationInfo`,e),this._validateElevationInfo(e)}get legendEnabled(){return!this._isPreviewLayer&&(this._get(`legendEnabled`)??!0)}set legendEnabled(e){this._set(`legendEnabled`,e)}get listMode(){return this._isPreviewLayer?`hide`:this._get(`listMode`)}set listMode(e){this._set(`listMode`,e)}writeOperationalLayerType(e,t,n){t[n]=this.renderer?.type===`vector-field`?`ArcGISImageServiceVectorLayer`:`ArcGISImageServiceLayer`}get defaultPopupTemplate(){return this.createPopupTemplate()}get _isPreviewLayer(){return!(!this.raster||!this.url?.toLowerCase().includes(`/rasterrendering/imageserver`))}createPopupTemplate(e){let{rasterFields:t}=this,n=new Set,r=Ct.itemPixelValue.toLowerCase(),i=this.sourceType===`raster-dataset`,a=Pt.toLowerCase(),o=`${Ct.servicePixelValue.toLowerCase()}.`;for(let e of t){let t=e.name.toLowerCase();t===r||t.startsWith(o)||i&&t.startsWith(a)||n.add(e.name)}let s=te({fields:t,title:this.title},{...e,visibleFieldNames:n}),{rasterInfo:c}=this;return s?.fieldInfos&&c&&Et(s.fieldInfos,c),s}queryFeatures(e,t){return this.queryRasters(e,t).then(e=>{if(e?.features)for(let t of e.features)t.layer=t.sourceLayer=this,t.origin=this.graphicOrigin;return e})}queryFeatureCount(e,t){return this.queryRasterCount(e,t)}redraw(){this.emit(`redraw`)}async save(e){return this._debouncedSaveOperations(0,e)}async saveAs(e,t){return this._debouncedSaveOperations(1,t,e)}serviceSupportsSpatialReference(e){return Ne(this,e)}write(e,t){if(!this._isPreviewLayer)return super.write(e,t);if(t?.messages){let e=`${t.origin}/${t.layerContainerType||`operational-layers`}`;t.messages.push(new E(`layer:unsupported`,`Imagery preview layer (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${e}'`,{layer:this}))}return null}_validateElevationInfo(e){Le(Ae.getLogger(this),Re(`Imagery layers`,`relative-to-scene`,e)),Le(Ae.getLogger(this),Ie(`Imagery layers`,e))}};a([b({type:De,value:null,json:{name:`layerDefinition.elevationInfo`,write:!0,origins:{"portal-item":{read:!1,write:!1},"web-map":{read:!1,write:!1}}}})],$.prototype,`elevationInfo`,null),a([b({readOnly:!0,clonable:!1})],$.prototype,`graphicOrigin`,void 0),a([b(d)],$.prototype,`legendEnabled`,null),a([b({type:[`show`,`hide`]})],$.prototype,`listMode`,null),a([b({type:Boolean,json:{read:!1,write:{enabled:!0,overridePolicy:()=>({enabled:!1})}}})],$.prototype,`isReference`,void 0),a([b({type:[`ArcGISImageServiceLayer`],json:{origins:{"web-map":{type:[`ArcGISImageServiceLayer`,`ArcGISImageServiceVectorLayer`],read:!1,write:{target:`layerType`,ignoreOrigin:!0}}}}})],$.prototype,`operationalLayerType`,void 0),a([O(`web-map`,`operationalLayerType`)],$.prototype,`writeOperationalLayerType`,null),a([b(_)],$.prototype,`popupEnabled`,void 0),a([b({type:Te,json:{read:{source:`popupInfo`},write:{target:`popupInfo`}}})],$.prototype,`popupTemplate`,void 0),a([b({readOnly:!0})],$.prototype,`defaultPopupTemplate`,null),a([b(ve)],$.prototype,`screenSizePerspectiveEnabled`,void 0),a([b({readOnly:!0,json:{read:!1}})],$.prototype,`type`,void 0),a([b({readOnly:!0})],$.prototype,`_isPreviewLayer`,null),$=a([D(`esri.layers.ImageryLayer`)],$);var Dr=$;export{Dr as default};
const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/densifyOperator-BuecAwvo.js","assets/UnitFactory-J9WMNXdY.js","assets/index-BqmCqmfp.js","assets/index-kIqmb12G.css","assets/Envelope2D-BNwQDrOT.js","assets/Point2D-UYEfE6HP.js","assets/OperatorDefinitions-DQQu7-BK.js","assets/SimpleGeometryCursor-CI9GIWKa.js","assets/Transformation2D-DVoPQwGC.js","assets/densifyOperator-CMdMIzY9.js","assets/apiConverter-DVPFZqjR.js","assets/jsonConverter-DiNOXEUJ.js","assets/differenceOperator-CkbxR4hR.js","assets/differenceOperator-C2DtYLs8.js","assets/lengthOperator-CDbTNtoR.js","assets/lengthOperator-Bek34LVo.js"])))=>i.map(i=>d[i]);
import{Ax as e,CD as t,Cw as n,Hx as r,Hy as i,IC as a,MC as o,Nm as s,Pa as c,Pw as l,Sw as u,Sx as d,Ux as f,_E as p,e_ as m,jS as h,jm as g,kC as _,oT as v,ta as y,vC as b,vE as x,zC as S}from"./index-BqmCqmfp.js";import{t as C}from"./QueueProcessor-C8_CgXms.js";import{c as w,f as T,i as E,l as D,n as O,p as k,r as A,s as j,t as M,u as N}from"./multidimensionalUtils-yEWHc_se.js";import{E as P,Q as F,d as I,t as L,z as R}from"./RasterSymbolizer-CkbjgVe_.js";import{_ as ee,a as z,c as te,f as ne,g as re,h as ie,i as ae,l as oe,m as se,n as ce,o as le,p as ue,r as de,s as fe,u as pe,y as me}from"./RasterJobHandlerMixin-CZVDgRFD.js";import{r as he}from"./pixelRangeUtils-DMjHgTK0.js";import{d as ge,g as B,h as _e,o as ve,u as ye}from"./vectorFieldUtils-yzcuu25U.js";import{r as V,t as be}from"./datasetUtils-DSaKkE9z.js";import{a as xe,c as Se,i as Ce,o as we,r as Te}from"./RawBlockCache-Dlb6yJNd.js";import{a as H,c as Ee,f as U,l as De,n as Oe,o as ke,p as Ae,r as W,s as je,t as G,u as K}from"./rasterProjectionHelper-CyS9RtmF.js";import{i as q,r as Me}from"./clipUtils-ZHQqHn8q.js";import{t as Ne}from"./rasterFunctionHelper-CMjb75WD.js";var Pe=8,Fe=256,Ie=0,J=class extends b{constructor(){super(...arguments),this._tileFetchQueue=new C({concurrency:32,process:(e,t)=>this._fetchRawTile(e.pyramidLevel,e.row,e.col,{...e.options,signal:t})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:`closest`}}normalizeCtorArgs(e){return e?.ioConfig&&(e={...e,ioConfig:{resolution:null,bandIds:null,sampling:`closest`,tileInfo:g.create(),...e.ioConfig}}),e}get _isGlobalWrappableSource(){let{rasterInfo:e}=this,t=G(e.spatialReference);return t!=null&&e.extent.width>=t/2}get _hasNoneOrGCSShiftTransform(){let{transform:e}=this.rasterInfo;return e==null||e.type===`gcs-shift`}set rasterJobHandler(e){this._set(`rasterJobHandler`,e),V(this)&&this.primaryRasters?.rasters?.forEach(t=>t.rasterJobHandler=e)}get rasterId(){return this.url||`rasterId-`+ Ie++}set url(e){this._set(`url`,l(e,x.getLogger(this)))}async open(e){return this._openPromise??=K().then(()=>this._open(e)),this._openPromise}async fetchTile(e,t,n,r={}){let i=r.tileInfo||this.rasterInfo.storageInfo.tileInfo,a=this.getTileExtentFromTileInfo(e,t,n,i);if(!a)throw new p(`imagery-tile:out-of-bounds`,`Level for fetch tile out of range`);return r={noClip:!0,...r},this.fetchPixels(a,i.size[0],i.size[1],r)}async identify(t,n={}){t=a(e,t).clone().normalize();let{multidimensionalDefinition:r,timeExtent:i}=n,{rasterInfo:o}=this,{hasMultidimensionalTranspose:s,multidimensionalInfo:c}=o,{transposedVariableName:l}=n,u=c!=null&&s&&(i!=null||T(r));u&&!l&&(l=r!=null&&r.length>0?r[0].variableName??void 0:c.variables[0].name,n={...n,transposedVariableName:l}),n=this._getRequestOptionsWithSliceId(n);let{spatialReference:f,extent:p}=o,{datumTransformation:m}=n,h=ke(t,f,m);if(!p.intersects(h))return{location:h,value:null};if(o.transform!=null){let e=o.transform.inverseTransform(h);if(!o.nativeExtent.intersects(e))return{location:e,value:null};h=e}let g=0,_=l!=null&&c!=null&&o.hasMultidimensionalTranspose;if(V(this)){let e=this.primaryRasters.rasters[0];if(_)return e.identify(h,n);let{pixelSize:t}=o,i=t.x*3/2,a=t.y*3/2,s=new d({xmin:h.x-i,xmax:h.x+i,ymin:h.y-a,ymax:h.y+a,spatialReference:f}),c={interpolation:`nearest`,multidimensionalDefinition:r,sliceId:n.sliceId,bandIds:n.bandIds},{pixelBlock:l}=await e.fetchPixels(s,3,3,c),{pixelBlock:u}=await this.fetchPixels(s,3,3,c);if(l==null)return{location:h,value:null};let p=!l.mask||l.mask[4]?l.pixels.map(e=>e[4]):null,m;return u!=null&&(m=!u.mask||u.mask[4]?u.pixels.map(e=>e[4]):void 0),{location:h,value:p,processedValue:m,pyramidLevel:0}}if(!_){if(n.srcResolution)g=Ee(n.srcResolution,o,this.ioConfig.sampling).pyramidLevel;else if(g=await this.computeBestPyramidLevelForLocation(t,n),g==null)return{location:h,value:null}}let v=this.identifyPixelLocation(h,g,null,_);if(v===null)return{location:h,value:null};let{row:y,col:b,rowOffset:x,colOffset:S,blockWidth:C}=v,w=await this._tileFetchQueue.push({pyramidLevel:g,row:y,col:b,options:n},{signal:n.signal});if(!w?.pixels?.length)return{location:h,value:null};let E=x*C+S;return this._processIdentifyResult(w,{srcLocation:h,position:E,pyramidLevel:g,useTransposedTile:!!_,requestSomeSlices:u,identifyOptions:n})}async fetchPixels(e,t,n,r={}){e=je(e),r=this._getRequestOptionsWithSliceId(r);let{_hasNoneOrGCSShiftTransform:i}=this;if(r.requestRawData&&i)return this._fetchPixels(e,t,n,r);let a=G(e.spatialReference),o=U(e);if(a==null||o===0||o===1&&this._isGlobalWrappableSource&&i)return this._fetchPixels(e,t,n,r);if(o>=3)return{extent:e,pixelBlock:null};let s=[],{xmin:c,xmax:l}=e,u=Math.round(a/(l-c)*t),f=u-Math.round((a/2-c)/(l-c)*t),p=0,m=[];for(let i=0;i<=o;i++){let h=new d({xmin:i===0?c:-a/2,xmax:i===o?l-a*i:a/2,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference}),g=i===0?u-f:i===o?t-p:u;p+=g,m.push(g);let _=r.disableWrapAround&&i>0?null:this._fetchPixels(h,g,n,r);s.push(_)}let h=(await Promise.all(s)).map(e=>e?.pixelBlock),g=null,_={width:t,height:n};return g=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:h,srcMosaicSize:_,destDimension:null,coefs:null,sampleSpacing:null,interpolation:`nearest`,alignmentInfo:null,blockWidths:m},r)).pixelBlock:B(h,_,{blockWidths:m}),{extent:e,srcExtent:W(e,this.rasterInfo.spatialReference,r.datumTransformation),pixelBlock:g}}async fetchRawPixels(e,t,n,r={}){t={x:Math.floor(t.x),y:Math.floor(t.y)};let i=await this._fetchRawTiles(e,t,n,r),{nativeExtent:a,nativePixelSize:o,storageInfo:s}=this.rasterInfo,c=2**e,l=o.x*c,u=o.y*c,f=new d({xmin:a.xmin+l*t.x,xmax:a.xmin+l*(t.x+n.width-1),ymin:a.ymax-u*(t.y+n.height-1),ymax:a.ymax-u*t.y,spatialReference:a.spatialReference});if(!i)return{extent:f,srcExtent:f,pixelBlock:null};let{pixelBlocks:p,mosaicSize:m}=i;if(p.length===1&&p[0]!=null&&p[0].width===n.width&&p[0].height===n.height)return{extent:f,srcExtent:f,pixelBlock:i.pixelBlocks[0]};let h=e>0?s.pyramidBlockWidth:s.blockWidth,g=e>0?s.pyramidBlockHeight:s.blockHeight,_={x:t.x%h,y:t.y%g},v;return v=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:p,srcMosaicSize:m,destDimension:n,clipOffset:_,clipSize:n,coefs:null,sampleSpacing:null,interpolation:r.interpolation,alignmentInfo:null,blockWidths:null},r)).pixelBlock:B(p,m,{clipOffset:_,clipSize:n}),{extent:f,srcExtent:f,pixelBlock:v}}fetchRawTile(e,t,n,r){throw new p(`BaseRaster:read-not-implemented`,`fetchRawTile() is not implemented`)}computeExtent(e){return W(this.rasterInfo.extent,e)}decodePixelBlock(e,t){return!this.rasterJobHandler||t.useCanvas?P(e,t):this.rasterJobHandler.decode({data:e,options:t})}async request(e,t,n=0){let{customFetchParameters:r}=this.ioConfig,{range:i,query:a,headers:o}=t;n=n??t.retryCount??this.ioConfig.retryCount;let s=i?{Range:`bytes=${i.from}-${i.to}`}:null;try{return await u(e,{...t,query:{...a,...r},headers:{...o,...s}})}catch(r){if(n>0)return n--,this.request(e,t,n);throw r}}getSliceIndex(e){let{multidimensionalInfo:t}=this.rasterInfo;return t==null||e==null||e.length===0?null:M(e,t)}getTileExtentFromTileInfo(e,t,n,r){let i=r.lodAt(e);return i?this.getTileExtent({x:i.resolution,y:i.resolution},t,n,r.origin,r.spatialReference,r.size):null}updateTileInfo(){let{storageInfo:t,spatialReference:n,extent:r,pixelSize:i}=this.rasterInfo,{pyramidResolutions:a}=t;if(!t.tileInfo){let o=[],c=t.maximumPyramidLevel||0,l=(i.x+i.y)/2,u=1/.0254*96*l;for(let e=0;e<=c&&(o.unshift(new s({level:c-e,resolution:l,scale:u})),e!==c);e++)if(a){let t=(a[e].x+a[e].y)/2;u*=t/l,l=t}else l*=2,u*=2;let d=new e({x:r.xmin,y:r.ymax,spatialReference:n});t.tileInfo=new g({origin:d,size:[t.blockWidth,t.blockHeight],spatialReference:n,lods:o}),t.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(t,n=512,r=512,i){let{width:a,height:o,nativeExtent:s,pixelSize:c,spatialReference:l}=t,u=new e({x:s.xmin,y:s.ymax,spatialReference:l});i??=Math.max(0,Math.round(Math.log(Math.max(a,o))/Math.LN2-8));let d=this.computeBlockBoundary(s,512,512,{x:s.xmin,y:s.ymax},[c],i);t.storageInfo=new R({blockWidth:n,blockHeight:r,pyramidBlockWidth:n,pyramidBlockHeight:r,origin:u,firstPyramidLevel:1,maximumPyramidLevel:i,blockBoundary:d})}async computeBestPyramidLevelForLocation(e,t={}){return 0}computeBlockBoundary(e,t,n,r,i,a=0,o=2){if(i.length===1&&a>0){i=[...i];let{x:e,y:t}=i[0];for(let n=0;n<a;n++)e*=o,t*=o,i.push({x:e,y:t})}let s=[],{x:c,y:l}=r;for(let r=0;r<i.length;r++){let{x:a,y:o}=i[r];s.push({minCol:Math.floor((e.xmin-c+.1*a)/t/a),maxCol:Math.floor((e.xmax-c-.1*a)/t/a),minRow:Math.floor((l-e.ymax+.1*o)/n/o),maxRow:Math.floor((l-e.ymin-.1*o)/n/o)})}return s}getPyramidPixelSize(e){let{nativePixelSize:t}=this.rasterInfo,{pyramidResolutions:n,pyramidScalingFactor:r}=this.rasterInfo.storageInfo;if(e===0)return t;if(n!=null&&n.length)return n[e-1];let i=r**e;return{x:t.x*i,y:t.y*i}}identifyPixelLocation(e,t,n,r){let{spatialReference:i,nativeExtent:a,storageInfo:o}=this.rasterInfo,{maximumPyramidLevel:s,origin:c,transposeInfo:l}=o,u=r&&l!=null?l.tileSize[0]:o.blockWidth,d=r&&l!=null?l.tileSize[1]:o.blockHeight,f=ke(e,i,n);if(!a.intersects(f)||t<0||t>s)return null;let{x:p,y:m}=this.getPyramidPixelSize(t),h=(c.y-f.y)/m/d,g=(f.x-c.x)/p/u,_=Math.min(d-1,Math.floor((h-Math.floor(h))*d)),v=Math.min(u-1,Math.floor((g-Math.floor(g))*u));return{pyramidLevel:t,row:Math.floor(h),col:Math.floor(g),rowOffset:_,colOffset:v,blockWidth:u,srcLocation:f}}getTileExtent(e,t,n,r,i,a){let[o,s]=a,c=r.x+n*o*e.x,l=c+o*e.x,u=r.y-t*s*e.y,f=u-s*e.y;return new d({xmin:c,xmax:l,ymin:f,ymax:u,spatialReference:i})}getBlockWidthHeight(e){return{blockWidth:e>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:e>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(e,t,n){let r=this.rasterInfo.storageInfo.blockBoundary[e];return!r||r.maxRow<t||r.maxCol<n||r.minRow>t||r.minCol>n}updateImageSpaceRasterInfo(t){let{pixelSize:n}=t,{width:r,height:i}=t,a=f.WebMercator;t.spatialReference=a,t.extent=t.nativeExtent=new d({xmin:-.5,ymax:.5,xmax:r-.5,ymin:.5-i,spatialReference:a}),t.isPseudoSpatialReference=!0,t.transform=null,t.pixelSize=new e({x:1,y:1,spatialReference:a});let{extent:o,storageInfo:s}=t;if(s){s.origin=new e({x:o.xmin,y:o.ymax,spatialReference:a});let{pyramidResolutions:r,tileInfo:i}=s;if(r&&r.forEach(e=>{e.x/=n.x,e.y/=n.y}),i){i.origin=s.origin;let e=(t.nativePixelSize.x+t.nativePixelSize.y)/2;i.lods.forEach((t,n)=>{t.resolution=e*2**n,t.scale=96*t.resolution/.0254})}}}async _fetchPixels(t,n,r,i={}){let a=U(t);if(a>=2)return{extent:t,pixelBlock:null};let o=this._getSourceDataInfo(t,n,r,i),{pyramidLevel:s,srcResolution:c,srcExtent:l,srcWidth:u,srcHeight:d,ul:f}=o;if(u===0||d===0)return{extent:t,srcExtent:l,pixelBlock:null};let{rasterInfo:p}=this,m=p.transform,h=m?.type===`gcs-shift`,g=G(t.spatialReference)!=null;!h&&g||(a=U(o.srcExtent,h));let _=await this._fetchRawTiles(s,f,{width:u,height:d,wrapCount:a},i);if(!_)return{extent:t,srcExtent:l,pixelBlock:null};let v=p.storageInfo,y=s>0?v.pyramidBlockWidth:v.blockWidth,b=s>0?v.pyramidBlockHeight:v.blockHeight,{x,y:S}=p.pixelSize;if(s>0){let{pyramidResolutions:e,pyramidScalingFactor:t}=v;if(e!=null&&e[s-1])({x,y:S}=e[s-1]);else{let e=t**s;x*=e,S*=e}}let C=p.spatialReference,w=new e({x,y:S,spatialReference:C}),T=y===u&&b===d&&f.x%y===0&&f.y%b===0,E=new e({x:(t.xmax-t.xmin)/n,y:(t.ymax-t.ymin)/r,spatialReference:t.spatialReference}),D=!t.spatialReference.equals(C),O=C.isGeographic?1e-9:1e-4,{datumTransformation:k}=i;if(!D&&T&&_.pixelBlocks.length===1&&y===n&&b===r&&Le(c,E,O))return{extent:t,srcExtent:l,srcTilePixelSize:w,pixelBlock:_.pixelBlocks[0]};let A=g&&G(l.spatialReference)!=null&&this._hasNoneOrGCSShiftTransform,j=i.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith(`vector`);j&&!this.rasterJobHandler&&await K();let M=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:t,srcBufferExtent:_.extent,pixelSize:E.toJSON(),datumTransformation:k,rasterTransform:m,hasWrapAround:a>0||A,isAdaptive:!1!==this.ioConfig.optimizeProjectionAccuracy,includeGCSGrid:j},i):Ae({projectedExtent:t,srcBufferExtent:_.extent,pixelSize:E,datumTransformation:k,rasterTransform:m,hasWrapAround:a>0||A,isAdaptive:!1,includeGCSGrid:j}),N,P=!i.requestRawData,F={rows:M.spacing[0],cols:M.spacing[1]},I=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(s,_.extent.xmin):void 0,{pixelBlocks:L,mosaicSize:R,isPartiallyFilled:ee}=_,z=null;if(this.rasterJobHandler){let e=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:L,srcMosaicSize:R,destDimension:P?{width:n,height:r}:null,coefs:P?M.coefficients:null,sampleSpacing:P?F:null,projectDirections:j,gcsGrid:j?M.gcsGrid:null,isUV:this.rasterInfo.dataType===`vector-uv`,interpolation:i.interpolation,alignmentInfo:I,blockWidths:null},i);({pixelBlock:N,localNorthDirections:z}=e)}else{let e=B(L,R,{alignmentInfo:I});N=P?_e(e,{width:n,height:r},M.coefficients,F,i.interpolation):e,j&&M.gcsGrid&&(z=ge({width:n,height:r},M.gcsGrid),N=ye(N,this.rasterInfo.dataType,z))}return i.requestRawData||j?{extent:t,srcExtent:l,srcTilePixelSize:w,pixelBlock:N,transformGrid:M,localNorthDirections:z,isPartiallyFilled:ee}:{extent:t,srcExtent:l,srcTilePixelSize:w,pixelBlock:N}}async _fetchRawTiles(e,t,n,r){let{origin:i,blockBoundary:a}=this.rasterInfo.storageInfo,{blockWidth:o,blockHeight:s}=this.getBlockWidthHeight(e),{x:c,y:l}=t,{width:u,height:f,wrapCount:p}=n,m=this._getRasterTileAlignmentInfo(e,0);r.buffer&&(c-=r.buffer.cols,l-=r.buffer.rows,u+=2*r.buffer.cols,f+=2*r.buffer.rows);let h=0,g=0,_=0;p&&m!=null&&({worldColumnCountFromOrigin:g,originColumnOffset:_,rightPadding:h}=m,g*m.blockWidth-h>=c+u&&(h=0));let v=Math.floor(c/o),y=Math.floor(l/s),b=Math.floor((c+u+h-1)/o),x=Math.floor((l+f+h-1)/s),S=a[e];if(!S)return null;let{minRow:C,minCol:w,maxCol:T,maxRow:E}=S;if(p===0&&(x<C||b<w||y>E||v>T))return null;let D=[],O=!1,k=this.ioConfig.allowPartialFill==null?r.allowPartialFill:this.ioConfig.allowPartialFill;for(let t=y;t<=x;t++)for(let n=v;n<=b;n++){let i=n;if(!r.disableWrapAround&&p&&m!=null&&g<=n&&(i=n-g-_),t>=C&&i>=w&&E>=t&&T>=i){let n=this._tileFetchQueue.push({pyramidLevel:e,row:t,col:i,options:r},{signal:r.signal});k?D.push(new Promise(e=>{n.then(t=>e(t)).catch(()=>{O=!0,e(null)})})):D.push(n)}else D.push(Promise.resolve(null))}if(D.length===0)return null;let A=await Promise.all(D),j={height:(x-y+1)*s,width:(b-v+1)*o},{spatialReference:M}=this.rasterInfo,{x:N,y:P}=this.getPyramidPixelSize(e);return{extent:new d({xmin:i.x+v*o*N,xmax:i.x+(b+1)*o*N,ymin:i.y-(x+1)*s*P,ymax:i.y-y*s*P,spatialReference:M}),pixelBlocks:A,mosaicSize:j,isPartiallyFilled:O}}_fetchRawTile(e,t,n,r){let{storageInfo:i}=this.rasterInfo,a=i.transposeInfo!=null&&!!r.transposedVariableName;if(!a){let r=i.blockBoundary[e];if(!r)return Promise.resolve(null);let{minRow:a,minCol:o,maxCol:s,maxRow:c}=r;if(t<a||n<o||t>c||n>s)return Promise.resolve(null)}let o=a?r.transposeVariableName:r.sliceId,s=this.rasterInfo.storageInfo.isBsqTile?r.bandIds:null,c=Ce(this.rasterId,o,s),l=`${e}/${t}/${n}`,u=xe(c,r.registryId,l);if(u==null){let i=new AbortController;u=this.fetchRawTile(e,t,n,{...r,signal:i.signal}),Te(c,r.registryId,l,u,i),u.catch(()=>Se(c,r.registryId,l))}return r.signal&&v(r,()=>{we(c,r.registryId,l)}),u}_computeMagDirValues(e){let{bandCount:t,dataType:n}=this.rasterInfo;if(!(t===2&&n===`vector-magdir`||n===`vector-uv`)||e?.length!==2||!e[0]?.length)return null;let r=e[0].length;if(n===`vector-magdir`){let t=e[1].map(e=>(e+360)%360);return[e[0],t]}let[i,a]=e,o=[],s=[];for(let e=0;e<r;e++){let[t,n]=ve([i[e],a[e]]);o.push(t),s.push(n)}return[o,s]}_getRasterTileAlignmentInfo(e,t){return this._rasterTileAlignmentInfo??=De(this.rasterInfo),this._rasterTileAlignmentInfo.pyramidsInfo==null?null:{startX:t,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[e]}}_getSourceDataInfo(t,n,r,i={}){let a={datumTransformation:i.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};i.srcResolution&&(a.srcResolution=i.srcResolution,this._updateSourceDataInfo(t,a));let o=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:s,srcHeight:c,pyramidLevel:l}=a,u=s/n,d=c/r,f=l<o&&u*d>=16,p=l===o&&this._requireTooManySrcTiles(s,c,n,r);if(f||p||s===0||c===0){let s=new e({x:(t.xmax-t.xmin)/n,y:(t.ymax-t.ymin)/r,spatialReference:t.spatialReference}),c=Oe(s,this.rasterInfo.spatialReference,t,a.datumTransformation),p=!c||i.srcResolution&&c.x+c.y<i.srcResolution.x+i.srcResolution.y;if(f&&i.srcResolution&&p){let e=Math.round(Math.log(Math.max(u,d))/Math.LN2)-1;if(o-l+3>=e){let t=2**e;c={x:i.srcResolution.x*t,y:i.srcResolution.y*t}}}c&&(a.srcResolution=c,this._updateSourceDataInfo(t,a))}return this._requireTooManySrcTiles(a.srcWidth,a.srcHeight,n,r)&&(a.srcWidth=0,a.srcHeight=0),a}_requireTooManySrcTiles(e,t,n,r){let{tileInfo:i}=this.rasterInfo.storageInfo,a=Math.ceil(e/i.size[0])*Math.ceil(t/i.size[1]),o=e/n,s=t/r,c=Math.max(1,(n+r)/1024);return a>=Fe*c||o>Pe||s>Pe}_updateSourceDataInfo(e,t){t.srcWidth=0,t.srcHeight=0;let{rasterInfo:n}=this,r=n.spatialReference,{srcResolution:i,datumTransformation:a}=t,{pyramidLevel:o,pyramidResolution:s,excessiveReading:c}=Ee(i,n,this.ioConfig.sampling);if(c)return;let l=t.srcExtent||W(e,r,a);if(l==null)return;let u=n.transform;u&&(l=u.inverseTransform(l)),t.srcExtent=l;let{origin:d}=n.storageInfo,{width:f,height:p,ul:m}=be(l,d,s,o);t.pyramidLevel=o,t.pyramidResolution=s,t.srcWidth=f,t.srcHeight=p,t.ul=m}_getRequestOptionsWithSliceId(e){return this.rasterInfo.multidimensionalInfo!=null&&e.sliceId==null&&(e={...e,sliceId:this.getSliceIndex(e.multidimensionalDefinition)}),e}_processIdentifyResult(e,t){let{srcLocation:n,position:r,pyramidLevel:i,useTransposedTile:a}=t,o=e.pixels[0].length/e.width/e.height;if(!(!e.mask||e.mask[r]))return{location:n,value:null};let{multidimensionalInfo:s}=this.rasterInfo;if(s==null||!a){let t=e.pixels.map(e=>e[r]),a={location:n,value:t,pyramidLevel:i},o=this._computeMagDirValues(t.map(e=>[e]));return o?.length&&(a.magdirValue=o.map(e=>e[0])),a}let c=e.pixels.map(e=>e.slice(r*o,r*o+o)),l=this._computeMagDirValues(c),{requestSomeSlices:u,identifyOptions:d}=t,f=D(s,d.transposedVariableName);if(u){let e=w(f,d.multidimensionalDefinition,d.timeExtent);c=c.map(t=>e.map(e=>t[e])),l=l?.map(t=>e.map(e=>t[e])),f=e.map(e=>f[e])}let p=e.noDataValues||this.rasterInfo.noDataValue,m={pixels:c,pixelType:e.pixelType},h;return p!=null&&(he(m,p),h=m.mask),{location:n,value:null,dataSeries:f.map((e,t)=>{let n={value:h?.[t]===0?null:c.map(e=>e[t]),multidimensionalDefinition:e.multidimensionalDefinition.map(e=>new k({...e,isSlice:!0}))};return l?.length&&(n.magdirValue=[l[0][t],l[1][t]]),n}),pyramidLevel:i}}};function Le(e,t,n){return Math.abs(e.x-t.x)<n&&Math.abs(e.y-t.y)<n}t([o()],J.prototype,`_rasterTileAlignmentInfo`,void 0),t([o()],J.prototype,`_tileFetchQueue`,void 0),t([o({readOnly:!0})],J.prototype,`_isGlobalWrappableSource`,null),t([o({readOnly:!0})],J.prototype,`_hasNoneOrGCSShiftTransform`,null),t([o()],J.prototype,`_openPromise`,void 0),t([o()],J.prototype,`rasterJobHandler`,null),t([o({readOnly:!0})],J.prototype,`rasterId`,null),t([o(y)],J.prototype,`url`,null),t([o({type:String,json:{write:!0}})],J.prototype,`datasetName`,void 0),t([o({type:String,json:{write:!0}})],J.prototype,`datasetFormat`,void 0),t([o()],J.prototype,`hasUniqueSourceStorageInfo`,void 0),t([o()],J.prototype,`rasterInfo`,void 0),t([o()],J.prototype,`ioConfig`,void 0),t([o()],J.prototype,`sourceJSON`,void 0),J=t([_(`esri.layers.support.rasterDatasets.BaseRaster`)],J);var Re=40,Y=class extends J{constructor(){super(...arguments),this.datasetFormat=`Function`,this.tileType=`Raster`,this.rasterFunction=null,this._clippingGeometry=new Map}async fetchPixels(e,t,n,r={}){let{rasters:i,rasterIds:a}=this.primaryRasters,o=!1,{interpolation:s}=r,c=this.rasterFunction.flatWebGLFunctionChain?.hasFocalFunction;!r.requestRawData&&c&&(o=i.length===1&&!r.skipRasterFunction,r={...r,interpolation:`bilinear`,requestRawData:o}),r.requestRawData&&i.length>1&&!this.hasUniqueSourceStorageInfo&&(o=!1,r={...r,requestRawData:!1});let l=i.map(i=>i.fetchPixels(e,t,n,r)),u=await Promise.all(l),d=u.map(e=>e.pixelBlock),f=o||r.requestRawData?u.map(e=>e.srcTilePixelSize):null;if(r.skipRasterFunction||d.every(e=>e==null))return u[0];let p=u.find(e=>e.pixelBlock!=null)?.extent??e,m=this.rasterJobHandler?await this.rasterJobHandler.process({extent:p,primaryPixelBlocks:d,primaryPixelSizes:f,primaryRasterIds:a}):this.rasterFunction.process({extent:p,primaryPixelBlocks:d,primaryPixelSizes:f,primaryRasterIds:a}),{transformGrid:h}=u[0];if(!o||m==null||h==null){let e=r.noClip?null:this.getClippingGeometry(p.spatialReference);return!r.noClip&&m!=null&&e&&(m=await q(m,p,e)),{...u[0],pixelBlock:m}}let g={rows:h.spacing[0],cols:h.spacing[1]},_;_=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[m],srcMosaicSize:{width:m.width,height:m.height},destDimension:{width:t,height:n},coefs:h.coefficients,sampleSpacing:g,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:s,alignmentInfo:void 0,blockWidths:null},r)).pixelBlock:_e(m,{width:t,height:n},h.coefficients,g,s);let v=r.noClip?null:this.getClippingGeometry(e.spatialReference);return r.noClip||_==null||v==null||(_=await q(_,e,v)),{extent:e,srcExtent:u[0].srcExtent,pixelBlock:_}}getClippingGeometry(e){let t=this._clippingGeometry.get(`0`);if(!e||!t)return t;let n=Be(e),r=this._clippingGeometry.get(n);return r??(r=e.equals(t.spatialReference)?t:H(t,e),this._clippingGeometry.set(n,r)),r}async _open(e){let{rasterFunction:t}=this;t.isRoot=!0,this.primaryRasters?.rasters?.length?t.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=t.getPrimaryRasters(),this.rasterJobHandler&&this.primaryRasters.rasters?.forEach(e=>e.rasterJobHandler=this.rasterJobHandler));let{rasters:n,rasterIds:r}=this.primaryRasters,i=n.map(t=>t.rasterInfo?void 0:t.open(e));await Promise.all(i);let a=n.map(({rasterInfo:e})=>e),o=t.bind({rasterInfos:a,rasterIds:r});if(t.rawSourceRasterInfos=a,!o.success||a.length===0)throw new p(`raster-function:open`,`cannot bind the function: ${o.error??``}`);let s=t.functionName===`Table`?t:t.functionArguments?.raster;s?.functionName===`Table`&&(t.rasterInfo.attributeTable=c.fromJSON(s.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();let l=a[0];this.hasUniqueSourceStorageInfo=a.length===1||a.slice(1).every(e=>ze(e,l)),this.set(`sourceJSON`,n[0].sourceJSON),this.set(`rasterInfo`,t.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){return this.rasterJobHandler?.updateRasterFunction(this.rasterFunction)}async _updateClipGeometry(){let e=this.rasterFunction.getClippingGeometries()[0],t=e?.clippingGeometry;if(t&&e.clippingType===`inside`){let{extent:e}=this.rasterInfo,r=await n(()=>import(`./densifyOperator-BuecAwvo.js`),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11])),i=await n(()=>import(`./differenceOperator-CkbxR4hR.js`),__vite__mapDeps([12,1,2,3,4,5,6,7,8,13,10,11])),a=r.execute(m.fromExtent(e),2*(e.width+e.height)/Re);a=H(a,t.spatialReference),t=i.execute(a,t)}this._clippingGeometry.clear(),t&&this._clippingGeometry.set(`0`,t)}};function ze(e,t){let{storageInfo:n,pixelSize:r,spatialReference:i,extent:a}=e,{storageInfo:o,pixelSize:s,spatialReference:c,extent:l}=t;return r.x===s.x&&r.y===s.y&&i.equals(c)&&a.equals(l)&&n.blockHeight===o.blockHeight&&n.blockWidth===o.blockWidth&&n.maximumPyramidLevel===o.maximumPyramidLevel&&n.firstPyramidLevel===o.firstPyramidLevel&&n.pyramidBlockWidth===o.pyramidBlockWidth&&n.pyramidBlockHeight===o.pyramidBlockHeight&&n.pyramidScalingFactor===o.pyramidScalingFactor}function Be(e){return String(e.wkid??e.wkt??e.wkt2)}t([o({type:String,json:{write:!0}})],Y.prototype,`datasetFormat`,void 0),t([o()],Y.prototype,`tileType`,void 0),t([o()],Y.prototype,`rasterFunction`,void 0),t([o()],Y.prototype,`primaryRasters`,void 0),Y=t([_(`esri.layers.support.rasterDatasets.FunctionRaster`)],Y);var X=1e3,Ve=s=>{let c=s,d=class extends c{constructor(...e){super(...e),this._isConstructedFromFunctionRaster=!1,this.bandIds=null,this.copyright=null,this.interpolation=null,this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster=V(e[0]?.raster)}destroy(){this._shutdownJobHandler()}get fullExtent(){return this.serviceRasterInfo?.extent}set multidimensionalDefinition(e){this._set(`multidimensionalDefinition`,e),this.updateRenderer()}set rasterFunction(e){e?.functionName?.toLowerCase()===`none`&&(e=void 0),this._set(`rasterFunction`,e),this.updateRasterFunction()}set url(e){this._set(`url`,l(e,x.getLogger(this)))}get renderer(){if(this.type!==`imagery-tile`)return this.internalRenderer;let{activePresetRendererName:e,presetRenderers:t}=this;return e?(t?.find(({name:t})=>t===e))?.renderer.clone():this.internalRenderer}set renderer(e){this.type===`imagery-tile`&&(this.activePresetRendererName=null),this.internalRenderer=e}set internalRenderer(e){e==null&&this.rasterFunction==null?this._configDefaultRenderer(`override`):(this._set(`internalRenderer`,e),this.updateRenderer())}readRenderer(e,t,n){let r=t?.layerDefinition?.drawingInfo?.renderer;return le(r,n)||void 0}async computeStatisticsHistograms(t,n){await this.load(n),t=a(z,t).clone();let{serviceRasterInfo:r}=this;if(r==null)throw new p(`imagery-tile-mixin:compute-statistics-histograms`,`serviceRasterInfo must be specified`);let{geometry:i}=t;if(i==null)throw new p(`imagery-tile-mixin:compute-statistics-histograms`,`geometry must be specified`);let o=i,{spatialReference:s}=r;if(!i.spatialReference.equals(s)){await K();let e=i.type===`extent`?W(i,s):H(i,s);if(e==null)throw new p(`imagery-tile-mixin:compute-statistics-histograms`,`geometry cannot be projected to the data source`);o=e}let c=t.pixelSize??new e({x:r.pixelSize.x,y:r.pixelSize.y,spatialReference:s}),{extent:l,width:u,height:d}=Me(r,o,c),f=await this.fetchPixels(l,u,d,{...n,interpolation:`nearest`});if(f.pixelBlock==null)throw new p(`imagery-tile-mixin:compute-statistics-histograms`,`failed to fetch pixels`);let m=await q(f.pixelBlock,l,o),h=this._rasterJobHandler;return h?h.computeStatisticsHistograms({pixelBlock:m},n):I(m)}normalizeRasterFetchOptions(e){let{multidimensionalInfo:t}=this.serviceRasterInfo??{};if(t==null)return e;let n=j({rasterInfo:this.raster.rasterInfo,multidimensionalDefinition:e.multidimensionalDefinition||this.multidimensionalDefinition,timeExtent:e.timeExtent??this.timeExtent,multidimensionalSubset:this.multidimensionalSubset});return{...e,multidimensionalDefinition:n,timeExtent:void 0}}async updateRasterFunction(){return this.loaded&&this.type===`imagery-tile`&&(this.rasterFunction||this._cachedRasterFunctionJson)&&JSON.stringify(this.rasterFunction)!==JSON.stringify(this._cachedRasterFunctionJson)?(this._cachedRasterFunctionJson=this.rasterFunction?.toJSON(),this._rasterFunctionUpdatePromise=this._updateRasterFunction(),this._rasterFunctionUpdatePromise):this._rasterFunctionUpdatePromise}async updateRenderer(){let{loaded:e,symbolizer:t,renderer:n}=this;if(!e||!t||!n)return;let{rasterInfo:r}=this.raster,i=N(r,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset})?.name,a=pe(r,i);return this._updateSymbolizer(t,n,i,a)}async applyRenderer(e,t,n){let r=e?.pixelBlock;if(!(r!=null&&r.pixels&&r.pixels.length>0))return null;await this.updateRenderer();let i=this.bandIds??[],{pixelBlock:a}=await this._symbolize({pixelData:e,simpleStretchParams:t,bandIds:i,symbolizer:this.symbolizer},n);return a}getRawDisplayBandIds(){let{bandIds:e,raster:t}=this;if(this.rasterFunction&&V(t)){let n=t.rasterFunction.rawInputBandIds;e=e?.length&&n?.length&&t.rasterInfo.bandCount!==1?e.map(e=>n[Math.min(e,n.length-1)]):n}return e&&e.length>3&&e.every((e,t)=>e===t)?null:e}getTileUrl(e,t,n){return this.raster.datasetFormat===`RasterTileServer`?`${this.url}/tile/${e}/${t}/${n}`:``}getCompatibleTileInfo(e,t,n=!1){if(!this.loaded||t==null)return null;if(n&&e.equals(this.spatialReference))return this.tileInfo;let r=h(e);return g.create({size:256,spatialReference:e,origin:r?{x:r.origin[0],y:r.origin[1]}:{x:t.xmin,y:t.ymax}})}getCompatibleFullExtent(e){return this.loaded?(this._compatibleFullExtent?.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,t,n,r={}){if(m(this),r.requestAsImageElement){let i=this.getTileUrl(e,t,n);return u(i,{responseType:`image`,query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:r.signal}).then(e=>e.data)}let{serviceRasterInfo:i}=this;if(i.multidimensionalInfo!=null&&(r=this.normalizeRasterFetchOptions(r)).multidimensionalDefinition==null){let a=r.tileInfo||i.storageInfo.tileInfo,o=this.raster.getTileExtentFromTileInfo(e,t,n,a);if(o)return{extent:o,pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),this.renderer?.type===`raster-shaded-relief`&&(r={...r,buffer:{cols:1,rows:1}}),this.raster.fetchTile(e,t,n,r)}async fetchPixels(e,t,n,r={}){if(this.serviceRasterInfo.multidimensionalInfo!=null&&(r=this.normalizeRasterFetchOptions(r)).multidimensionalDefinition==null)return{extent:e,pixelBlock:null};await this._initJobHandler(),await this.updateRasterFunction(),t=Math.round(t),n=Math.round(n);let i=await this.raster.fetchPixels(e,t,n,r);return r.bandIds?.length&&!this.raster.rasterInfo.storageInfo.isBsqTile&&(i.pixelBlock=i.pixelBlock?.extractBands(r.bandIds)),i}async getSamples(e,t){if(await this.load(),(e=a(ae,e).clone()).interpolation&&e.interpolation!==`nearest`)throw new p(`imagery-tile-mixin:get-samples`,`only nearest interpolation is currently supported`);let n=e.mosaicRule?.multidimensionalDefinition,r={...t,multidimensionalDefinition:n},i=(await this._getSampleLocations(e)).map(e=>this.identify(e,r).then(t=>(t.location=e,t))),o=(await Promise.all(i)).flatMap((e,t)=>this._convertRasterIdentifyResultToSample(e,t));return new ce({samples:o})}async identify(t,n={}){await this.load(),t=a(e,t).clone().normalize();let{raster:r,serviceRasterInfo:i}=this;if(i?.multidimensionalInfo!=null&&!(i.hasMultidimensionalTranspose&&!(!T(n.multidimensionalDefinition)&&!n.transposedVariableName))&&(n=this.normalizeRasterFetchOptions(n)).multidimensionalDefinition==null)return{location:t,value:null};let o=this.multidimensionalSubset?.areaOfInterest;if(o&&!o.contains(t))throw new p(`imagery-tile-mixin:identify`,`the request cannot be fulfilled when falling outside of the multidimensional subset`);let s;if(this.serviceRasterInfo?.storageInfo.isBsqTile){let e=V(r)?this.getRawDisplayBandIds():this.bandIds;s=e?.length?e:void 0}return r.identify(t,{...n,bandIds:s})}hasStandardTime(){let e=this.serviceRasterInfo?.multidimensionalInfo;if(e==null||this.serviceRasterInfo?.dataType!==`standard-time`)return!1;let t=this.multidimensionalDefinition,n=t?.[0]?.variableName;return e.variables.some(e=>e.name===n&&(!t?.[0].dimensionName||e.dimensions.some(e=>e.name===`StdTime`)))}getStandardTimeValue(e){return new Date(A(e)).toISOString()}getMultidimensionalSubsetVariables(e){let t=e??this.serviceRasterInfo?.multidimensionalInfo;return O(this.multidimensionalSubset,t)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||=E(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset}),this.rasterFunction&&V(this.raster)&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}async _initJobHandler(){if(!this._rasterJobHandler)return super._initJobHandler().then(async()=>{if(!this._rasterJobHandler)return;m(this);let{raster:e}=this;e.rasterJobHandler=this._rasterJobHandler,V(e)&&e.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch(()=>{}),this.renderer&&this.updateRenderer()}).catch(()=>{})}_shutdownJobHandler(){super._shutdownJobHandler(),this.raster&&(this.raster.rasterJobHandler=null)}async _getSampleLocations(t){let{geometry:r}=t;if(r.type===`point`)return[r];let{spatialReference:i,type:a}=r;if(a===`multipoint`)return r.points.map(t=>new e({x:t[0],y:t[1],spatialReference:i}));if(a===`polyline`){let a=r;if(t.sampleCount||t.sampleDistance){let e=await n(()=>import(`./densifyOperator-BuecAwvo.js`),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11])),i=(await n(async()=>{let{execute:e}=await import(`./lengthOperator-CDbTNtoR.js`);return{execute:e}},__vite__mapDeps([14,1,2,3,4,5,6,7,8,15,10,11]))).execute(r,{unit:`meters`}),o=Math.min(t.sampleCount||100,X),s=t.sampleDistance;s||=i/(o+(a.paths[0].length===2?1:0)),a=e.execute(r,s,{unit:`meters`})}return a.paths.flatMap(t=>t.map(t=>new e({x:t[0],y:t[1],spatialReference:i})))}let o=Math.min(t.sampleCount||100,X),s=r.type===`extent`,c=s?r:r.extent,l=Math.sqrt(c.width*c.height/o),u=c.height/l,d=c.width/l,{xmin:f,ymax:p}=c,m=[];for(let t=0;t<u;t++)for(let n=0;n<d;n++){let a=new e({x:f+(n+.5)*l,y:p-(t+.5)*l,spatialReference:i});(s||r.contains(a))&&m.push(a)}return m}_configDefaultInterpolation(){if(this.interpolation==null){m(this);let{raster:e}=this,t=ne(e.rasterInfo,e.tileType,this.sourceJSON?.defaultResamplingMethod);this._set(`interpolation`,t)}}_configDefaultRenderer(e=`no`){m(this);let{rasterInfo:t}=this.raster,n=N(t,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset})?.name,r=ie({variableName:n,rasterFunctionName:this.rasterFunction?.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&t.bandCount>1&&(this.bandIds=r?.bandIds??ue(t)),!this.renderer||e===`override`){let e=re(this.raster),i=r?.renderer??oe(t,{bandIds:this.bandIds,variableName:n,rasterFunctionColorRamp:e}),a=t.statistics,o=a&&a.length>0?a[0]:null,s=o?.max??0,c=o?.min??0;this.raster.datasetFormat===`WCSServer`&&i.type===`raster-stretch`&&(s>1e24||c<-1e24)&&(i.dynamicRangeAdjustment=!0,i.customStatistics=null,i.stretchType===`none`&&(i.stretchType=`min-max`)),this.renderer=i}let i=se({...this.renderer.toJSON(),variableName:n}),a=pe(t,n);this.symbolizer?(this.symbolizer.rendererJSON=i,this.symbolizer.rasterInfo=a):this.symbolizer=new L({rendererJSON:i,rasterInfo:a});let o=this.symbolizer.bind();if(o.success){if(e===`auto`){let{colormap:e}=this.raster.rasterInfo,t=this.renderer;if(e!=null&&t.type===`raster-colormap`){let e=oe(this.raster.rasterInfo);JSON.stringify(e)!==JSON.stringify(t)&&this._configDefaultRenderer(`override`)}else if(t.type===`raster-stretch`){let e=this.bandIds?.length,n=t.customStatistics?.length;!t.dynamicRangeAdjustment&&n&&e&&n!==e&&this._configDefaultRenderer(`override`)}}}else x.getLogger(this).warn(`imagery-tile-mixin`,o.error||`The given renderer is not supported by the layer.`),e===`auto`&&this._configDefaultRenderer(`override`)}async _updateRasterFunction(){if(this._isConstructedFromFunctionRaster&&V(this.raster)){let e=this.raster.rasterFunction.toJSON();!this.rasterFunction&&e&&this._set(`rasterFunction`,me.fromJSON(e));return}let e,t=this.raster,n=!1;V(t)?(e=t.primaryRasters.rasters,t=e[0],n=!0):e=[t];let{rasterFunction:r}=this;if(r){let n={raster:t};e.length>1&&e.forEach(e=>n[e.url]=e);let i=Ne(r.functionDefinition?.toJSON()??r.toJSON(),n),a=new Y({rasterFunction:i});a.rasterJobHandler=this._rasterJobHandler,await a.open(),this.raster=a}else this.raster=t,await t.open();if(this._cachedRendererJson=void 0,!n&&!r)return;let{bandIds:i}=this,{bandCount:a}=this.raster.rasterInfo,o=i?.length?i.some(e=>e>=a):a>=3;i&&(o||this.renderer&&this.renderer.type!==`raster-stretch`)&&this._set(`bandIds`,null),this._configDefaultRenderer(`auto`)}_convertRasterIdentifyResultToSample(e,t){let{rasterInfo:n}=this.raster,r=n.storageInfo.pyramidScalingFactor**(e.pyramidLevel??0),i=(n.pixelSize.x+n.pixelSize.y)/2*r;if(!e.dataSeries?.length)return[new de({location:e.location,pixelValue:e.value,locationId:t,resolution:i})];let a=[];return e.dataSeries.forEach(({value:n,multidimensionalDefinition:r},o)=>{let s={Variables:r[0].variableName,Dimensions:r.flatMap(({dimensionName:e})=>e).join(`,`)};for(let{dimensionName:e,values:t}of r){s[e]=Array.isArray(t[0])?t[0][0]:t[0];let n=t[t.length-1];s[`${e}_Max`]=Array.isArray(n)?n[n.length-1]:n}let c=new de({location:e.location,pixelValue:n,rasterId:o,locationId:t,resolution:i,attributes:s});a.push(c)}),a}};function m(e){if(!e.raster||!e.serviceRasterInfo)throw new p(`imagery-tile`,`no raster`)}return t([o({clonable:!1})],d.prototype,`_cachedRasterFunctionJson`,void 0),t([o({clonable:!1})],d.prototype,`_compatibleFullExtent`,void 0),t([o({clonable:!1})],d.prototype,`_isConstructedFromFunctionRaster`,void 0),t([o({clonable:!1})],d.prototype,`_rasterFunctionUpdatePromise`,void 0),t([o({type:[S],json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType===`Raster`||this.bandIds?.join(`,`)!==`0,1,2`}}}}})],d.prototype,`bandIds`,void 0),t([o({json:{origins:{service:{read:{source:`copyrightText`}}}}})],d.prototype,`copyright`,void 0),t([o({json:{read:!1}})],d.prototype,`fullExtent`,null),t([o({json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType===`Raster`||this.interpolation!==`bilinear`}}}}}),i(F)],d.prototype,`interpolation`,void 0),t([o()],d.prototype,`ioConfig`,void 0),t([o({type:[k],json:{write:!0}})],d.prototype,`multidimensionalDefinition`,null),t([o({type:ee,json:{write:!0}})],d.prototype,`multidimensionalSubset`,void 0),t([o()],d.prototype,`raster`,void 0),t([o({type:me})],d.prototype,`rasterFunction`,null),t([o()],d.prototype,`serviceRasterInfo`,void 0),t([o()],d.prototype,`sourceJSON`,void 0),t([o({readOnly:!0,type:f,json:{read:!1}})],d.prototype,`spatialReference`,void 0),t([o({type:g})],d.prototype,`tileInfo`,void 0),t([o(y)],d.prototype,`url`,null),t([o()],d.prototype,`renderer`,null),t([o({types:fe,json:{name:`layerDefinition.drawingInfo.renderer`,write:{overridePolicy(){let e=this.renderer?.type===`raster-stretch`&&this.renderer.stretchType===`none`&&!this.renderer.useGamma;return{enabled:!this.loaded||this.raster.tileType===`Raster`||!e}}},origins:{"web-scene":{types:te,name:`layerDefinition.drawingInfo.renderer`,write:{overridePolicy:e=>({enabled:e&&e.type!==`vector-field`})}}}}})],d.prototype,`internalRenderer`,null),t([r(`internalRenderer`)],d.prototype,`readRenderer`,null),t([o({clonable:!1})],d.prototype,`symbolizer`,void 0),d=t([_(`esri.layers.mixins.ImageryTileMixin`)],d),d};function Z(e,t){if(!e||!t)return[];let n=t;t.includes(`/`)?(n=t.slice(0,t.indexOf(`/`)),t=t.slice(t.indexOf(`/`)+1)):t=``;let r=[];if(t){let i=Z(e,n);for(let e=0;e<i.length;e++)Z(i[e],t).forEach(e=>r.push(e));return r}let i=e.getElementsByTagNameNS(`*`,n);if(!i||i.length===0)return[];for(let e=0;e<i.length;e++)r.push(i[e]||i.item(e));return r}function Q(e,t){if(!e||!t)return null;let n=t;t.includes(`/`)?(n=t.slice(0,t.indexOf(`/`)),t=t.slice(t.indexOf(`/`)+1)):t=``;let r=Z(e,n);return r.length>0?t?Q(r[0],t):r[0]:null}function $(e,t=null){let n=t?Q(e,t):e,r;return n?(r=n.textContent||n.nodeValue,r?r.trim():null):null}function He(e,t){let n=Z(e,t),r=[],i;for(let e=0;e<n.length;e++)i=n[e].textContent||n[e].nodeValue,i&&(i=i.trim(),i!==``&&r.push(i));return r}function Ue(e,t=null){return $(e,t)?.split(` `).map(e=>Number(e))??[]}function We(e,t){return He(e,t).map(e=>Number(e))}function Ge(e,t){let n=$(e,t);return Number(n)}function Ke(e,t){let n=e?.nodeName?.toLowerCase(),r=t.toLowerCase();return n.slice(n.lastIndexOf(`:`)+1)===r}function qe(e){return e.nodeName.slice(e.nodeName.lastIndexOf(`:`)+1)}export{Z as a,$ as c,Y as d,J as f,He as i,We as l,Q as n,Ge as o,Ke as r,Ue as s,qe as t,Ve as u};
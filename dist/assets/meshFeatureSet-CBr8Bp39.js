import{ET as e,Id as t,Pa as n,Sx as r,Ux as i,hr as a,vE as o}from"./index-BqmCqmfp.js";import"./quatf64-CJzmL3cc.js";import"./quat-Bk_ZaVz9.js";import"./axisAngleDegrees-Di7q97jx.js";import"./meshCloneUtils-Akm6YUJV.js";import"./MeshMaterialMetallicRoughness-BUsirHC6.js";import"./meshProperties-Du90n6lL.js";import"./MeshComponent--ctdPfFQ.js";import{t as s}from"./Mesh-CUHzTZdQ.js";import"./MeshLocalVertexSpace-HjmVAuYa.js";import"./MeshTransform-B2p38eYR.js";import"./MeshVertexAttributes-Df5_8xlW.js";import"./meshVertexSpaceUtils-Y8FeTLov.js";import"./earcut-Drx511Ix.js";import"./Indices-BsTLKVdx.js";import"./vectorStacks-CKtslZxP.js";import"./plane-CTjDePZl.js";import"./triangulationUtils-BJbNyOeM.js";import"./deduplicate-BuZ0DaaO.js";import"./projectPointToVector-Clou1sfo.js";import"./computeTranslationToOriginAndRotation-BC3OuSky.js";import"./BufferView-DNaZpbJX.js";import"./Util-3rPi0NfK.js";import"./vec3-40WN6G4a.js";import"./vec4-CcFo8HF1.js";import"./vertexSpaceConversion-g9XG_RJW.js";import"./spatialReferenceEllipsoidUtils-DBtdxVkA.js";import{a as c,r as l}from"./External-Cyg8cgWj.js";import{n as u,t as d}from"./meshFeatureAttributes-DKUFwpcn.js";var f=()=>o.getLogger(`esri.rest.support.meshFeatureSet`);function p(e,r,a){let o=a.features;a.features=[],delete a.geometryType;let s=n.fromJSON(a);if(s.geometryType=`mesh`,!a.assetMaps)return s;let c=g(r,a.assetMaps),l=e.sourceSpatialReference??i.WGS84,u=a.globalIdFieldName,{outFields:d}=e,f=d!=null&&d.length>0?m(d.includes(`*`)?null:new Set(d)):()=>({});for(let e of o){let n=h(e,u,l,r,c);s.features.push(new t({geometry:n,attributes:f(e)}))}return s}function m(e){return({attributes:t})=>{if(!t)return{};if(!e)return t;for(let n in t)e.has(n)||delete t[n];return t}}function h(e,t,n,i,a){let o=e.attributes[t],c=a.get(o);if(c==null||!e.geometry)return null;let l=u(e.attributes,n,i.transformFieldRoles),f=r.fromJSON(e.geometry);f.spatialReference=n;let p=d(e.attributes,i.transformFieldRoles),m=n.isGeographic?`local`:`georeferenced`,h=_(c);return h?s.createWithExternalSource(l,h,{extent:f,transform:p,vertexSpace:m,unitConversionDisabled:!0}):s.createIncomplete(l,{extent:f,transform:p,vertexSpace:m})}function g(t,n){let r=new Map;for(let i of n){let n=i.parentGlobalId;if(n==null)continue;let o=i.assetName,s=i.assetType,c=i.assetHash,l=i.assetURL,u=i.conversionStatus,d=i.seqNo,p=a(s,t.supportedFormats);if(!p){f().error(`mesh-feature-set:unknown-format`,`Service returned an asset of type ${s}, but it does not list it as a supported type`);continue}let m=e(r,n,()=>({files:new Map}));e(m.files,o,()=>({name:o,type:s,mimeType:p,status:v(u),parts:[]})).parts[d]={hash:c,url:l}}return r}function _(e){let t=Array.from(e.files.values()),n=[];for(let e of t){if(e.status!==2)return null;let t=[];for(let n of e.parts){if(!n)return null;t.push(new c(n.url,n.hash))}n.push(new l(e.name,e.mimeType,t))}return{type:`service`,assets:n}}function v(e){switch(e){case`COMPLETED`:case`SUBMITTED`:return 2;case`INPROGRESS`:return 1;default:return 0}}export{g as assetMapFromAssetMapsJSON,h as extractMesh,p as meshFeatureSetFromJSON};
import{Ax as e,CD as t,Kv as n,MC as r,Mm as i,Qw as a,Rx as o,TC as s,Ux as c,Zv as l,_E as u,aS as d,gg as f,kC as p,lC as m,rT as h,sD as g,sy as _,ty as v,uT as y,vE as b,yg as x,zv as S}from"./index-BqmCqmfp.js";import{t as C}from"./GeometryDescriptor-BAsgbvB_.js";var w=class{constructor(e,t){this.layer=e,this.parameters=t}},ee=class extends w{constructor(e,t,n){super(e,n),this.outSpatialReference=t,this.type=`geometry`}selectTilesAtLOD(e){if(e<0)this.geometry.coordinates.forEach(e=>e.tile=null);else{let{tileInfo:t,tilemapCache:n}=this.layer,r=D(t,n)[e].level;this.geometry.coordinates.forEach(e=>e.tile=t.tileAt(r,e.x,e.y))}}allElevationTilesFetched(){return!this.geometry.coordinates.some(e=>!e.elevationTile)}clearElevationTiles(){for(let e of this.geometry.coordinates)e.elevationTile!==this.outsideExtentTile&&(e.elevationTile=null)}populateElevationTiles(e){for(let t of this.geometry.coordinates)!t.elevationTile&&t.tile?.id&&(t.elevationTile=e[t.tile.id])}remapTiles(e){for(let t of this.geometry.coordinates){let n=t.tile?.id;t.tile=n?e[n]:null}}getTilesToFetch(){return g(this.geometry.coordinates.filter(({tile:e,elevationTile:t})=>e?.id&&!t),(e,t)=>e.tile?.id===t.tile?.id).map(({tile:e})=>e)}forEachTileToFetch(e){for(let t of this.geometry.coordinates)t.tile&&!t.elevationTile&&e(t.tile,()=>t.tile=null)}},T=class extends w{constructor(e,t,n,r){super(e,n),this.maskExtents=r,this.type=`extent`,this.elevationTiles=[],this._candidateTiles=[],this._fetchedCandidates=new Set,this.extent=t.clone().intersection(e.fullExtent)}selectTilesAtLOD(e,t){let n=this._maximumLodForRequests(t),r=Math.min(n,e);r<0?this._candidateTiles.length=0:this._selectCandidateTilesCoveringExtentAt(r)}_maximumLodForRequests(e){let{tileInfo:t,tilemapCache:n}=this.layer,r=D(t,n);if(!e)return r.length-1;let i=this.extent;if(i==null)return-1;for(let n=r.length-1;n>=0;n--){let a=r[n],o=a.resolution*t.size[0],s=a.resolution*t.size[1];if(Math.ceil(i.width/o)*Math.ceil(i.height/s)<=e)return n}return-1}allElevationTilesFetched(){return this._candidateTiles.length===this.elevationTiles.length}clearElevationTiles(){this.elevationTiles.length=0,this._fetchedCandidates.clear()}populateElevationTiles(e){for(let t of this._candidateTiles){let n=t.id&&e[t.id];n&&(this._fetchedCandidates.add(t),this.elevationTiles.push(n))}}remapTiles(e){this._candidateTiles=O(this._candidateTiles.map(t=>e[t.id]))}getTilesToFetch(){return this._candidateTiles}forEachTileToFetch(e,t){let n=this._candidateTiles;this._candidateTiles=[],n.forEach(n=>{if(this._fetchedCandidates.has(n))return void t?.(n);let r=!1;e(n,()=>r=!0),r?t?.(n):this._candidateTiles.push(n)}),this._candidateTiles=O(this._candidateTiles,t)}_selectCandidateTilesCoveringExtentAt(e){this._candidateTiles.length=0;let t=this.extent;if(t==null)return;let{tileInfo:n,tilemapCache:r}=this.layer,a=D(n,r)[e],o=n.tileAt(a.level,t.xmin,t.ymin),s=o.extent,c=a.resolution*n.size[0],l=a.resolution*n.size[1],u=Math.ceil((t.xmax-s[0])/c),d=Math.ceil((t.ymax-s[1])/l);for(let e=0;e<d;e++)for(let t=0;t<u;t++){let r=new i(o.level,o.row-e,o.col+t);n.updateTileInfo(r),this._tileIsMasked(r)||this._candidateTiles.push(r)}}_tileIsMasked(e){return this.maskExtents?.some(t=>_(t,e.extent))??!1}};function E(e){return e?.tileInfo!=null}function D(e,t){let n=e.lods;if(E(t)){let{effectiveMinLOD:e,effectiveMaxLOD:r}=t;return n.filter(t=>t.level>=e&&t.level<=r)}return n}function O(e,t){let n={},r=[];for(let i of e){let e=i.id;e&&!n[e]?(n[e]=i,r.push(i)):t?.(i)}let i=r.sort((e,t)=>e.level-t.level);return i.filter((e,n)=>{for(let r=0;r<n;r++){let n=i[r].extent;if(n&&_(n,e.extent))return t?.(e),!1}return!0})}var k=class{constructor(e,t){this.data=e,this.safeWidth=.99999999*(e.width-1),this.dx=(e.width-1)/(t[2]-t[0]),this.dy=(e.width-1)/(t[3]-t[1]),this.x0=t[0],this.y1=t[3]}},A=class{constructor(e,t=null){if(this.key=e,t!=null){let n=e.extent;this._samplerData=new k(t,n)}}get zmin(){return this._samplerData==null?0:this._samplerData.data.minValue}get zmax(){return this._samplerData==null?0:this._samplerData.data.maxValue}get hasNoDataValues(){return!!this._samplerData?.data.hasNoDataValues}sample(e,t){if(this._samplerData==null)return;let{safeWidth:n,data:r,dx:i,dy:a,y1:o,x0:s}=this._samplerData,{width:c,values:l,noDataValue:u}=r,d=j(a*(o-t),0,n),f=j(i*(e-s),0,n),p=Math.floor(d),m=Math.floor(f),h=p*c+m,g=h+c,_=l[h],v=l[g],y=l[h+1],b=l[g+1];if(_!==u&&v!==u&&y!==u&&b!==u){let e=f-m,t=_+(y-_)*e;return t+(v+(b-v)*e-t)*(d-p)}}};function j(e,t,n){return e<t?t:e>n?n:e}var M=class extends s{queryElevation(e){let t=this.projectIfRequired(e,this.spatialReference);if(!t)return null;switch(e.type){case`point`:return N(e,t,this);case`polyline`:return P(e,t,this);case`multipoint`:return F(e,t,this);default:return null}}projectIfRequired(e,t){if(e==null)return null;let n=e.spatialReference;if(n.equals(t))return e;let r=o(e,t);return r||b.getLogger(this).error(`Cannot project geometry spatial reference (wkid:${n.wkid}) to elevation sampler spatial reference (wkid:${t.wkid})`),r}};function N(e,t,n){return e.hasZ=!0,e.z=n.elevationAt(t.x,t.y),e}function P(e,t,n){I.spatialReference=t.spatialReference;let r=e.hasM&&!e.hasZ;for(let i=0;i<e.paths.length;i++){let a=e.paths[i],o=t.paths[i];for(let e=0;e<a.length;e++){let t=a[e],i=o[e];I.x=i[0],I.y=i[1],r&&(t[3]=t[2]),t[2]=n.elevationAt(I.x,I.y)}}return e.hasZ=!0,e}function F(e,t,n){I.spatialReference=t.spatialReference;let r=e.hasM&&!e.hasZ;for(let i=0;i<e.points.length;i++){let a=e.points[i],o=t.points[i];I.x=o[0],I.y=o[1],r&&(a[3]=a[2]),a[2]=n.elevationAt(I.x,I.y)}return e.hasZ=!0,e}M=t([p(`esri.layers.support.ElevationSampler`)],M);var I=new e,L=class extends M{get spatialReference(){return this.extent.spatialReference}constructor(e){let t=e.noDataValue,r=`tiles`in e?e.tiles.map(n=>new R({tile:n,tileInfo:e.tileInfo,noDataValue:t})):e.samplers;super({noDataValue:t,samplers:r});let i=r[0];if(i){this.extent=i.extent.clone();let{min:e,max:t}=i.demResolution;this.demResolution={min:e,max:t};for(let e=1;e<r.length;e++){let t=r[e];this.extent.union(t.extent),this.demResolution.min=Math.min(this.demResolution.min,t.demResolution.min),this.demResolution.max=Math.max(this.demResolution.max,t.demResolution.max)}}else{let t=`tileInfo`in e?e.tileInfo:null;this.extent=n(l(),t?.spatialReference??c.WGS84),this.demResolution={min:0,max:0}}}elevationAt(e,t){let n;for(let r of this.samplers)if(r.containsAt(e,t)&&(n=r.elevationAt(e,t),n!==r.noDataValue))return n;return n??(b.getLogger(this).warn(`#elevationAt()`,`Point used to sample elevation (${e}, ${t}) is outside of the sampler`),this.noDataValue)}};t([r({constructOnly:!0})],L.prototype,`noDataValue`,void 0),t([r({constructOnly:!0})],L.prototype,`samplers`,void 0),L=t([p(`esri.layers.support.TileElevationSampler`)],L);var R=class extends M{get spatialReference(){return this.extent.spatialReference}constructor(e){super(e);let t=e.tile.key.extent;this.extent=n(t,e.tileInfo.spatialReference),this.extent.zmin=e.tile.zmin,this.extent.zmax=e.tile.zmax;let r=d(e.tileInfo.spatialReference),i=e.tileInfo.lodAt(e.tile.key.level).resolution*r;this.demResolution={min:i,max:i}}contains(e){let t=this.projectIfRequired(e,this.spatialReference);return t!=null&&this.containsAt(t.x,t.y)}containsAt(e,t){return S(this.tile.key.extent,e,t)}elevationAt(e,t){return this.containsAt(e,t)?this.tile.sample(e,t)??this.noDataValue:this.noDataValue}};t([r({constructOnly:!0})],R.prototype,`tile`,void 0),t([r({constructOnly:!0})],R.prototype,`noDataValue`,void 0),t([r({constructOnly:!0})],R.prototype,`tileInfo`,void 0),R=t([p(`esri.layers.support.TileElevationSampler.SingleTileElevationSampler`)],R);async function z(e,t,n){if(e=n?.ignoreInvisibleLayers?e.filter(e=>e.visible):e.slice(),!e.length)throw new u($,`Elevation queries require at least one elevation layer to fetch tiles from`);let r=C.fromGeometry(t),i={...Z,...n,returnSampleInfo:!0},a=e.pop(),o=await B(a,r,i),s=await W(e,o,i);return s.geometry=s.geometry.export(),n?.returnSampleInfo||delete s.sampleInfo,s}async function B(e,t,n){if(!e)throw new u($,`Elevation queries require an elevation layer to fetch tiles from`);if(!t||!(t instanceof C)&&t.type!==`point`&&t.type!==`multipoint`&&t.type!==`polyline`)throw new u(`elevation-query:invalid-geometry`,`Only point, polyline and multipoint geometries can be used to query elevation`);let r={...Z,...n},i=new ee(e,t.spatialReference,r),a=r.signal;return await e.load({signal:a}),await te(i,t,a),await G(i,a),await Q(i,a),se(i),ce(i,a)}async function V(e,t,n){if(e=Array.isArray(e)?e:[e],(e=n?.ignoreInvisibleLayers?e.filter(e=>e.visible):e.slice()).length===0)throw new u($,`Elevation queries require at least one elevation layer to fetch tiles from`);if(!t||t.type!==`extent`)throw new u(`elevation-query:invalid-extent`,`Invalid or undefined extent`);let r={...Z,...n,returnSampleInfo:!0},i=H(e[e.length-1],t,r);return e.length===1?i:U(e,t,await i,r)}async function H(e,t,n,r){let i=n.signal;await e.load({signal:i});let a=t.spatialReference,o=e.tileInfo.spatialReference;a.equals(o)||(await f([{source:a,dest:o}],{signal:i}),t=x(t,o));let s=new T(e,t,n,r);await G(s,i),await Q(s,i);let c=s.elevationTiles,l=s.layer.tileInfo,u=s.parameters.noDataValue;return new L({noDataValue:u,tiles:c,tileInfo:l})}async function U(e,t,n,r){if(e.pop(),!e.length)return n;let i=n.samplers.filter(e=>!e.tile.hasNoDataValues).map(e=>v(e.extent)),a=await H(e[e.length-1],t,r,i);if(a.samplers.length===0)return n;let o=n.samplers.concat(a.samplers),s=r.noDataValue;return U(e,t,new L({samplers:o,noDataValue:s}),r)}async function W(e,t,n){let r=t.geometry.coordinates,i=t.sampleInfo;y(i);let a=[],o=[];for(let t=0;t<r.length;t++)i[t].demResolution<0&&e.length&&(a.push(r[t]),o.push(t));let s=e.pop();if(s==null||a.length===0)return t;let c=t.geometry.clone(a),l=await B(s,c,n),u=l.sampleInfo;if(!u)throw Error(`no sampleInfo`);return o.forEach((e,t)=>{r[e].z=l.geometry.coordinates[t].z,i[e].demResolution=u[t].demResolution,i[e].source=u[t].source}),W(e,t,n)}async function G(e,t){e.type===`geometry`&&ne(e);let n=e.parameters.demResolution;if(typeof n==`number`)ie(e,n);else if(n===`finest-contiguous`)await K(e,t);else{if(n!==`auto`)throw new u(`elevation-query:invalid-dem-resolution`,`Invalid dem resolution value '${n}', expected a number, "finest-contiguous" or "auto"`);await J(e,t)}}async function K(e,t){let{tileInfo:n,tilemapCache:r}=e.layer,i=X(n,r,e.parameters.minDemResolution);await q(e,i,t)}async function q(e,t,n){let r=e.layer;if(e.selectTilesAtLOD(t),t<0)return;let i=r.tilemapCache,o=e.getTilesToFetch();try{if(i&&!E(i))await h(Promise.all(o.map(e=>i.fetchAvailability(e.level,e.row,e.col,{signal:n}))),n);else if(await Q(e,n),!e.allElevationTilesFetched())throw e.clearElevationTiles(),new u(`elevation-query:has-unavailable-tiles`,`Some elevation tiles are unavailable`)}catch(r){a(r),await q(e,t-1,n)}}async function J(e,t){ae(e),oe(e);let n=e.layer.tilemapCache;if(!n||E(n))return Y(e,t);let r=e.getTilesToFetch(),o={},s=r.map(async e=>{let r=new i(0,0,0),s=await m(n.fetchAvailabilityUpsample(e.level,e.row,e.col,r,{signal:t}));!1===s.ok?a(s.error):e.id!=null&&(o[e.id]=r)});await h(Promise.all(s),t),e.remapTiles(o)}async function Y(e,t){let n=e.layer.tileInfo;await Q(e,t);let r=!1;e.forEachTileToFetch((e,t)=>{n.upsampleTile(e)?r=!0:t()}),r&&await Y(e,t)}function X(e,t,n=0){let r=D(e,t),i=r.length-1;if(n>0){let t=n/d(e.spatialReference),a=r.findIndex(e=>e.resolution<t);a===0?i=0:a>0&&(i=a-1)}return i}var Z={maximumAutoTileRequests:20,noDataValue:0,returnSampleInfo:!1,demResolution:`auto`,minDemResolution:0,signal:null};async function te(e,t,n){let r,i=e.layer.tileInfo.spatialReference;if(t instanceof C?r=await t.project(i,n):(await f([{source:t.spatialReference,dest:i}],{signal:n}),r=x(t,i)),!r)throw new u(`elevation-query:spatial-reference-mismatch`,`Cannot query elevation in '${t.spatialReference.wkid}' on an elevation service in '${i.wkid}'`);e.geometry=C.fromGeometry(r)}function ne(e){if(e.layer.fullExtent==null)return;let t=new A(new i(-1,-1,-1));t.sample=()=>e.parameters.noDataValue,e.outsideExtentTile=t;let n=e.layer.fullExtent;e.geometry.coordinates.forEach(e=>{let r=e.x,i=e.y;(r<n.xmin||r>n.xmax||i<n.ymin||i>n.ymax)&&(e.elevationTile=t)})}function re(e,t){let{tileInfo:n,tilemapCache:r}=e.layer,i=t/d(n.spatialReference),a=D(n,r),o=a[0],s=0;for(let e=1;e<a.length;e++){let t=a[e];Math.abs(t.resolution-i)<Math.abs(o.resolution-i)&&(o=t,s=e)}return s}function ie(e,t){let n=re(e,t);e.selectTilesAtLOD(n)}function ae(e){let{tileInfo:t,tilemapCache:n}=e.layer,r=X(t,n,e.parameters.minDemResolution);e.selectTilesAtLOD(r,e.parameters.maximumAutoTileRequests)}async function Q(e,t){let n=e.getTilesToFetch(),r={},i=e.parameters.cache,a=e.parameters.noDataValue,o={noDataValue:a,signal:t},s=n.map(async t=>{if(t.id==null)return;let n=`${e.layer.uid}:${t.id}:${a}`,s=i?.get(n)??await e.layer.fetchTile(t.level,t.row,t.col,o);i?.put(n,s),r[t.id]=new A(t,s)});await h(Promise.allSettled(s),t),e.populateElevationTiles(r)}function oe(e){let t=e.layer.tileInfo,n=0,r={},i=e=>{e.id!=null&&(e.id in r?r[e.id]++:(r[e.id]=1,n++))},a=e=>{if(e.id==null)return;let t=r[e.id];t===1?(delete r[e.id],n--):r[e.id]=t-1};e.forEachTileToFetch(i,a);let o=!0;for(;o&&(o=!1,e.forEachTileToFetch(r=>{n<=e.parameters.maximumAutoTileRequests||(a(r),t.upsampleTile(r)&&(o=!0),i(r))},a),o););}function se(e){e.geometry.coordinates.forEach(t=>{let n=t.elevationTile,r=e.parameters.noDataValue;if(n){let e=n.sample(t.x,t.y);e==null?t.elevationTile=null:r=e}t.z=r})}async function ce(e,t){let n=await e.geometry.project(e.outSpatialReference,t);y(n);let r={geometry:n.export(),noDataValue:e.parameters.noDataValue};return e.parameters.returnSampleInfo&&(r.sampleInfo=le(e)),e.geometry.coordinates.forEach(e=>{e.tile=null,e.elevationTile=null}),r}function le(e){let t=e.layer.tileInfo,n=d(t.spatialReference);return e.geometry.coordinates.map(r=>{let i=-1;return r.elevationTile&&r.elevationTile!==e.outsideExtentTile&&(i=t.lodAt(r.elevationTile.key.level).resolution*n),{demResolution:i,source:i===-1?void 0:e.layer}})}var $=`elevation-query:invalid-layer`;export{$ as InvalidLayerError,V as createSampler,Z as defaultOptions,X as getFinestLodIndex,B as query,z as queryAll};
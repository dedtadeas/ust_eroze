import{wD as e,xD as t}from"./index-BqmCqmfp.js";import{n}from"./SimpleGeometryCursor-CI9GIWKa.js";import{Dt as r,I as i,Qt as a,cn as o,dn as s,fn as c,gn as l,gt as u,in as d,kt as f,ln as p,st as m,un as h,vn as g,wn as _,x as v,yn as y}from"./Point2D-UYEfE6HP.js";import{t as b}from"./Envelope2D-BNwQDrOT.js";import{En as x,Jt as S,On as C,Qt as w,S as T,_n as E,cn as D,et as O,kn as k,nn as A,on as j,pn as M,qt as N,s as P,sn as F}from"./UnitFactory-J9WMNXdY.js";import{t as I}from"./Transformation2D-DVoPQwGC.js";import{t as L}from"./OperatorSimplifyOGC-r9P7gVey.js";import{t as R}from"./GeometryCleaner-BEJM7I4l-DybJvg8-.js";import{t as z}from"./OperatorGeneralize-Ce-8cGyg.js";var B;function V(e,t,n,r,i,a){return{m_from:e.clone(),m_to:t.clone(),m_center:n.clone(),m_next:i,m_type:r}}function H(e,t,n,r,i){return{m_from:e.clone(),m_to:t.clone(),m_next:n,m_type:4,m_center:new f}}(function(e){e[e.enumDummy=256]=`enumDummy`,e[e.enumLine=1]=`enumLine`,e[e.enumArc=2]=`enumArc`,e[e.enumMiter=8]=`enumMiter`,e[e.enumBevel=16]=`enumBevel`,e[e.enumJoinMask=26]=`enumJoinMask`,e[e.enumConnectionMask=27]=`enumConnectionMask`})(B||={});var U=class extends n{constructor(e,t,n,r,i,a,o,s,c,l){super(),this.m_index=0,this.m_bufferedPolygon=null,this.m_x=0,this.m_y=0,this.m_progressTracker=l,this.m_parent=e,this.m_mp=t,this.m_distance=n,this.m_spatialReference=r,this.m_densifyDist=s,this.m_maxVertexInCompleteCircle=c,this.m_joins=i,this.m_caps=a,this.m_miterLimit=o}next(){let e=new x;for(;;){if(this.m_index===this.m_mp.getPointCount())return null;if(this.m_caps===1)return this.m_index=this.m_mp.getPointCount(),new F({vd:this.m_mp.getDescription()});if(this.m_mp.getPointByVal(this.m_index,e),this.m_index++,!e.isEmpty())break}let t,n=!1;if(this.m_bufferedPolygon===null&&(this.m_x=e.getX(),this.m_y=e.getY(),this.m_bufferedPolygon=this.m_parent.buffer(e,this.m_distance,this.m_spatialReference,this.m_joins,this.m_caps,this.m_miterLimit,this.m_densifyDist,this.m_maxVertexInCompleteCircle),n=!0),t=this.m_index<this.m_mp.getPointCount()?this.m_bufferedPolygon.clone():this.m_bufferedPolygon,!n){let n=new I,r=e.getX()-this.m_x,i=e.getY()-this.m_y;n.setShiftCoords(r,i),t.applyTransformation(n)}return C(t,0),t}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}},W=class extends n{constructor(e){super(),this.m_currentPathIndex=0,this.m_polyline=e}next(){if(!this.m_polyline)return null;let e=this.m_polyline.getImpl(),t=e.getPathCount();if(this.m_currentPathIndex<t){let t=this.m_currentPathIndex;if(this.m_currentPathIndex++,!e.isClosedPathInXYPlane(t)){let n=e.getXY(e.getPathEnd(t)-1);for(;this.m_currentPathIndex<e.getPathCount();){let t=e.getXY(e.getPathStart(this.m_currentPathIndex));if(e.isClosedPathInXYPlane(this.m_currentPathIndex)||!t.equals(n))break;n=e.getXY(e.getPathEnd(this.m_currentPathIndex)-1),this.m_currentPathIndex++}}if(t===0&&this.m_currentPathIndex===this.m_polyline.getPathCount()){let e=this.m_polyline;return this.m_polyline=null,e}let n=new N({vd:this.m_polyline.getDescription()});n.addPath(this.m_polyline,t,!0);for(let r=t+1;r<this.m_currentPathIndex;r++)n.addSegmentsFromPath(this.m_polyline,r,0,e.getSegmentCountPath(r),!1);return this.m_currentPathIndex===this.m_polyline.getPathCount()&&(this.m_polyline=null),n}return null}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}},G=class extends n{constructor(e,t,n){super(),this.m_geometry=null,this.m_index=0,this.m_bufferer=e,this.m_geoms=t,this.m_index=0,this.m_bFilter=n}next(){if(this.m_geometry===null&&(this.m_index=0,this.m_geometry=this.m_geoms.next(),!this.m_geometry))return null;let e=this.m_geometry.getImpl();if(this.m_index<e.getPathCount()){let e=this.m_index;return this.m_index++,this.m_bufferer.bufferPolylinePath(this.m_geometry,e,this.m_bFilter)}return this.m_geometry=null,this.next()}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}},K=class extends n{constructor(e){super(),this.m_index=0,this.m_bufferer=e}next(){let e=this.m_bufferer.m_geometry;if(this.m_index<e.getPathCount()){let t=this.m_index,n=e.calculateRingArea2D(this.m_index);for(g(n>0),this.m_index++;this.m_index<e.getPathCount()&&!(e.calculateRingArea2D(this.m_index)>0);)this.m_index++;let r;return r=t===0&&this.m_index===e.getPathCount()?this.m_bufferer.bufferPolygonImpl(e,0,e.getPathCount()):this.m_bufferer.bufferPolygonImpl(e,t,this.m_index),r}return null}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}},q=class{constructor(e){this.m_geometry=null,this.m_bufferCommands=[],this.m_originalGeomType=o.enumUnknown,this.m_maxVertexInCompleteCircle=-1,this.m_circleTemplateSize=-1,this.m_oldCircleTemplateSize=0,this.m_spatialReference=null,this.m_tolerance=new E(0,0),this.m_smallTolerance=new E(0,0),this.m_filterTolerance=0,this.m_densifyDist=-1,this.m_distance=NaN,this.m_absDistance=0,this.m_absDistanceReversed=0,this.m_dA=-1,this.m_miterLimit=4,this.m_joins=0,this.m_caps=0,this.m_bRoundBuffer=!0,this.m_bOutputLoops=!0,this.m_bFilter=!0,this.m_circleTemplate=[],this.m_leftStack=[],this.m_middleStack=[],this.m_helperLine1=new j,this.m_helperLine2=new j,this.m_helperArray=[],this.m_progressCounter=0,this.m_densificator=A.constructDefault(e),this.m_progressTracker=e}buffer(e,t,n,r,i,o,s,f){if(e||d(`Geometry.Bufferer.Impl.Buffer`),s<0&&d(`Geometry.Bufferer.Impl.Buffer`),c(e.getGeometryType())&&_(`Unsupported geometry type.`),e.isEmpty()||(this.m_joins=r,this.m_caps=i,this.m_bRoundBuffer=!1,this.m_miterLimit=o,this.m_originalGeomType=e.getGeometryType(),h(this.m_originalGeomType)?this.m_bRoundBuffer=this.m_joins===0:l(this.m_originalGeomType)?this.m_bRoundBuffer=this.m_caps===0:y(this.m_originalGeomType)&&(this.m_bRoundBuffer=this.m_joins===0&&this.m_caps===0),this.m_bFilter=this.m_bRoundBuffer,this.m_geometry=R(e),this.m_geometry.isEmpty()))return new F({vd:e.getDescription()});let p=new b;this.m_geometry.queryLooseEnvelope(p),t>0&&p.inflateCoords(t,t),this.m_tolerance=M(n,p,!0),this.m_smallTolerance=M(null,p,!0),f<=0&&(f=96),this.m_spatialReference=n,this.m_distance=t,this.m_absDistance=Math.abs(this.m_distance),this.m_absDistanceReversed=this.m_absDistance===0?0:1/this.m_absDistance,Number.isNaN(s)||s===0?s=1e-5*this.m_absDistance:s>.5*this.m_absDistance&&(s=.5*this.m_absDistance),f<12&&(f=12);let m=Math.abs(t)*(1-Math.cos(Math.PI/f));if(m>s)s=m;else if(t!==0){let e=Math.PI/Math.acos(1-s/Math.abs(t));e<f-1&&(f=Math.trunc(e))<12&&(f=12,s=Math.abs(t)*(1-Math.cos(Math.PI/f)))}this.m_densifyDist=s,this.m_maxVertexInCompleteCircle=f,this.m_filterTolerance=this.m_bRoundBuffer?Math.min(this.m_smallTolerance.total(),.25*this.m_densifyDist):0,this.m_circleTemplateSize=this.calcN(),this.m_circleTemplateSize!==this.m_oldCircleTemplateSize&&(this.m_circleTemplate.length=0,this.m_oldCircleTemplateSize=this.m_circleTemplateSize),this.m_densifyDist>0&&a(this.m_geometry)&&(this.m_geometry=this.m_densificator.densifyEx(this.m_geometry,0,this.m_densifyDist,0,this.m_joins!==0,u()));let g=this.bufferImpl();return this.m_geometry=null,g}generateCircleTemplate(){if(this.m_circleTemplate.length)return;let e=this.m_circleTemplateSize,t=Math.trunc((e+3)/4),n=.5*Math.PI/t;this.m_dA=n,this.m_circleTemplate=i(f,4*t);let r=Math.cos(n),a=Math.sin(n),o=f.construct(0,1);for(let e=0;e<t;e++)this.m_circleTemplate[e+0*t].setCoords(o.y,-o.x),this.m_circleTemplate[e+1*t].setCoords(-o.x,-o.y),this.m_circleTemplate[e+2*t].setCoords(-o.y,o.x),this.m_circleTemplate[e+3*t].setCoords(o.x,o.y),o.rotateReverse(r,a)}bufferImpl(){let e=this.m_geometry.getGeometryType();if(s(e)){let e=new N({vd:this.m_geometry.getDescription()});return e.addSegment(this.m_geometry,!0),this.m_geometry=e,this.bufferImpl()}if(this.m_distance<=this.m_tolerance.total()){if(!h(e))return new F({vd:this.m_geometry.getDescription()});if(this.m_distance<0){let e=new b;if(this.m_geometry.queryEnvelope(e),e.width()<=2*this.m_absDistance||e.height()<=2*this.m_absDistance)return new F({vd:this.m_geometry.getDescription()})}}switch(this.m_geometry.getGeometryType()){case o.enumPoint:return this.bufferPoint();case o.enumMultiPoint:return this.bufferMultiPoint();case o.enumPolyline:return this.bufferPolyline();case o.enumPolygon:return this.bufferPolygon();case o.enumEnvelope:return this.bufferEnvelope();default:p(``)}}bufferPolyline(){if(this.isDegenerateGeometry(this.m_geometry)){let e=new x;this.m_geometry.getPointByVal(0,e);let t=new b;return this.m_geometry.queryEnvelope(t),e.setXY(t.getCenter()),this.bufferDegeneratePath(e,!0)}let e=this.m_geometry,t=this.m_geometry.getDescription();this.m_geometry=null;let n=new W(e),r,i;r=this.m_joins===0?new z().executeMany(n,.25*this.m_densifyDist,!1,this.m_progressTracker):n,i=this.m_bRoundBuffer?new L().executeMany(r,null,!0,this.m_progressTracker):r;let a=new G(this,i,this.m_bFilter),o=new O().executeMany(a,this.m_spatialReference,this.m_progressTracker,2),s=new P().executeMany(o,this.m_spatialReference,!1,this.m_progressTracker).next();return s===null?new F({vd:t}):s}bufferPolygon(){if(this.m_distance===0)return this.m_geometry;this.generateCircleTemplate();let e=new P().execute(this.m_geometry,null,!1,this.m_progressTracker);if(this.m_distance<0){if(this.m_geometry=e,this.m_geometry.isEmpty())return this.m_geometry;let t=this.m_geometry,n=this.bufferPolygonImpl(t,0,t.getPathCount());return new P().execute(n,this.m_spatialReference,!1,this.m_progressTracker)}{if(this.m_geometry=e,this.isDegenerateGeometry(this.m_geometry)){let e=new x;this.m_geometry.getPointByVal(0,e);let t=new b;return this.m_geometry.queryEnvelope(t),e.setXY(t.getCenter()),this.bufferDegeneratePath(e,!0)}let t=new K(this),n=new O().executeMany(t,this.m_spatialReference,this.m_progressTracker,2),r=new P().executeMany(n,this.m_spatialReference,!1,this.m_progressTracker).next();return r===null?new F({vd:this.m_geometry.getDescription()}):r}}bufferPolygonImpl(e,t,n){let r=e,i=r.getImpl(),a=new F({vd:e.getDescription()});for(let o=t;o<n;o++){if(i.getPathSize(o)<1)continue;let t=i.calculateRingArea2D(o),n=new b;if(i.queryPathEnvelope(o,n),this.m_distance>0)if(t>0)if(this.isDegeneratePath(i,o)){let e=new x;i.getPointByVal(i.getPathStart(o),e),e.setXY(n.getCenter()),a.add(this.bufferDegeneratePath(e,!0),!1)}else{let t=new N({vd:e.getDescription()}),n=t.getImpl();if(D(this.m_geometry,o)){let e=this.bufferConvexPath(r,o);a.add(e,!1)}else{this.bufferClosedPath(this.m_geometry,o,n,this.m_bRoundBuffer,1);let e=this.bufferCleanup(t);a.add(e,!1)}}else{if(n.width()+this.m_tolerance.total()<=2*this.m_absDistance||n.height()+this.m_tolerance.total()<=2*this.m_absDistance)continue;let t=new N({vd:e.getDescription()}),r=t.getImpl();if(this.bufferClosedPath(this.m_geometry,o,r,this.m_bRoundBuffer,1),!t.isEmpty()){let e=n,i=Math.max(1,this.m_absDistance),o=e.clone();o.inflateCoords(i,i),r.addEnvelope(o,!1);let s=this.bufferCleanup(t);a.reserve(a.getPointCount()+s.getPointCount()-4),$(s,a,o,!0)}}else if(t>0){if(n.width()+this.m_tolerance.total()<=2*this.m_absDistance||n.height()+this.m_tolerance.total()<=2*this.m_absDistance)continue;let t=new N({vd:e.getDescription()}),r=t.getImpl();if(this.bufferClosedPath(this.m_geometry,o,r,this.m_bRoundBuffer,-1),!t.isEmpty()){let e=new b;r.queryLooseEnvelope(e);let n=Math.max(1,this.m_absDistance),i=e.clone();i.inflateCoords(n,n),r.addEnvelope(i,!1),$(this.bufferCleanup(t),a,i,!0)}}else{let t=new N({vd:e.getDescription()}),n=t.getImpl();this.bufferClosedPath(this.m_geometry,o,n,this.m_bRoundBuffer,-1);let r=this.bufferCleanup(t);for(let e=0,t=r.getPathCount();e<t;e++)a.addPath(r,e,!0)}}if(this.m_distance>0)return a.getPathCount()>1?this.bufferCleanup(a):J(a);{let e=new b;if(a.queryLooseEnvelope(e),a.isEmpty())return J(a);{let t=Math.max(1,this.m_absDistance),n=e.clone();n.inflateCoords(t,t),a.addEnvelope(n,!1);let r=this.bufferCleanup(a);a=new F;let i=new F({vd:r.getDescription()});return $(r,i,n,!1),J(i)}}}bufferPoint(){return this.bufferPointImpl(this.m_geometry)}bufferPointImpl(e){let t=new F({vd:e.getDescription()});return this.m_caps===0?(this.addCircle(t.getImpl(),e),this.setStrongSimple(t)):this.m_caps===2?(this.addSquare(t.getImpl(),e),this.setStrongSimple(t)):t}bufferDegeneratePath(e,t){let n=new F({vd:e.getDescription()});return t&&this.m_joins===0||!t&&this.m_caps===0?(this.addCircle(n.getImpl(),e),this.setStrongSimple(n)):t||this.m_caps!==2?n:(this.addSquare(n.getImpl(),e),this.setStrongSimple(n))}bufferMultiPoint(){let e=new U(this,this.m_geometry,this.m_distance,this.m_spatialReference,this.m_joins,this.m_caps,this.m_miterLimit,this.m_densifyDist,this.m_maxVertexInCompleteCircle,this.m_progressTracker);return new O().executeMany(e,this.m_spatialReference,this.m_progressTracker,2).next()}bufferEnvelope(){let e=new F({vd:this.m_geometry.getDescription()});if(this.m_distance<=0){if(this.m_distance===0)e.addEnvelope(this.m_geometry,!1),Y(this.m_geometry,this.m_tolerance.total())&&(e=this.setStrongSimple(e));else{let t=new k;this.m_geometry.queryEnvelope(t),t.inflateCoords(this.m_distance,this.m_distance),e.addEnvelope(t,!1),Y(t,this.m_tolerance.total())&&(e=this.setStrongSimple(e))}return e}if(this.m_joins===1){let t=new k({copy:this.m_geometry});return t.inflateCoords(this.m_absDistance,this.m_absDistance),e.addEnvelope(t,!1),e}let t=this.m_geometry.clone();if(t.width()===0||t.height()===0){if(t.width()===0&&t.height()===0){let e=new x({vd:this.m_geometry.getDescription()});return t.queryCornerByVal(0,e),this.m_geometry=e,this.bufferImpl()}let e=new N({vd:this.m_geometry.getDescription()}),n=new x;return t.queryCornerByVal(0,n),e.startPathPoint(n),t.queryCornerByVal(2,n),e.lineToPoint(n),this.m_geometry=e,this.bufferImpl()}return e.addEnvelope(this.m_geometry,!1),this.m_geometry=e,this.bufferConvexPath(e,0)}bufferConvexPath(e,t){this.generateCircleTemplate();let n=e.hasAttribute(10),r=new F({vd:e.getDescription()}),i=r.getImpl();r.reserve((this.m_circleTemplate.length/10+4)*e.getPathSize(t));let a=new f,o=new f,s=new f,c=new f(0,0),l=new f,u=new f,d=e.getImpl(),m=e.getPathSize(t),h=e.getPathStart(t);for(let r=0,f=e.getPathSize(t);r<f;r++){let e=d.getXY(h+r),t=d.getXY(h+(r+1)%m),f=d.getXY(h+(r+2)%m);l.setSub(t,e),l.length()===0&&p(``);let g=n&&!!(1&d.getAttributeAsInt(10,(r+1)%m,0));l.normalize();let _=l.clone();l.leftPerpendicularThis(),l.scale(this.m_absDistance),a.setAdd(l,e),o.setAdd(l,t),r===0?i.startPath(a):i.lineTo(a),i.lineTo(o),u.setSub(f,t),u.length()===0&&p(``),u.normalize();let v=u.clone();u.leftPerpendicularThis(),u.scale(this.m_absDistance),s.setAdd(u,t);let y=B.enumArc,b=g?0:this.m_joins;if(b===2)y=B.enumBevel;else if(b===1){let e=-_.crossProduct(v);c.setSub(_,v),c.scale(this.m_absDistance/e),c.length()<this.m_miterLimit*this.m_absDistance?(c.addThis(t),y=B.enumMiter):y=B.enumBevel}else c.assign(t);this.addJoin(y,i,c,o,s,!1,!1)}return J(r)}bufferPolylinePath(e,t,n){this.generateCircleTemplate();let r=e,i=r.getImpl();if(i.getPathSize(t)<1)return null;let a;if(a=this.m_bRoundBuffer?i.isClosedPathInXYPlane(t):i.isClosedPath(t),this.isDegeneratePath(i,t)&&this.m_distance>0){let e=new x;i.getPointByVal(i.getPathStart(t),e);let n=new b;return i.queryPathEnvelope(t,n),e.setXY(n.getCenter()),this.bufferDegeneratePath(e,a)}let o=new N({vd:e.getDescription()});o.reserve((Math.trunc(this.m_circleTemplate.length/10)+4)*i.getPathSize(t));let s=o.getImpl();return a?this.bufferClosedPath(r,t,s,n,1)!==2&&this.bufferClosedPath(r,t,s,n,-1):this.bufferOpenPath(r,t,s,n),this.bufferCleanup(o)}progress_(){}bufferCleanup(e,t=!1){let n=t?this.m_tolerance:this.m_smallTolerance;return T(e,n,!0,!t,-1,this.m_progressTracker,0,!1)}calcN(){if(this.m_densifyDist===0)return this.m_maxVertexInCompleteCircle;let e=1-this.m_densifyDist*Math.abs(this.m_absDistanceReversed),t=4;return t=e<-1?4:2*Math.PI/Math.acos(e)+.5,t<4?t=4:t>this.m_maxVertexInCompleteCircle&&(t=this.m_maxVertexInCompleteCircle),Math.trunc(t)}addJoin(e,t,n,r,i,a,o){if(this.generateCircleTemplate(),a&&=(t.startPath(r),!1),e===B.enumBevel)return void(o&&t.lineTo(i));if(e===B.enumMiter){let e=n.clone();t.lineTo(e),o&&t.lineTo(i);return}let s=new f;s.setSub(r,n),s.scale(this.m_absDistanceReversed);let c=new f;c.setSub(i,n),c.scale(this.m_absDistanceReversed);let l=Math.atan2(s.y,s.x)/this.m_dA;l<0&&(l=this.m_circleTemplate.length+l),l=this.m_circleTemplate.length-l;let u=Math.atan2(c.y,c.x)/this.m_dA;u<0&&(u=this.m_circleTemplate.length+u),u=this.m_circleTemplate.length-u,u<l&&(u+=this.m_circleTemplate.length);let d=Math.trunc(u),p=Math.ceil(l),m=this.m_circleTemplate[p%this.m_circleTemplate.length].clone();m.scaleAddThis(this.m_absDistance,n);let h=10*this.m_tolerance.total();m.sub(r).length()<h&&(p+=1),m=this.m_circleTemplate[d%this.m_circleTemplate.length].clone(),m.scaleAddThis(this.m_absDistance,n),m.sub(i).length()<h&&--d;let g=d-p;g++;for(let e=0,r=p%this.m_circleTemplate.length;e<g;e++,r=(r+1)%this.m_circleTemplate.length)m=this.m_circleTemplate[r].clone(),m.scaleAddThis(this.m_absDistance,n),t.lineTo(m),this.progress_();o&&t.lineTo(i)}bufferClosedPath(e,t,n,r,i){let a=new S,o=a.addPathFromMultiPath(e,t,!0);return this.bufferClosedPathImpl(a,o,n,r,i)}bufferClosedPathImpl(e,t,n,r,i){let a=e.getFirstVertex(e.getFirstPath(t)),o=new x;if(e.queryPoint(a,o),e.filterClosePoints(this.m_filterTolerance,!1,!1,!1,-1),e.getPointCount(t)<2)return i<0?0:(this.m_bRoundBuffer&&this.addCircle(n,o),2);g(e.getFirstPath(t)!==-1),g(e.getFirstVertex(e.getFirstPath(t))!==-1);let s=e.getXY(e.getFirstVertex(e.getFirstPath(t))),c=new I;if(c.setShift(s.negate()),e.applyTransformation(c),r){let r=ee(e,t,i,!0,this.m_absDistance,this.m_filterTolerance,this.m_densifyDist);if(g(r===1),e.getPointCount(t)<2)return i<0?0:(this.addCircle(n,o),2)}let l=this.m_joins!==0&&e.getVertexDescription().hasAttribute(10);this.m_bufferCommands.length=0;let u=e.getFirstPath(t),d=e.getFirstVertex(u),p=i===1?e.getPrevVertex(d):e.getNextVertex(d),m=i===1?e.getNextVertex(d):e.getPrevVertex(d),h=!0,_=new f,v=new f,y=new f,b=new f,S=new f,C=new f,w=new f,T=new f,E=this.m_absDistance,D=e.getPathSize(u),O=new f(0,0);for(let t=0;t<D;t++){v.assign(e.getXY(m)),h&&(_.assign(e.getXY(d)),y.assign(e.getXY(p)),C.setSub(_,y),C.normalize(),T.leftPerpendicularOther(C),T.scale(E),b.setAdd(T,_));let t=l&&!!(1&e.getAttributeAsDbl(10,d,0));S.setSub(v,_),S.normalize(),w.leftPerpendicularOther(S),w.scale(E);let n=new f;n.setAdd(_,w);let r=C.crossProduct(S),a=C.dotProduct(S);if(r<0||a<0&&r<Math.abs(a)*2**-52*8){let e=!1,i=t?0:this.m_joins;if(i===1){let t=-r;O.setSub(C,S),O.scale(this.m_absDistance/t),O.length()<this.m_miterLimit*this.m_absDistance&&(O.addThis(_),e=!0),this.m_bufferCommands.push(V(b,n,O,e?B.enumMiter:B.enumBevel,this.m_bufferCommands.length+1))}else this.m_bufferCommands.push(V(b,n,_,i===0?B.enumArc:B.enumBevel,this.m_bufferCommands.length+1))}else b.equals(n)||(this.m_bufferCommands.push(H(b,_,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(H(_,n,this.m_bufferCommands.length+1)));let o=new f;o.setAdd(v,w),this.m_bufferCommands.push(V(n,o,_,B.enumLine,this.m_bufferCommands.length+1)),b.setCoordsPoint2D(o),T.setCoordsPoint2D(w),y.setCoordsPoint2D(_),_.setCoordsPoint2D(v),C.setCoordsPoint2D(S),p=d,d=m,h=!1,m=i===1?e.getNextVertex(d):e.getPrevVertex(d)}return this.m_bufferCommands.at(-1).m_next=0,this.processBufferCommands(n),c.setShift(s),n.applyTransformationToPath(c,n.getPathCount()-1),1}bufferOpenPath(e,t,n,r){if(this.m_bRoundBuffer){let i=new N({vd:e.getDescription()});return i.addPath(e,t,!1),i.addSegmentsFromPath(e,t,0,e.getSegmentCountPath(t),!1),this.bufferClosedPath(i,0,n,r,1)}let i=0,a=new N({vd:e.getDescription()}),o=new f(0,0);{let r=new S,s=r.addPathFromMultiPath(e,t,!1),c=r.getFirstVertex(r.getFirstPath(s)),l=new x;if(r.queryPoint(c,l),o.assign(l.getXY()),r.filterClosePoints(0,!1,!1,!1,-1),r.getPointCount(s)<2)return this.m_bRoundBuffer&&this.addCircle(n,l),2;let u=r.getGeometry(r.getFirstGeometry());a.addPath(u,0,!1),i=a.getPointCount()-1,a.addSegmentsFromPath(u,0,0,u.getSegmentCountPath(0)-1,!1)}let s=new S,c=s.addPathFromMultiPath(a,0,!0);g(s.getFirstPath(c)!==-1),g(s.getFirstVertex(s.getFirstPath(c))!==-1);let l=new I;l.setShift(o.negate()),s.applyTransformation(l),this.m_bufferCommands.length=0;let u=s.getFirstPath(c),d=this.m_joins!==0&&s.getVertexDescription().hasAttribute(10),p=s.getFirstVertex(u),m=s.getPrevVertex(p),h=s.getNextVertex(p),_=!0,v=new f,y=new f,b=new f,C=new f,w=new f,T=new f,E=new f,D=new f,O=this.m_absDistance,k=s.getPathSize(u),A=new f(0,0);for(let e=0;e<k;e++){let t=!1;e!==0&&e!==i||(t=!0),y.assign(s.getXY(h)),_&&(v.assign(s.getXY(p)),b.assign(s.getXY(m)),T.setSub(v,b),T.normalize(),D.leftPerpendicularOther(T),D.scale(O),C.setAdd(D,v));let n=d&&!!(1&s.getAttributeAsDbl(10,p,0));w.setSub(y,v),w.normalize(),E.leftPerpendicularOther(w),E.scale(O);let r=new f;r.setAdd(v,E);let a=T.crossProduct(w),o=T.dotProduct(w);if(a<0||o<0&&a<Math.abs(o)*2**-52*8)if(t)if(this.m_caps===0)this.m_bufferCommands.push(V(C,r,v,B.enumArc,this.m_bufferCommands.length+1));else if(this.m_caps===1)this.m_bufferCommands.push(V(C,r,v,B.enumLine,this.m_bufferCommands.length+1));else{let e=w.mul(this.m_absDistance).negate(),t=e.clone();e.addThis(C),t.addThis(r),this.m_bufferCommands.push(V(C,e,v,B.enumLine,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(V(e,t,v,B.enumLine,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(V(t,r,v,B.enumLine,this.m_bufferCommands.length+1))}else{let e=!1,t=n?0:this.m_joins;if(t===1){let t=-a;A.setSub(T,w),A.scale(this.m_absDistance/t),A.length()<this.m_miterLimit*this.m_absDistance&&(A.addThis(v),e=!0),this.m_bufferCommands.push(V(C,r,A,e?B.enumMiter:B.enumBevel,this.m_bufferCommands.length+1))}else this.m_bufferCommands.push(V(C,r,v,t===0?B.enumArc:B.enumBevel,this.m_bufferCommands.length+1))}else C.equals(r)||(this.m_bufferCommands.push(H(C,v,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(H(v,r,this.m_bufferCommands.length+1)));let c=new f;c.setAdd(y,E),this.m_bufferCommands.push(V(r,c,v,B.enumLine,this.m_bufferCommands.length+1)),C.setCoordsPoint2D(c),D.setCoordsPoint2D(E),b.setCoordsPoint2D(v),v.setCoordsPoint2D(y),T.setCoordsPoint2D(w),m=p,p=h,_=!1,h=s.getNextVertex(p)}return this.m_bufferCommands.at(-1).m_next=0,this.processBufferCommands(n),l.setShift(o),n.applyTransformationToPath(l,n.getPathCount()-1),1}processBufferCommands(e){let t=this.cleanupBufferCommands(),n=!0,r=t+1;for(let i=t;r!==t;i=r){let t=this.m_bufferCommands[i];r=t.m_next===-1?(i+1)%this.m_bufferCommands.length:t.m_next,t.m_type&&(n&&=(e.startPath(t.m_from),!1),t.m_type&B.enumJoinMask?this.addJoin(t.m_type,e,t.m_center,t.m_from,t.m_to,!1,!0):e.lineTo(t.m_to))}}cleanupBufferCommands(){this.m_helperArray=i(f,9);let e=0;for(let t=0,n=this.m_bufferCommands.length;t<n;){let n=this.m_bufferCommands[t];if(n.m_type&B.enumConnectionMask){e=t;break}t=n.m_next}let t=e+1;for(let n=e;t!==e;n=t){let e=this.m_bufferCommands[n];t=e.m_next;let r=1,i=null;for(;t!==n&&(i=this.m_bufferCommands[t],!(i.m_type&B.enumConnectionMask));)t=i.m_next,r++;r!==1&&(e.m_type&i.m_type)===B.enumLine&&(this.m_helperLine1.setStartXY(e.m_from),this.m_helperLine1.setEndXY(e.m_to),this.m_helperLine2.setStartXY(i.m_from),this.m_helperLine2.setEndXY(i.m_to),this.m_helperLine1.intersect(this.m_helperLine2,this.m_helperArray,null,null,this.m_smallTolerance.total())===1&&(e.m_to.assign(this.m_helperArray[0]),i.m_from.assign(this.m_helperArray[0]),e.m_next=t))}return e}isDegeneratePath(e,t){if(e.getPathSize(t)===1)return!0;if(this.m_joins===0&&this.m_caps===0){let n=new b;if(e.queryPathEnvelope(t,n),Math.max(n.width(),n.height())<.5*this.m_densifyDist)return!0}return!1}isDegenerateGeometry(e){if(this.m_joins===0&&this.m_caps===0){let t=new b;if(e.queryEnvelope(t),Math.max(t.width(),t.height())<.5*this.m_densifyDist)return!0}return!1}addCircle(e,t){let n=t.getXY();if(this.m_circleTemplate.length!==0){let t=this.m_circleTemplate[0].clone();t.scaleAddThis(this.m_absDistance,n),e.startPath(t);for(let r=1,i=this.m_circleTemplate.length;r<i;r++)t=this.m_circleTemplate[r].clone(),t.scaleAddThis(this.m_absDistance,n),e.lineTo(t);return}let r=this.m_circleTemplateSize,i=Math.trunc((r+3)/4),a=.5*Math.PI/i;e.reserve(4*i);let o=Math.cos(a),s=Math.sin(a);for(let t=3;t>=0;t--){let r=f.construct(0,this.m_absDistance);switch(t){case 0:for(let t=0;t<i;t++)e.lineToCoords(r.x+n.x,r.y+n.y),r.rotateReverse(o,s);break;case 1:for(let t=0;t<i;t++)e.lineToCoords(-r.y+n.x,r.x+n.y),r.rotateReverse(o,s);break;case 2:for(let t=0;t<i;t++)e.lineToCoords(-r.x+n.x,-r.y+n.y),r.rotateReverse(o,s);break;default:e.startPathCoords(r.y+n.x,-r.x+n.y);for(let t=1;t<i;t++)r.rotateReverse(o,s),e.lineToCoords(r.y+n.x,-r.x+n.y)}this.progress_()}}addSquare(e,t){let n=new k({vd:t.getDescription()});n.setCoords(t.getX(),t.getY(),t.getX(),t.getY()),n.inflateCoords(this.m_absDistance,this.m_absDistance),e.addEnvelope(n,!1)}setStrongSimple(e){return e.getImpl().setIsSimple(4,this.m_tolerance.total()),e.getImpl().updateOGCFlagsProtected(),e}};function J(e){return C(e,0),e}function Y(e,t){return!!e.isEmpty()||Math.min(e.width(),e.height())>t}function X(e,t,n,r,i,a,o,s){let c=e.getXY(n),l=e.getXY(r);if(c.equals(l))return-1;let u=.25*o,d=.25*o,p=new f;p.setSub(l,c);let h=p.length(),_=h*h*.25,y=a*a-_;if(y<=_)return-1;let b=Math.sqrt(y);p.normalize();let x=p.clone();x.rightPerpendicularThis();let S=_/b,C=S<=d,w=f.lerp(l,c,.5),T=x.clone(),E=S-u;T.scaleAddThis(Math.max(0,E),w),x.negate().scaleAddThis(b,w);let D=3.61*v(a-d),O=T.sub(c),k=T.sub(l),A=!1,j=0,M=m(64,0);g(s===M.length);{for(let a=e.getPrevVertexEx(r,i);a!==n;){if(e.getUserIndex(a,t)===1)return-1;if(e.getXY(a).equals(l)){let t=e.getPrevVertexEx(a,i);e.removeVertex(a,!1),a=t;continue}break}let a=new f,o=c.clone();M[j++]=1;for(let s=e.getNextVertexEx(n,i);s!==r;){if(e.getUserIndex(s,t)===1)return-1;let n=e.getXY(s);if(n.equals(o)){let t=e.getNextVertexEx(s,i);e.removeVertex(s,!1),s=t;continue}M[j++]=0;let r=new f;if(r.setSub(n,c),r.dotProduct(x)<0)return 0;(f.sqrDistance(n,c)>D||f.sqrDistance(n,l)>D)&&(A=!0);let u=0;if(n.sub(c).crossProduct(O)>=0&&(u=1),n.sub(l).crossProduct(k)<=0&&(u|=2),u===0)return 0;M[j-1]=u,a.assign(o),o.assign(n),s=e.getNextVertexEx(s,i)}if(j===1)return 0;g(j<M.length),M[j++]=2}let N=!0;for(let e=1,t=0;e<j;e++)if(M[e]!==M[e-1]&&(t++,N=t<3&&(t===1&&M[e]===3||t===2&&M[e]===2),!N))return 0;if(j>2&&N&&(j===3||!A)){let t=0,a=e.getNextVertexEx(n,i);for(C||(e.setXY(a,T),a=e.getNextVertexEx(a,i));a!==r;){let n=e.getNextVertexEx(a,i);e.removeVertex(a,!1),a=n,++t}return t}if(g(j!==3),A&&j>3)return 0;let P=c.clone(),F=n,I=c.clone(),L=1,R=-1,z=F,B=0;for(j=1;z!==r;){z=e.getNextVertexEx(z,i);let t=M[j++];if(t===0){if(z===r)break;continue}let n=e.getXY(z);if(R!==-1){if(3&(R&L&t)){e.removeVertex(F,!0),B++,F=z,I.setCoordsPoint2D(n),L=t;continue}if(L===3&&R!==0&&t!==0){if(I.setCoordsPoint2D(T),C||I.equals(P)){e.removeVertex(F,!0),B++,F=z,I.setCoordsPoint2D(n),L=t;continue}e.setXY(F,I)}}R=L,P.setCoordsPoint2D(I),F=z,L=t,I.setCoordsPoint2D(n)}return B}function Z(e,t,n,r){let i=-1,a=new f,o=new f,s=new f;for(let n=0,c=e.getPathSize(r),l=e.getFirstVertex(r);n<c;++n){i===-1&&(e.queryXY(l,o),i=e.getPrevVertex(l),i!==-1&&(e.queryXY(i,a),s.setSub(o,a),s.normalize()));let n=e.getNextVertex(l);if(n===-1)break;let r=e.getXY(n),c=r.sub(o);c.normalize(),i!==-1&&c.dotProduct(s)<-.99&&Math.abs(c.crossProduct(s))<1e-7&&e.setUserIndex(l,t,1),i=l,l=n,a.assign(o),o.assign(r),s.assign(c)}}function Q(n,i,a,o,s,c,l){let u={stack:[],error:void 0,hasError:!1};try{let e=n.getFirstPath(i),o=n.createUserIndex();t(u,r(()=>{n.removeUserIndex(o)},!1),!1),Z(n,o,i,e);for(let t=0;t<100;++t){if(n.getPathSize(e)===0)return 1;let t=n.getFirstVertex(e),r=n.getPathSize(e);if(r<3)return 1;n.isClosedPath(e)||--r;let i=0,c=!1;for(let e=0;e<r&&t!==-1;e++){let u=0,d=t;for(let i=1,c=Math.min(64,r-e);i<c;i++)if(d=n.getNextVertexEx(d,a),i>1){let e=X(n,o,t,d,a,s,l,64);if(e===-1)break;u+=e,r-=e}if(i+=u,c=u>0,c){let e=n.getPrevVertexEx(t,a);if(e!==-1){t=e,r++;continue}}t=n.getNextVertexEx(t,a)}if(i===0)break}return n.filterClosePoints(c,!1,!1,!1,-1),1}catch(e){u.error=e,u.hasError=!0}finally{e(u)}}function ee(e,t,n,r,i,a,o){return Q(e,t,n,r,i,a,o)}function $(e,t,n,r){for(let i=0,a=e.getPathCount();i<a;i++){let a=e.getXY(e.getPathStart(i));a.x!==n.xmin&&a.x!==n.xmax&&t.addPath(e,i,r)}}export{q as t};
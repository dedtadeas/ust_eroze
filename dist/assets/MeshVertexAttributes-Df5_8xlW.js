import{AE as e,Bx as t,CD as n,MC as r,kC as i,vC as a,vE as o,zy as s}from"./index-BqmCqmfp.js";import{n as c,t as l}from"./meshProperties-Du90n6lL.js";var u,d=u=class extends s(a){constructor(e){super(e),this.color=null,this.position=new Float64Array,this.uv=null,this.normal=null,this.tangent=null}castColor(e){return l(e,Uint8Array,[Uint8ClampedArray],{loggerTag:`.color=`,stride:4},o.getLogger(this))}castPosition(e){return e&&e instanceof Float32Array&&o.getLogger(this).warn(`.position=`,`Setting position attribute from a Float32Array may cause precision problems. Consider storing data in a Float64Array or a regular number array`),l(e,Float64Array,[Float32Array],{loggerTag:`.position=`,stride:3},o.getLogger(this))}castUv(e){return l(e,Float32Array,[Float64Array],{loggerTag:`.uv=`,stride:2},o.getLogger(this))}castNormal(e){return l(e,Float32Array,[Float64Array],{loggerTag:`.normal=`,stride:3},o.getLogger(this))}castTangent(e){return l(e,Float32Array,[Float64Array],{loggerTag:`.tangent=`,stride:4},o.getLogger(this))}clonePositional(){let t={position:e(this.position),normal:e(this.normal),tangent:e(this.tangent),uv:this.uv,color:this.color};return new u(t)}get usedMemory(){return this.position.byteLength+(this.uv?.byteLength??0)+(this.normal?.byteLength??0)+(this.tangent?.byteLength??0)+(this.color?.byteLength??0)}};n([r({json:{write:c}})],d.prototype,`color`,void 0),n([t(`color`)],d.prototype,`castColor`,null),n([r({nonNullable:!0,json:{write:c}})],d.prototype,`position`,void 0),n([t(`position`)],d.prototype,`castPosition`,null),n([r({json:{write:c}})],d.prototype,`uv`,void 0),n([t(`uv`)],d.prototype,`castUv`,null),n([r({json:{write:c}})],d.prototype,`normal`,void 0),n([t(`normal`)],d.prototype,`castNormal`,null),n([r({json:{write:c}})],d.prototype,`tangent`,void 0),n([t(`tangent`)],d.prototype,`castTangent`,null),d=u=n([i(`esri.geometry.support.MeshVertexAttributes`)],d);export{d as t};
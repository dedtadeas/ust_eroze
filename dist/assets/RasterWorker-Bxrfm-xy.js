import{Ax as e,CD as t,Hy as n,Rg as r,Sx as i,kC as a}from"./index-BqmCqmfp.js";import"./_commonjsHelpers-D6ht1XAa.js";import{E as o,d as s,g as c,t as l}from"./RasterSymbolizer-CkbjgVe_.js";import"./pixelRangeUtils-DMjHgTK0.js";import"./colorUtils-uG2qTogT.js";import{t as u}from"./PixelBlock-CjVaas_l.js";import{A as d,C as f,a as p,d as m,f as h,g,h as _,u as v,v as y}from"./vectorFieldUtils-yzcuu25U.js";import{t as b}from"./dataUtils-lUZ4DUuE.js";import{p as x,u as S}from"./rasterProjectionHelper-CyS9RtmF.js";import"./clipUtils-ZHQqHn8q.js";import{t as C}from"./rasterFunctionHelper-CMjb75WD.js";import{n as w,r as T,t as E}from"./GCSShiftTransform-ClfQwpo0.js";var D,O=D=class extends T{constructor(){super(...arguments),this.type=`identity`}clone(){return new D}};t([n({IdentityXform:`identity`})],O.prototype,`type`,void 0),O=D=t([a(`esri.layers.support.rasterTransforms.IdentityTransform`)],O);var k={GCSShiftXform:E,IdentityXform:O,PolynomialXform:w};function A(e){if(!e?.type)return null;let t=k[e?.type];if(t){let n=new t;return n.read(e),n}return null}function j(e){if(!e)return{result:null,transferList:[]};let{pixelBlock:t,transferList:n}=e.getTransferableObject();return{result:t,transferList:n}}var M=class{convertVectorFieldData(e){let t=u.fromJSON(e.pixelBlock),n=j(p(t,e.type));return Promise.resolve(n)}convertPixelBlockToFeatures(e){let t=f({pixelBlock:u.fromJSON(e.pixelBlock),extent:i.fromJSON(e.extent),fieldNames:e.fieldNames,skipFactor:e.skipFactor,skipSpatialReference:!0,pixelIdOffset:e.pixelIdOffset,imageRowSize:e.imageRowSize});return Promise.resolve(t)}computeStatisticsHistograms(e){let t=u.fromJSON(e.pixelBlock),n=s(t,{histogramSize:e.histogramSize,includeSkewnessKurtosis:e.includeSkewnessKurtosis});return Promise.resolve(n)}async decode(e){return j(await o(e.data,e.options))}symbolize(e){e.pixelBlock=u.fromJSON(e.pixelBlock),e.extent=e.extent?i.fromJSON(e.extent):null;let t=j(this.symbolizer.symbolize(e));return Promise.resolve(t)}highlightPixels(e){let t=u.fromJSON(e.pixelBlock),n=u.fromJSON(e.renderedPixelBlock);return d(t,n,e.highlightOptions),Promise.resolve(n.toJSON())}async updateSymbolizer(e){this.symbolizer=l.fromJSON(e.symbolizerJSON),e.histograms&&this.symbolizer?.rendererJSON.type===`rasterStretch`&&(this.symbolizer.rendererJSON.histograms=e.histograms)}async updateRasterFunction(e){this.rasterFunction=C(e.rasterFunctionJSON)}async process(t){return j(this.rasterFunction.process({extent:i.fromJSON(t.extent),primaryPixelBlocks:t.primaryPixelBlocks.map(e=>e==null?null:u.fromJSON(e)),primaryPixelSizes:t.primaryPixelSizes?.map(t=>t==null?null:e.fromJSON(t)),primaryRasterIds:t.primaryRasterIds}))}stretch(e){let t=j(this.symbolizer.simpleStretch(u.fromJSON(e.srcPixelBlock),e.stretchParams));return Promise.resolve(t)}estimateStatisticsHistograms(e){let t=c(u.fromJSON(e.srcPixelBlock));return Promise.resolve(t)}split(e){let t=y(u.fromJSON(e.srcPixelBlock),e.tileSize,e.maximumPyramidLevel??0,!1===e.useBilinear),n=[],r;return t&&(r=new Map,t.forEach((e,t)=>{if(e){let{pixelBlock:i,transferList:a}=e.getTransferableObject();r.set(t,i),a.forEach(e=>{n.includes(e)||n.push(e)})}})),Promise.resolve({result:r,transferList:n})}clipTile(e){let t=u.fromJSON(e.pixelBlock),n=j(h({...e,pixelBlock:t}));return Promise.resolve(n)}async mosaicAndTransform(e){let t=e.srcPixelBlocks.map(e=>e?new u(e):null),n=g(t,e.srcMosaicSize,{blockWidths:e.blockWidths,alignmentInfo:e.alignmentInfo,clipOffset:e.clipOffset,clipSize:e.clipSize}),r,i=n;e.coefs&&(i=_(n,e.destDimension,e.coefs,e.sampleSpacing,e.interpolation)),e.projectDirections&&e.gcsGrid&&(r=m(e.destDimension,e.gcsGrid),i=v(i,e.isUV?`vector-uv`:`vector-magdir`,r));let{result:a,transferList:o}=j(i);return{result:{pixelBlock:a,localNorthDirections:r},transferList:o}}async createFlowMesh(e,t){let n={data:new Float32Array(e.flowData.buffer),mask:new Uint8Array(e.flowData.maskBuffer),width:e.flowData.width,height:e.flowData.height},{vertexData:r,indexData:i}=await b(e.meshType,e.simulationSettings,n,t.signal);return{result:{vertexBuffer:r.buffer,indexBuffer:i.buffer},transferList:[r.buffer,i.buffer]}}async getProjectionOffsetGrid(e){let t=i.fromJSON(e.projectedExtent),n=i.fromJSON(e.srcBufferExtent),a=null;e.datumTransformationSteps?.length&&(a=new r({steps:e.datumTransformationSteps})),await S();let o=e.rasterTransform?A(e.rasterTransform):null;return x({...e,projectedExtent:t,srcBufferExtent:n,datumTransformation:a,rasterTransform:o})}};export{M as default};
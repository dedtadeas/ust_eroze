import{wD as e,xD as t}from"./index-BqmCqmfp.js";import{t as n}from"./SimpleGeometryCursor-CI9GIWKa.js";import{Ut as r,cn as i,ht as a,in as o,kt as s,ln as c,pn as l,r as u,vn as d,xn as f,z as p}from"./Point2D-UYEfE6HP.js";import{t as m}from"./Envelope2D-BNwQDrOT.js";import{An as h,Ct as g,L as _,M as v,O as y,Tn as b,V as x,Vt as S,W as C,a as w,en as T,it as E,n as D,o as O,ot as k,sn as A,u as j,wt as M,xt as N,z as P}from"./UnitFactory-J9WMNXdY.js";import{t as F}from"./Transformation2D-DVoPQwGC.js";import{i as I,r as L,t as R}from"./Distance2DCalculator-CXhBP-8I-Xmr2hQVp.js";import{n as z}from"./OperatorGeodeticDensifyByLength-TfdsZEIz.js";var B=class{getOperatorType(){return 10317}supportsCurves(){return!0}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}executeMany(e,t,n,r,i,a){return new z(e,t,4,n,r,i,a)}execute(e,t,r,i,a,o){let s=new n([e]),l=this.executeMany(s,t,r,i,a,o).next();return l||c(`null output`),l}};function V(){return new m}var H=class{[Symbol.dispose](){this.m_peR1.destroy(),this.m_peR2.destroy(),this.m_peR3.destroy(),this.m_peR1=null,this.m_peR2=null,this.m_peR3=null}constructor(e,t,n){this.m_peR1=new w,this.m_peR2=new w,this.m_peR3=new w,e===void 0?this.reset(1,0,1):this.reset(e,t,n)}reset(e,t,n){this.m_a=e,this.m_e2=t,this.m_b=this.m_a*Math.sqrt(1-this.m_e2),this.m_unitToDegree=n,this.m_unitToRad=.017453292519943295*n,this.m_u180=180/this.m_unitToDegree,this.m_u360=360/this.m_unitToDegree}calculateBbox(e,t,n,r){let i=this.m_peR1,o=this.m_peR2,s=this.m_peR3;O.geodeticDistance(this.m_a,this.m_e2,e*this.m_unitToRad,t*this.m_unitToRad,n*this.m_unitToRad,r*this.m_unitToRad,s,i,o,0);let c=Math.cos(i.val),l=Math.cos(o.val+3.141592653589793),u=t*this.m_unitToRad,d=_.phiToEta(this.m_e2,u),f=Math.sin(i.val)*Math.cos(d),p=t;if(c*l<0){let e=c<0?-1:1,t=Math.acos(Math.abs(f))*e;p=_.etaToPhi(this.m_e2,t)/this.m_unitToRad}let m=a((n-e)*this.m_unitToRad,2*Math.PI);Math.abs(m)>Math.PI&&(m=m>0?m-2*Math.PI:m+2*Math.PI),m/=this.m_unitToRad,n=e+m;let h=V();return h.xmin=Math.min(e,n),h.xmax=Math.max(e,n),h.ymin=Math.min(t,r),h.ymin=Math.min(h.ymin,p),h.ymax=Math.max(t,r),h.ymax=Math.max(h.ymax,p),h}minDistanceGeodesic(e,t){let n=U(e),r=U(t);if(n&&r)return this.lowerDistanceGeodetic_(e.xmin,e.ymin,t.xmin,t.ymin);let i=this.normalizeGeodesic_(t,e);return W(e,i)?e.ymin>=i.ymax?this.minDistanceGeodesicUpDown_(e,i):i.ymin>=e.ymax?this.minDistanceGeodesicUpDown_(i,e):e.xmin>i.xmax?this.minDistanceGeodesicLeftRight_(i,e):this.minDistanceGeodesicLeftRight_(e,i):0}normalizeGeodesic_(e,t){let n=e.clone(),r=e.clone(),i=G(n,t);if(i===0)return n;for(;r.xmax>t.xmin;){r.xmin-=this.m_u360,r.xmax-=this.m_u360;let e=G(r,t);if(e<i&&(n.assign(r),i=e,i===0))return n}for(r.assign(e);r.xmin<t.xmax;){r.xmin+=this.m_u360,r.xmax+=this.m_u360;let e=G(r,t);if(e<i&&(n.assign(r),i=e,i===0))return n}return n}lowerDistanceGeodetic_(e,t,n,r){let i=this.m_peR1;{let a=this.m_b*this.m_b/this.m_a,o=_.phiToPhig(this.m_e2,this.m_unitToRad*t),s=_.phiToPhig(this.m_e2,this.m_unitToRad*r);O.geodeticDistance(a,0,this.m_unitToRad*e,o,this.m_unitToRad*n,s,i,null,null,0)}return i.val}minDistanceGeodesicUpDown_(e,t){if(t.xmin<=e.xmin?t.xmax>=e.xmin:e.xmax>=t.xmin)return this.lowerDistanceGeodetic_(0,e.ymin,0,t.ymax);if(t.xmin>e.xmax){let n=this.lowerDistanceGeodeticSegMeridional_(e.xmax,e.ymin,e.ymax,t.xmin,t.ymin,t.ymax);if(t.xmax-e.xmin<this.m_u180)return n;let r=this.lowerDistanceGeodeticSegMeridional_(e.xmin,e.ymin,e.ymax,t.xmax,t.ymin,t.ymax);return Math.min(n,r)}{let n=this.lowerDistanceGeodeticSegMeridional_(e.xmin,e.ymin,e.ymax,t.xmax,t.ymin,t.ymax);if(e.xmax-t.xmin<this.m_u180)return n;let r=this.lowerDistanceGeodeticSegMeridional_(e.xmax,e.ymin,e.ymax,t.xmin,t.ymin,t.ymax);return Math.min(n,r)}}minDistanceGeodesicLeftRight_(e,t){let n=Math.abs(e.xmax-t.xmin);for(;n>this.m_u180;)n-=this.m_u360;let r=Math.abs(e.xmin-t.xmax);for(;r>this.m_u180;)r-=this.m_u360;return Math.abs(n)<=Math.abs(r)?this.minDistanceGeodesicLeftRightNormalized_(e,t):this.minDistanceGeodesicLeftRightNormalized_(t,e)}minDistanceGeodesicLeftRightNormalized_(e,t){let n,r;return n=this.lowerDistanceGeodetic_(e.xmax,e.ymin,t.xmin,t.ymin),e.ymin>=t.ymin&&e.ymin<=t.ymax&&(r=this.lowerDistanceGeodeticPtMeridional_(e.xmax,e.ymin,t.xmin,t.ymin,t.ymax),n=Math.min(n,r)),t.ymin>=e.ymin&&t.ymin<=e.ymax&&(r=this.lowerDistanceGeodeticPtMeridional_(t.xmin,t.ymin,e.xmax,e.ymin,e.ymax),n=Math.min(n,r)),r=this.lowerDistanceGeodetic_(e.xmax,e.ymax,t.xmin,t.ymax),n=Math.min(n,r),e.ymax>=t.ymin&&e.ymax<=t.ymax&&(r=this.lowerDistanceGeodeticPtMeridional_(e.xmax,e.ymax,t.xmin,t.ymin,t.ymax),n=Math.min(n,r)),t.ymax>=e.ymin&&t.ymax<=e.ymax&&(r=this.lowerDistanceGeodeticPtMeridional_(t.xmin,t.ymax,e.xmax,e.ymin,e.ymax),n=Math.min(n,r)),n}lowerDistanceGeodeticSegMeridional_(e,t,n,r,i,a){let o=this.lowerDistanceGeodeticPtMeridional_(e,t,r,i,a),s=this.lowerDistanceGeodeticPtMeridional_(e,n,r,i,a),c=this.lowerDistanceGeodeticPtMeridional_(r,i,e,t,n),l=this.lowerDistanceGeodeticPtMeridional_(r,a,e,t,n);return o=Math.min(o,s),c=Math.min(c,l),Math.min(o,c)}lowerDistanceGeodeticPtMeridional_(e,t,n,r,i){let a=this.m_b*this.m_b/this.m_a,o=_.phiToPhig(this.m_e2,this.m_unitToRad*t),c=_.phiToPhig(this.m_e2,this.m_unitToRad*r),l=_.phiToPhig(this.m_e2,this.m_unitToRad*i),u=this.m_peR1,d=this.m_peR2;O.geodeticDistance(a,0,this.m_unitToRad*n,c,this.m_unitToRad*e,o,u,null,null,0),O.geodeticDistance(a,0,this.m_unitToRad*n,l,this.m_unitToRad*e,o,d,null,null,0);let f=k(1,0,new s(this.m_unitToRad*e,o)),p=k(1,0,new s(this.m_unitToRad*n,c)),m=k(1,0,new s(this.m_unitToRad*n,l)),h=new b;h.setCrossProductVector(p,m);let g=p.dotProduct(m);if(h.length()<1568e-13)return g>=0?Math.min(u.val,d.val):0;h=h.getUnitVector();let v=new b;if(v.setCrossProductVector(h,f),v.length()<1568e-13)return Math.min(u.val,d.val)-1e-5*a;v=v.getUnitVector();let x=f.sub(h.mul(f.dotProduct(h)));{let t=new b;t.setCrossProductVector(p,x);let n=new b;n.setCrossProductVector(x,m);let r=h.dotProduct(t)>0&&h.dotProduct(n)>0;if(r||=(x.negateThis(),t.setCrossProductVector(p,x),n.setCrossProductVector(x,m),h.dotProduct(t)>0&&h.dotProduct(n)>0),r){x=x.getUnitVector();let t=y(1,0,x),n=this.m_peR3;O.geodeticDistance(a,0,this.m_unitToRad*e,o,t.x,t.y,n,null,null,0);let r=Math.min(u.val,d.val);return Math.min(r,n.val)}}return Math.min(u.val,d.val)}};function U(e){return e.xmin===e.xmax&&e.ymin===e.ymax}function W(e,t){return t.xmax<e.xmin||t.xmin>e.xmax||t.ymax<e.ymin||t.ymin>e.ymax}function G(e,t){let n,r=0;return n=e.xmin-t.xmax,n>r&&(r=n),n=t.xmin-e.xmax,n>r&&(r=n),r}var K=class{};function q(e){return{outPoint:e===void 0?new s:e.clone()}}function J(e,t){e.outPoint.assign(t.outPoint)}function Y(){return new m}var X=class{constructor(e,t,n,r,i=0,a=4){this.m_ptDistFrom=new s,this.m_segStartPt=new s,this.m_segEndPt=new s,this.m_geodeticLength=new w,this.m_az12=new w,this.m_minGeodeticDist=new w,this.m_segStartPt3d=new b,this.m_segEndPt3d=new b,this.m_sr=r,this.m_distCurveType=i,this.m_segCurveType=a,this.m_inputGCS=this.m_sr.getGCS(),this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_bIsPannablePcs=this.m_sr.getCoordinateSystemType()===2&&this.m_sr.isPannable();let o=j();this.m_inputGCS.querySpheroidData(o),this.m_a=o.majorSemiAxis,this.m_eSquared=o.e2,this.setPointDistFrom(e),this.setSegmentEndPoints(t,n)}setSegmentEndPoints(e,t){this.m_segStartPt.assign(e),this.m_segEndPt.assign(t),this.m_bIsPannablePcs||(this.m_segStartPt.mulThis(this.m_rpu),this.m_segEndPt.mulThis(this.m_rpu)),this.m_segCurveType===2&&(this.m_segStartPt3d.assign(k(this.m_a,this.m_eSquared,this.m_segStartPt)),this.m_segEndPt3d.assign(k(this.m_a,this.m_eSquared,this.m_segEndPt))),this.calculateAndUpdateSegmentLength()}setPointDistFrom(e){this.m_ptDistFrom.assign(e),this.m_ptDistFrom.scale(this.m_rpu)}setSegmentCurveType(e){this.m_segCurveType=e}setDistanceCurveType(e){this.m_distCurveType=e}makeFunctor(){return n=>{let r;switch(this.m_segCurveType){case 0:case 1:case 3:{let i={stack:[],error:void 0,hasError:!1};try{let e=t(i,new w,!1),a=t(i,new w,!1);O.geodeticCoordinate(this.m_a,this.m_eSquared,this.m_segStartPt.x,this.m_segStartPt.y,this.m_geodeticLength.val*n,this.m_az12.val,e,a,this.m_segCurveType),r=new s(e.val,a.val);break}catch(e){i.error=e,i.hasError=!0}finally{e(i)}}case 2:{let e=b.lerp(this.m_segStartPt3d,this.m_segEndPt3d,n);r=y(this.m_a,this.m_eSquared,e);break}case 4:r=s.lerp(this.m_segStartPt,this.m_segEndPt,n),this.m_bIsPannablePcs&&(N(this.m_sr,0,[r],1),r.mulThis(this.m_rpu));break;default:c(`Invalid curve type`)}return O.geodeticDistance(this.m_a,this.m_eSquared,this.m_ptDistFrom.x,this.m_ptDistFrom.y,r.x,r.y,this.m_minGeodeticDist,null,null,this.m_distCurveType),this.m_minGeodeticDist.val}}calculateAndUpdateSegmentLength(){switch(this.m_segCurveType){case 0:case 2:case 1:case 3:O.geodeticDistance(this.m_a,this.m_eSquared,this.m_segStartPt.x,this.m_segStartPt.y,this.m_segEndPt.x,this.m_segEndPt.y,this.m_geodeticLength,this.m_az12,null,this.m_segCurveType);break;case 4:this.m_geodeticLength.val=s.distance(this.m_segStartPt,this.m_segEndPt);break;default:c(`Invalid curve type`)}}[Symbol.dispose](){this.m_geodeticLength[Symbol.dispose](),this.m_az12[Symbol.dispose](),this.m_minGeodeticDist[Symbol.dispose]()}};function Z(){return new K}var Q=class{[Symbol.dispose](){this.m_envHelper[Symbol.dispose]()}constructor(e,t,n,r,i){this.m_boxGeomA=Y(),this.m_boxGeomB=Y(),this.m_envGeomA=new m,this.m_envGeomB=new m,this.m_progressCounter=0,this.m_transformPCS2GCS=null,this.m_segmentBoxesA=new Map,this.m_segmentBoxesB=new Map,this.m_boundaryPtsA=[],this.m_boundaryPtsB=[],this.m_scaleToRadians=new F,this.m_scaleToDegrees=new F,this.m_inputSR=e,this.m_distCurveType=t,this.m_progressTracker=n,this.m_maxDistance=r,this.m_maxDeviation=i,this.m_inputGCS=e.getGCS(),this.m_peGeogcs=this.m_inputGCS.getPECoordSys(),this.m_tolerance=0;let a=j();this.m_inputGCS.querySpheroidData(a),this.m_a=a.majorSemiAxis,this.m_eSquared=a.e2,this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_envHelper=new H(this.m_a,this.m_eSquared,1),this.m_distCurveType===4&&(this.m_distCurveType=0),this.m_boxGeomA.setEmpty(),this.m_boxGeomB.setEmpty(),this.m_envGeomA.setEmpty(),this.m_envGeomB.setEmpty(),this.m_bIsPannablePcs=this.m_inputSR.getCoordinateSystemType()===2&&this.m_inputSR.isPannable()}progress(e=!1){}calculate(e,t,n,r){let i=q(),a=q();if(e.queryEnvelope(this.m_envGeomA),t.queryEnvelope(this.m_envGeomB),this.checkGeometriesIntersect(e,t,i,a))return n&&J(n,i),r&&J(r,a),0;let o=this.prepareGeometry(e);if(o.isEmpty())return NaN;let s=this.prepareGeometry(t);if(s.isEmpty())return NaN;this.m_tolerance=this.computeTolerance(o,s);let c=this._ExecuteBruteForce(o,s,i,a);return c>=this.m_maxDistance?NaN:(n&&(this.prepareOutput(i),J(n,i)),r&&(this.prepareOutput(a),J(r,a)),c)}createDistanceFunctor(e,t,n){let r=new X(e,t,n,this.m_inputSR,this.m_distCurveType);return this.m_bIsPannablePcs||this.m_inputSR.getCoordinateSystemType()===1||r.setSegmentCurveType(2),r}_NormalizeAndProject(e){if(this.m_inputSR.isPannable()&&(e=new g().foldInto360Range(e,this.m_inputSR)),this.m_inputSR.getCoordinateSystemType()===2){let t=v(this.m_inputSR,this.m_inputGCS,null);e=new g().execute(e,t,this.m_progressTracker)}return e}_ExecuteBruteForce(e,t,n,r){switch(e.getGeometryType()){case i.enumPoint:return this.calculateDistanceGeodeticPointGeometry(e,t,n,r);case i.enumMultiPoint:return this.calculateDistanceGeodeticMultipointGeometry(e,t,n,r);case i.enumPolyline:case i.enumPolygon:case i.enumEnvelope:return this.calculateDistanceGeodeticMultipathGeometry(e,t,n,r);default:o(``)}}calculateDistanceGeodeticPointGeometry(e,t,n,r){switch(t.getGeometryType()){case i.enumPoint:return this.calculateDistanceGeodeticPointPoint(e,t,n,r);case i.enumMultiPoint:return this.calculateDistanceGeodeticPointMultipoint(e,t,n,r);case i.enumPolyline:case i.enumPolygon:return this.calculateDistanceGeodeticPointMultipath(e,t,n,r);default:o(``)}}calculateDistanceGeodeticPointPoint(n,r,i,a){let o={stack:[],error:void 0,hasError:!1};try{let e=n.getXY();e.scale(this.m_rpu);let s=r.getXY();s.scale(this.m_rpu),i.outPoint.assign(e),a.outPoint.assign(s);let c=t(o,new w,!1);return O.geodeticDistance(this.m_a,this.m_eSquared,e.x,e.y,s.x,s.y,c,null,null,this.m_distCurveType),c.val}catch(e){o.error=e,o.hasError=!0}finally{e(o)}}calculateDistanceGeodeticPointMultipoint(n,r,i,a){let o={stack:[],error:void 0,hasError:!1};try{this.computeEnvelopesAndBoxes(n,r);let e=this.estimateMinimumDistance(i,a),c=e<this.m_maxDistance?e:this.m_maxDistance,l=n.getXY();l.scale(this.m_rpu),i.outPoint.assign(l);let u=k(this.m_a,this.m_eSquared,l),d=new s,f=r.getImpl(),p=t(o,new w,!1),m=f.getPointCount();for(let e=0;e<m;++e){f.queryXY(e,d),d.scale(this.m_rpu);let t=k(this.m_a,this.m_eSquared,d);if(!(b.distance(u,t)>c)&&!(this.m_envHelper.minDistanceGeodesic(this.m_boxGeomA,this.m_boxGeomB)>c)&&(O.geodeticDistance(this.m_a,this.m_eSquared,l.x,l.y,d.x,d.y,p,null,null,this.m_distCurveType),p.val<c&&(c=p.val,a.outPoint=d,c===0)))return c}return c===this.m_maxDistance?1/0:c}catch(e){o.error=e,o.hasError=!0}finally{e(o)}}calculateDistanceGeodeticPointMultipath(n,r,i,a){let o={stack:[],error:void 0,hasError:!1};try{let e=new s,c=new s;e.assign(n.getXY()),c.assign(n.getXY()),i.outPoint.assign(c.mul(this.m_rpu)),this.m_bIsPannablePcs&&P(this.m_inputSR,[e],1,!1),this.computeEnvelopesAndBoxes(n,r);let l=this.estimateMinimumDistance(i,a),u=l<this.m_maxDistance?l:this.m_maxDistance,f=r.getImpl(),p=new s(0,0),m=new s(0,0),h=[1],g=this.canUseSpatialTree(n,r),_=Z();g&&this.buildSpatialTree(_,r);let v=Y();v.setCoords({xmin:c.x,ymin:c.y,xmax:c.x,ymax:c.y});let y=t(o,this.createDistanceFunctor(c,p,m),!1),b=f.querySegmentIterator();if(b.stripAttributes(),g)d(0);else for(;b.nextPath();)for(;b.hasNextSegment();){let t=b.nextSegment(),n=this.findOrComputeBoxSegment(b.getStartPointIndex(),t,this.m_segmentBoxesB);if(this.m_envHelper.minDistanceGeodesic(v,n)>u)continue;let r=this.calculateDistanceGeodeticPointSegment(e,c,t,h,y);if(r.second<u&&(this.updateOutputSegment(a,t,r.first),u=r.second,u===0))return 0}return u===this.m_maxDistance?1/0:u}catch(e){o.error=e,o.hasError=!0}finally{e(o)}}calculateDistanceGeodeticMultipointGeometry(e,t,n,r){switch(t.getGeometryType()){case i.enumPoint:return this.calculateDistanceGeodeticPointMultipoint(t,e,r,n);case i.enumMultiPoint:return this.calculateDistanceGeodeticMultipointMultipoint(e,t,n,r);case i.enumPolyline:case i.enumPolygon:case i.enumEnvelope:return this.calculateDistanceGeodeticMultipointMultipath(e,t,n,r);default:o(``)}}calculateDistanceGeodeticMultipointMultipoint(n,r,i,a){let o={stack:[],error:void 0,hasError:!1};try{let e=t(o,new w,!1);this.computeEnvelopesAndBoxes(n,r);let c=this.estimateMinimumDistance(i,a),l=c<this.m_maxDistance?c:this.m_maxDistance,u=new s,d=new s,f=n.getImpl(),p=r.getImpl(),m=Y(),h=f.getPointCount(),g=p.getPointCount();for(let t=0;t<h;++t){if(u.assign(f.getXY(t)),m.setCoords({xmin:u.x,ymin:u.y,xmax:u.x,ymax:u.y}),this.m_envHelper.minDistanceGeodesic(m,this.m_boxGeomB)>l)continue;u.scale(this.m_rpu);let n=k(this.m_a,this.m_eSquared,u);for(let t=0;t<g;++t){d.assign(p.getXY(t)),d.scale(this.m_rpu);let r=k(this.m_a,this.m_eSquared,d);if(!(b.distance(n,r)>=l)&&(O.geodeticDistance(this.m_a,this.m_eSquared,u.x,u.y,d.x,d.y,e,null,null,this.m_distCurveType),e.val<l&&(i.outPoint.assign(u),a.outPoint.assign(d),l=e.val,l===0)))return l}}return l===this.m_maxDistance?1/0:l}catch(e){o.error=e,o.hasError=!0}finally{e(o)}}calculateDistanceGeodeticMultipointMultipath(n,r,i,a){let o={stack:[],error:void 0,hasError:!1};try{let e=r.getImpl().querySegmentIterator();e.stripAttributes(),this.computeEnvelopesAndBoxes(n,r);let c=this.estimateMinimumDistance(i,a),l=c<this.m_maxDistance?c:this.m_maxDistance,u=new s,f=new s(0,0),p=new s(0,0),m=new s(0,0),h=[0],g=Y(),_=t(o,this.createDistanceFunctor(f,p,m),!1),v=Z(),y=this.canUseSpatialTree(n,r);y&&this.buildSpatialTree(v,r);let b=n.getPointCount();for(let t=0;t<b;++t)if(u.assign(n.getXY(t)),f.assign(n.getXY(t)),this.m_bIsPannablePcs&&P(this.m_inputSR,[u],1,!1),g.setCoords({xmin:f.x,ymin:f.y,xmax:f.x,ymax:f.y}),!(this.m_envHelper.minDistanceGeodesic(g,this.m_boxGeomB)>l))if(_.setPointDistFrom(f),y)d(0);else{for(;e.nextPath();)for(;e.hasNextSegment();){let t=e.nextSegment();if(this.m_envHelper.minDistanceGeodesic(g,this.findOrComputeBoxSegment(e.getStartPointIndex(),t,this.m_segmentBoxesB))>l)continue;let n=this.calculateDistanceGeodeticPointSegment(u,f,t,h,_);if(n.second<l&&(i.outPoint.assign(f.mul(this.m_rpu)),this.updateOutputSegment(a,t,n.first),l=n.second,l===0))return 0}e.resetToFirstPath()}return l===this.m_maxDistance?1/0:l}catch(e){o.error=e,o.hasError=!0}finally{e(o)}}calculateDistanceGeodeticMultipathGeometry(e,t,n,r){switch(t.getGeometryType()){case i.enumPoint:return this.calculateDistanceGeodeticPointMultipath(t,e,r,n);case i.enumMultiPoint:return this.calculateDistanceGeodeticMultipointMultipath(t,e,r,n);case i.enumPolyline:case i.enumPolygon:case i.enumEnvelope:return this.calculateDistanceGeodeticMultipathMultipath(e,t,n,r);default:o(``)}}calculateDistanceGeodeticMultipathMultipath(e,t,n,r){let i=[e],a=[t],o=this.swapGeometries(i,a),s=i[0],c=a[0];this.computeEnvelopesAndBoxes(i[0],a[0]);let l=this.estimateMinimumDistance(n,r),u=this.calculateDistanceGeodeticMultipathMultipath_(s,c,n,r,l);return o&&(r.outPoint=p(n.outPoint,n.outPoint=r.outPoint)),u}calculateDistanceGeodeticMultipathMultipath_(n,r,i,a,o=Number.MAX_VALUE){let c={stack:[],error:void 0,hasError:!1};try{let e=o,l=new s(0,0),u=new s,f=new s(0,0),p=new s,m=new s(0,0),h=new s,g=new s,_=new s,v=[new s],y=[0],b=[0],x=Y(),S=Y(),C=t(c,this.createDistanceFunctor(m,l,f),!1),w=Z(),D=this.canUseSpatialTree(n,r);D&&this.buildSpatialTree(w,r);let O=r.querySegmentIterator();O.stripAttributes();let k=new T,A=R(n);for(let t=0;t<A.length;++t){let r=A[t];n.getSegmentBuffer(r,k,!0);let o=k.get();if(x.assign(this.findOrComputeBoxSegment(r,o,this.m_segmentBoxesA)),D)d(0);else{if(m.assign(o.getStartXY()),h.assign(o.getStartXY()),g.assign(o.getEndXY()),_.assign(o.getEndXY()),this.m_bIsPannablePcs&&(N(this.m_inputSR,0,[h],1),N(this.m_inputSR,0,[_],1)),this.m_envHelper.minDistanceGeodesic(x,this.m_boxGeomB)>e)continue;for(;O.nextPath();){for(;O.hasNextSegment();){let t=O.nextSegment();if(l.assign(t.getStartXY()),u.assign(t.getStartXY()),f.assign(t.getEndXY()),p.assign(t.getEndXY()),o.intersect(t,v,y,b,this.m_tolerance))return this.updateOutputSegment(i,o,y[0]),this.updateOutputSegment(a,t,b[0]),0;if(this.m_bIsPannablePcs&&(N(this.m_inputSR,0,[u],1),N(this.m_inputSR,0,[p],1)),S.assign(this.findOrComputeBoxPoint(O.getStartPointIndex(),u,p,this.m_segmentBoxesB)),this.m_envHelper.minDistanceGeodesic(x,S)>e)continue;C.setSegmentEndPoints(l,f),C.setPointDistFrom(h);let n=E(C.makeFunctor(),0,1,1e-10);if(n.second<e&&(i.outPoint.assign(h.mul(this.m_rpu)),this.updateOutputSegment(a,t,n.first),e=n.second,e===0)||(C.setPointDistFrom(_),n=E(C.makeFunctor(),0,1,1e-10),n.second<e&&(i.outPoint.assign(_.mul(this.m_rpu)),this.updateOutputSegment(a,t,n.first),e=n.second,e===0))||(C.setSegmentEndPoints(m,g),C.setPointDistFrom(u),n=E(C.makeFunctor(),0,1,1e-10),n.second<e&&(this.updateOutputSegment(i,o,n.first),a.outPoint.assign(u.mul(this.m_rpu)),e=n.second,e===0))||(C.setPointDistFrom(p),n=E(C.makeFunctor(),0,1,1e-10),n.second<e&&(this.updateOutputSegment(i,o,n.first),a.outPoint.assign(p.mul(this.m_rpu)),e=n.second,e===0)))break}if(e===0)return 0}O.resetToFirstPath()}}return e===this.m_maxDistance?1/0:e}catch(e){c.error=e,c.hasError=!0}finally{e(c)}}calculateDistanceGeodeticPointSegment(e,t,n,r,i){let a=n.getStartXY(),o=n.getEndXY();return n.intersectPoint(e,r,this.m_tolerance)?u(r[0],0):(i.setPointDistFrom(t),i.setSegmentEndPoints(a,o),E(i.makeFunctor(),0,1,1e-10))}prepareGeometry(e){let t=e.clone(),n=e.getGeometryType();if(n===i.enumPoint||n===i.enumMultiPoint)return this._NormalizeAndProject(t);if(n===i.enumEnvelope&&(t=this.envelopeToPolygon(t)),this.m_inputSR.isPannable())return this.prepareGeometryPannable(t,4);if(this.m_inputSR.getCoordinateSystemType()===2){if(t=C(t,this.m_inputSR,0,null),t.isEmpty())return t;t=new B().execute(t,this.m_inputSR,5e4,this.m_maxDeviation/2,0,null);let e=this.m_inputSR.getSRToGCSTransform();return new g().execute(t,e,this.m_progressTracker)}let r=new m;t.queryLooseEnvelope(r);let a=this.m_inputSR.getPannableExtent();if(r.ymin<a.ymin||r.ymax>a.ymax){let e=new m(r.xmin-1,a.ymin,r.xmax+1,a.ymax);if(t=new S().execute(t,e,this.m_inputSR,this.m_progressTracker),t.isEmpty())return t}return r.width()>2*a.width()&&(t=M(t,-2*a.width(),2*a.width(),this.m_inputSR,!0,0,!0,this.m_progressTracker)),t}prepareGeometryPannable(e,t){let n=new m;e.queryEnvelope(n);let i=this.m_inputSR.getPannableExtent();if(i.containsEnvelope(n))return e;let a=new r;i.queryIntervalX(a);let o=new r;return n.queryIntervalX(o),e=a.contains(o)?D(e,this.m_inputSR):new g().foldInto360RangeGeodetic(e,this.m_inputSR,t)}prepareOutput(e){e.outPoint.scale(1/this.m_rpu),this.m_inputSR.getCoordinateSystemType()===2&&P(this.m_inputSR,[e.outPoint],1,!1)}updateOutputSegment(e,t,n){t.queryCoord2D(n,e.outPoint),this.m_bIsPannablePcs&&N(this.m_inputSR,0,[e.outPoint],1),e.outPoint.mulThis(this.m_rpu)}computeTolerance(e,t){e.queryEnvelope(this.m_envGeomA),t.queryEnvelope(this.m_envGeomB);let n=new m(this.m_envGeomA);return n.mergeEnvelope2D(this.m_envGeomB),h(null,n)}envelopeToPolygon(e){let t=new A;return t.addEnvelope(e,!1),t}computeEnvelopesAndBoxes(e,t){e.queryEnvelope(this.m_envGeomA),t.queryEnvelope(this.m_envGeomB),this.m_boxGeomA=this.computeBoxGeometry(e,this.m_boundaryPtsA,this.m_segmentBoxesA),this.m_boxGeomB=this.computeBoxGeometry(t,this.m_boundaryPtsB,this.m_segmentBoxesB)}computeBoxGeometry(e,t,n){switch(e.getGeometryType()){case i.enumPoint:return this.computeBoxPoint(e,t);case i.enumMultiPoint:return this.computeBoxMultiPoint(e,t);case i.enumPolyline:case i.enumPolygon:return this.computeBoxMultiPath(e,t,n);default:c(`Invalid geometry type`)}}computeBoxPoint(e,t){let n=e.getXY();t.length=0,t.push(n.mul(this.m_rpu));let r=Y();return r.setCoords({xmin:n.x,ymin:n.y,xmax:n.x,ymax:n.y}),r}computeBoxMultiPoint(e,t){let n=!0;for(let r=0;r<e.getPointCount();++r){let i=e.getXY(r);if(n){t.length=0;for(let e=0;e<4;++e)t.push(i.clone());n=!1}i.x<t[0].x&&t[0].assign(i),i.y>t[1].y&&t[1].assign(i),i.x>t[2].x&&t[2].assign(i),i.y<t[3].y&&t[3].assign(i)}for(let e=0;e<t.length;++e)t[e].mulThis(this.m_rpu);let r=Y();return e.queryEnvelope(r),r}computeBoxMultiPath(e,t,n){let r=!0,i=Y();i.setEmpty();let a=e.querySegmentIterator();for(a.stripAttributes();a.nextPath();)for(;a.hasNextSegment();){let e=a.nextSegment(),o=e.getStartXY(),s=e.getEndXY();if(this.m_bIsPannablePcs&&(N(this.m_inputSR,0,[o],1),N(this.m_inputSR,0,[s],1)),r){for(let e=0;e<4;++e)t.push(o.clone());r=!1}o.x<t[0].x&&t[0].assign(o),o.y>t[1].y&&t[1].assign(o),o.x>t[2].x&&t[2].assign(o),o.y<t[3].y&&t[3].assign(o),s.x<t[0].x&&t[0].assign(s),s.y>t[1].y&&t[1].assign(s),s.x>t[2].x&&t[2].assign(s),s.y<t[3].y&&t[3].assign(s);let c=this.findOrComputeBoxPoint(a.getStartPointIndex(),o,s,n);i.mergeEnvelope2D(c)}for(let e=0;e<t.length;++e)t[e].mulThis(this.m_rpu);return i}findOrComputeBoxSegment(e,t,n){if(!n.has(e)){let r=Y();if(t.queryEnvelope(r),this.m_bIsPannablePcs){let e=s.construct(r.xmin,r.ymin),t=s.construct(r.xmax,r.ymax);N(this.m_inputSR,0,[e],1),N(this.m_inputSR,0,[t],1),r=this.m_envHelper.calculateBbox(e.x,e.y,t.x,t.y)}return n.set(e,r),r}return n.get(e)}findOrComputeBoxPoint(e,t,n,r){if(!r.has(e)){let i=Y();return i.setCoords({xmin:t.x,ymin:t.y,xmax:n.x,ymax:n.y}),this.m_bIsPannablePcs&&(i=this.m_envHelper.calculateBbox(i.xmin,i.ymin,i.xmax,i.ymax)),r.set(e,i),i}return r.get(e)}estimateMinimumDistance(n,r){let i={stack:[],error:void 0,hasError:!1};try{let e=e=>k(this.m_a,this.m_eSquared,e),a=this.m_boundaryPtsA.map(e),o=this.m_boundaryPtsB.map(e),s=Number.MAX_VALUE,c=0,l=0;for(let e=0;e<a.length;++e)for(let t=0;t<o.length;++t){let n=b.distance(a[e],o[t]);n<s&&(s=n,c=e,l=t)}n.outPoint.assign(this.m_boundaryPtsA[c]),r.outPoint.assign(this.m_boundaryPtsB[l]);let u=t(i,new w,!1);return O.geodeticDistance(this.m_a,this.m_eSquared,this.m_boundaryPtsA[c].x,this.m_boundaryPtsA[c].y,this.m_boundaryPtsB[l].x,this.m_boundaryPtsB[l].y,u,null,null,this.m_distCurveType),u.val}catch(e){i.error=e,i.hasError=!0}finally{e(i)}}swapGeometries(e,t){return f(e[0])>f(t[0])&&(t[0]=p(e[0],e[0]=t[0]),this.m_envGeomB=p(this.m_envGeomA,this.m_envGeomA=this.m_envGeomB),!0)}canUseSpatialTree(e,t){return!1}checkGeometriesIntersect(e,t,n,r){let a=e.getGeometryType(),o=t.getGeometryType();if(this.m_envGeomA.isIntersecting(this.m_envGeomB)){if(a===i.enumPoint&&t.getDimension()===2){let i=[0],a=[e.getXY()];if(x(t,a,1,this.m_tolerance,i),i[0]!==0)return n.outPoint.assign(a[0]),r.outPoint.assign(a[0]),!0}else if(o===i.enumPoint&&e.getDimension()===2){let i=[2],a=[t.getXY()];if(x(e,a,1,this.m_tolerance,i),i[0]!==0)return n.outPoint.assign(a[0]),r.outPoint.assign(a[0]),!0}if(a===i.enumMultiPoint&&t.getDimension()===2)return this.multipointIntersectsArea(e,t,n,r);if(o===i.enumMultiPoint&&e.getDimension()===2)return this.multipointIntersectsArea(t,e,r,n);let s,c,u=e,d=t;if(a===i.enumEnvelope&&(s=this.envelopeToPolygon(e),u=s,a=i.enumPolygon),o===i.enumEnvelope&&(c=this.envelopeToPolygon(t),d=c,o=i.enumPolygon),l(a)&&l(o)){let e=u.querySegmentIterator(),t=d.querySegmentIterator(),i=I(),a=I();if(L(u,d,e,t,i,a))return n.outPoint.assign(i.outPoint),r.outPoint.assign(i.outPoint),!0}}return!1}multipointIntersectsArea(e,t,n,r){let i=e.getPointCount();for(let a=0;a<i;++a){let i=[2],o=e.getXY(a);if(x(t,[o],1,this.m_tolerance,i),i[0]!==0)return n.outPoint.assign(o),r.outPoint.assign(o),!0}return!1}getNearestNeighbourVisitor(e,t,n,r,i,a,o){return d(0),{}}buildSpatialTree(e,t){d(0)}};export{Q as n,q as r,X as t};
import{$l as e,CD as t,Dv as n,Jg as r,MC as i,OC as a,SC as o,Sv as s,Tv as c,Wl as l,_v as u,aS as d,bv as f,id as p,ih as m,kC as h,rh as g,tu as ee,vv as _,yv as te}from"./index-BqmCqmfp.js";import"./quatf64-CJzmL3cc.js";import"./vectorStacks-CKtslZxP.js";import"./plane-CTjDePZl.js";import"./projectPointToVector-Clou1sfo.js";import"./dehydratedPoint-Dwb3orme.js";import"./projectVectorToVector-D-Bbb8fP.js";import"./sphere-CicnK0Bn.js";import{o as v}from"./elevationInfoUtils-Df_uYU_q.js";import"./geodesicUtils-DJORTTMv.js";import{_ as y,c as b,g as x,h as S,i as C,l as w,o as T}from"./LineSnappingHint-BAcwqgNT.js";import{n as E}from"./ParallelSnappingHint-Knbe-U69.js";import{a as D,l as ne,o as O,r as k}from"./snappingUtils-CbrwOS61.js";import{f as A,n as j}from"./constraints-DXu8cqG3.js";import"./SnappingCandidate-BzUm7cf4.js";import{t as M}from"./LineSnappingCandidate-Cp24TJlP.js";import{n as N,t as re}from"./RightAngleTriangleSnappingCandidate-B-XFn7NT.js";import"./RightAngleSnappingHint--LJCiSno.js";import{n as ie,t as P}from"./viewUtils-CPzQ7QWB.js";import"./viewUtils-CtJQ47Dj.js";import{f as F,r as I}from"./quantityUtils-Dywg00j-.js";import{c as L,r as R}from"./angularMeasurementUtils-BFBiid4G.js";var z=class{constructor(e,t){this.view=e,this.options=t,this.squaredShortLineThreshold=E.shortLineThreshold*E.shortLineThreshold}snap(e,t){return t.vertexHandle==null?this.snapNewVertex(e,t):t.vertexHandle.type===`vertex`?this.snapExistingVertex(e,t):[]}edgeExceedsShortLineThreshold(e,t){return this.exceedsShortLineThreshold(S(e.leftVertex.pos,this.view,t),S(e.rightVertex.pos,this.view,t),t)}exceedsShortLineThreshold(e,t,{spatialReference:n}){return this.squaredShortLineThreshold===0||k(P(t,n,v,this.view),P(e,n,v,this.view))>this.squaredShortLineThreshold}isVertical(e,t,{spatialReference:n}){let r=d(n);return c(y(e),y(t))*r<E.verticalLineThresholdMeters}squaredProximityThreshold(e){return e===`touch`?this._squaredTouchProximityThreshold:this._squaredMouseProximityThreshold}get _squaredMouseProximityThreshold(){return this.options.distance*this.options.distance}get _squaredTouchProximityThreshold(){let{distance:e,touchSensitivityMultiplier:t}=this.options,n=e*t;return n*n}},B=class extends z{constructor(e,t,n){super(e,t),this._geodesicLengthMeasurementUtils=n}snapNewVertex(e,t){let n=t.editGeometryOperations.data.parts[0],r=n.segments.length,i=[];if(r<1)return i;let{spatialReference:a}=t,o=P(e,a,v,this.view),{view:s}=this,c=n.segments[r-1],l=c;do{if(O(l)&&this.edgeExceedsShortLineThreshold(l,t)){let n=D(l,s,t);this._processCandidateProposal(n.left,n.right,e,o,t,i)}l=l.leftVertex.leftSegment}while(l&&l!==c);return i}snapExistingVertex(e,t){let n=[],r=t.vertexHandle,i=r.part;if(i.segments.length<2)return n;let{view:a}=this,{spatialReference:o}=t,s=P(e,o,v,a),c=r.leftSegment,l=r.rightSegment;O(c)&&O(l)&&this.edgeExceedsShortLineThreshold(c,t)&&this.edgeExceedsShortLineThreshold(l,t)&&this._processCandidateProposal(S(c.leftVertex.pos,a,t),S(l.rightVertex.pos,a,t),e,s,t,n);let u=i.segments[0],d=u;do{if(O(d)&&d!==r.leftSegment&&d!==r.rightSegment&&this.edgeExceedsShortLineThreshold(d,t)){let r=D(d,a,t);this._processCandidateProposal(r.left,r.right,e,s,t,n)}d=d.rightVertex.rightSegment}while(d&&d!==u);return n}_processCandidateProposal(e,t,n,i,a,o){let{spatialReference:s,pointer:c}=a,l=r();V(l,e,t,n,a,this._geodesicLengthMeasurementUtils);let u=x(w(l));k(i,P(u,s,v,this.view))<this.squaredProximityThreshold(c)&&o.push(new M({lineStart:e,lineEnd:t,targetPoint:u,isDraped:a.elevationInfo?.mode===`on-the-ground`}))}};function V(e,t,n,r,i,a){H(e,t,n,r,i,a)||U(e,r,t,n)}function H(e,t,n,r,{spatialReference:i},a){let o=L(t,n,i,i);if(o==null)return!1;let s=L(n,r,i,i);if(s==null)return!1;let c=a.geodesicDistance(n,r,i);if(c==null)return!1;let l=Math.abs(m.shortestSignedDiff(o,s))>Math.PI/2?g.normalize(o+Math.PI):o;return R(e,n,i,F(c,`meters`),I(l,`radians`,`geographic`),`geodesic`),e[2]=r[2],!0}function U(e,t,n,r){A(t,{start:n,end:r,type:1},e),e[2]=t[2]}var W=class extends z{snapNewVertex(e,t){let n=t.editGeometryOperations.data.parts[0],r=n.segments.length,i=n.vertices.length,a=[];if(r<2)return a;let{view:o}=this,s=P(e,t.spatialReference,v,o),c=n.vertices[0],l=n.vertices[i-1],u=O(l.leftSegment)?S(l.pos,o,t):null,d=O(c.rightSegment)?S(c.pos,o,t):null,f=n.segments[r-1],p=f;do{if(O(p)&&this.edgeExceedsShortLineThreshold(p,t)){let n=D(p,o,t);u&&this._checkEdgeForParallelLines(n,u,e,s,t,a),d&&this._checkEdgeForParallelLines(n,d,e,s,t,a)}p=p.leftVertex.leftSegment}while(p&&p!==f);return a}snapExistingVertex(e,t){let n=[],r=t.vertexHandle,i=r.part;if(i.segments.length<3)return n;let{view:a}=this,o=P(e,t.spatialReference,v,a),s=r.leftSegment,c=r.rightSegment,l=i.vertices[0],u=S(l.pos,a,t),d=i.vertices.length,f=i.vertices[d-1],p=S(f.pos,a,t),m=i.segments[0],h=m;do{if(O(h)&&h!==s&&h!==c&&this.edgeExceedsShortLineThreshold(h,t)){let i=D(h,a,t);O(s)&&this._checkEdgeForParallelLines(i,S(s.leftVertex.pos,a,t),e,o,t,n),O(c)&&this._checkEdgeForParallelLines(i,S(c.rightVertex.pos,a,t),e,o,t,n),r===l?this._checkEdgeForParallelLines(i,p,e,o,t,n):r===f&&this._checkEdgeForParallelLines(i,u,e,o,t,n)}h=h.rightVertex.rightSegment}while(h&&h!==m);return n}_checkEdgeForParallelLines(e,t,n,r,i,a){let o=e.left,s=e.right;if(T(K,y(t),y(o),y(s)),_(K,y(t))<E.parallelLineThreshold)return;T(K,y(n),y(o),y(s),y(t));let{spatialReference:c,pointer:l}=i,u=x(b(K[0],K[1],n[2]));if(k(r,P(u,c,v,this.view))<this.squaredProximityThreshold(l)){if(this.isVertical(u,t,i)||this.isVertical(o,s,i)||G(e,a))return;a.push(new N({referenceLine:e,lineStart:t,targetPoint:u,isDraped:i.elevationInfo?.mode===`on-the-ground`}))}}};function G(e,t){let n=e.left,r=e.right;for(let i of t)if(T(K,y(r),y(i.constraint.start),y(i.constraint.end),y(n)),_(K,y(r))<E.parallelLineThreshold)return i.addReferenceLine(e),!0;return!1}var K=p(),q=class extends z{constructor(e,t,n){super(e,t),this._geodesicLengthMeasurementUtils=n}snapNewVertex(e,t){let n=t.editGeometryOperations.data.parts[0],r=[];if(n.vertices.length<2)return r;let{view:i}=this,a=P(e,t.spatialReference,v,i),o=n.vertices.at(-1);O(o.leftSegment)&&this._checkForSnappingCandidate(1,r,o.leftSegment,o,o.leftSegment.leftVertex,e,a,t);let s=n.vertices[0];return O(s.rightSegment)&&this._checkForSnappingCandidate(2,r,s.rightSegment,s,s.rightSegment.rightVertex,e,a,t),r}snapExistingVertex(e,t){let n=[],r=t.vertexHandle;if(r.part.vertices.length<3)return n;let{view:i}=this,a=P(e,t.spatialReference,v,i),o=r.leftSegment,s=r.rightSegment;if(O(o?.leftVertex.leftSegment)){let r=o.leftVertex.leftSegment;this._checkForSnappingCandidate(3,n,r,r.rightVertex,r.leftVertex,e,a,t)}if(O(s)&&O(s.rightVertex.rightSegment)){let r=s.rightVertex.rightSegment;this._checkForSnappingCandidate(3,n,r,r.leftVertex,r.rightVertex,e,a,t)}return n}_checkForSnappingCandidate(e,t,n,r,i,a,o,s){if(!O(n)||!this.edgeExceedsShortLineThreshold(n,s))return;let c=this.view,l=S(r.pos,c,s),u=S(i.pos,c,s);J(Z,u,l,a,s,this._geodesicLengthMeasurementUtils),this._checkForSnappingCandidateAlongProjectedRay(e,t,u,l,Z,a,o,s)}_checkForSnappingCandidateAlongProjectedRay(e,t,i,a,o,c,l,u){let{spatialReference:d,pointer:p}=u,m=f(X,y(c),y(a)),h=s(o,m)/n(o),g=te(X,y(a),o,h),_=x(b(g[0],g[1],c[2]));if(k(l,P(_,d,v,this.view))>this.squaredProximityThreshold(p)||this.isVertical(_,a,u)||this.isVertical(a,i,u))return;let S=ee(r(),a,o,Math.sign(h));t.push(new ie({targetPoint:_,constraint:new j(a,w(S)),previousVertex:i,otherVertex:a,otherVertexType:1,selfSnappingType:e,isDraped:u.elevationInfo?.mode===`on-the-ground`}))}};function J(e,t,n,r,i,a){Y(e,t,n,r,i,a)||ae(e,t,n)}function Y(e,t,n,i,{spatialReference:a},o){let s=L(t,n,a,a);if(s==null)return!1;let c=L(n,i,a,a);if(c==null)return!1;let u=Math.sign(g.shortestSignedDiff(s,c))*Math.PI*.5,d=I(s+u,`radians`,`geographic`),f=r(),p=o.geodesicDistance(n,i,a);return p!=null&&(R(f,n,a,F(p,`meters`),d,`geodesic`),l(e,f,n),!0)}function ae(t,n,r){let i=f(X,y(r),y(n));e(t,i[1],-i[0],0)}var X=p(),Z=r(),oe=class extends z{snapNewVertex(e,t){let n=t.editGeometryOperations.data.parts[0],r=[],i=n.vertices.length;if(t.editGeometryOperations.data.type!==`polygon`||i<2)return r;let{view:a}=this,o=n.vertices[0],s=n.vertices[i-1];if(s.leftSegment&&s.leftSegment.type!==`line`||s.rightSegment&&s.rightSegment.type!==`line`)return r;let c=S(o.pos,a,t),l=S(s.pos,a,t);return this._processCandidateProposal(c,l,e,t,r),r}snapExistingVertex(e,t){let n=[],r=t.vertexHandle,i=r.part;if(i.segments.length<2||t.editGeometryOperations.data.type===`polyline`&&(r.index===0||r.index===i.vertices.length-1)||r.leftSegment?.type!==`line`||r.rightSegment?.type!==`line`)return n;let{view:a}=this,o=S(r.leftSegment.leftVertex.pos,a,t),s=S(r.rightSegment.rightVertex.pos,a,t);return this._processCandidateProposal(o,s,e,t,n),n}_processCandidateProposal(e,t,n,r,i){if(!this.exceedsShortLineThreshold(e,t,r))return;let a=u(Q,y(e),y(t),.5),o=.5*c(y(e),y(t)),s=C(Q,y(n),a,o),l=x(b(s[0],s[1],n[2])),{spatialReference:d,pointer:f}=r,p=P(n,d,v,this.view);if(k(p,P(l,d,v,this.view))<this.squaredProximityThreshold(f)){if(this.isVertical(e,l,r)||this.isVertical(l,t,r))return;i.push(new re({targetPoint:l,point1:e,point2:t,isDraped:r.elevationInfo?.mode===`on-the-ground`}))}}},Q=p(),$=class extends a{constructor(e){super(e),this.updating=!1,this._snappers=new o,this._domain=2}initialize(){this._snappers.push(new W(this.view,this.options),new B(this.view,this.options,this.geodesicLengthMeasurementUtils),new q(this.view,this.options,this.geodesicLengthMeasurementUtils),new oe(this.view,this.options))}set options(e){this._set(`options`,e);for(let t of this._snappers)t.options=e}async fetchCandidates(e,t,n){if(!(t&this._domain&&this.options.effectiveSelfEnabled))return[];let r=[];for(let t of this._snappers.items)for(let i of t.snap(e,n))r.push(i);return ne(e,r),r}};t([i({readOnly:!0})],$.prototype,`updating`,void 0),t([i({constructOnly:!0})],$.prototype,`view`,void 0),t([i({constructOnly:!0})],$.prototype,`geodesicLengthMeasurementUtils`,void 0),t([i()],$.prototype,`options`,null),$=t([h(`esri.views.interactive.snapping.SelfSnappingEngine`)],$);export{$ as SelfSnappingEngine};
const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/uploadAssets-b_rtPlxV.js","assets/index-BqmCqmfp.js","assets/index-kIqmb12G.css","assets/quatf64-CJzmL3cc.js","assets/quat-Bk_ZaVz9.js","assets/MeshTransform-B2p38eYR.js","assets/axisAngleDegrees-Di7q97jx.js","assets/External-Cyg8cgWj.js","assets/meshSpatialReferenceScaleUtils-CQTVIwyV.js","assets/meshFeatureAttributes-DKUFwpcn.js","assets/convertMeshVertexSpace-H3sMyOMX.js","assets/vec3-40WN6G4a.js","assets/vec4-CcFo8HF1.js","assets/computeTranslationToOriginAndRotation-BC3OuSky.js","assets/projectPointToVector-Clou1sfo.js","assets/spatialReferenceEllipsoidUtils-DBtdxVkA.js","assets/MeshLocalVertexSpace-HjmVAuYa.js","assets/MeshVertexAttributes-Df5_8xlW.js","assets/meshProperties-Du90n6lL.js","assets/BufferView-DNaZpbJX.js","assets/Util-3rPi0NfK.js","assets/meshCloneUtils-Akm6YUJV.js","assets/vertexSpaceConversion-g9XG_RJW.js","assets/meshVertexSpaceUtils-Y8FeTLov.js"])))=>i.map(i=>d[i]);
import{CD as e,Cd as t,Cw as n,Dr as r,EE as i,Ia as a,Kb as o,Kw as s,Ly as c,MC as l,Nb as u,Qw as d,Sw as f,Sx as p,TE as m,Ux as h,XT as g,Yw as _,_E as v,_a as y,aC as b,bD as x,eD as S,ga as C,hC as w,ha as T,kC as E,kw as D,lr as O,ma as k,nD as A,vE as j}from"./index-BqmCqmfp.js";import{n as M}from"./MeshLocalVertexSpace-HjmVAuYa.js";import{a as N}from"./meshVertexSpaceUtils-Y8FeTLov.js";import{s as P}from"./External-Cyg8cgWj.js";import{r as F}from"./clientSideDefaults-CpyaF_rm.js";import{a as I,i as L,n as R,o as z,r as B,s as V,t as H}from"./applyEditsUtils-6Wi1ZwPV.js";import{t as U}from"./QueryTask-vPpZxMGi.js";import{n as W}from"./executeQueryJSON-BAg2ttNX.js";var G=new b({originalAndCurrentFeatures:`original-and-current-features`,none:`none`}),K=new b({Started:`published`,Publishing:`publishing`,Stopped:`unavailable`}),q=class extends w{constructor(e){super(e),this.type=`feature-layer`,this.supportedSourceTypes=new Set([`Feature Layer`,`Oriented Imagery Layer`,`Table`,`Catalog Layer`]),this.refresh=s(async()=>{await this.load();let e=this.sourceJSON.editingInfo?.lastEditDate;if(e==null)return{dataChanged:!0,updates:{}};try{await this._fetchService(null)}catch{return{dataChanged:!0,updates:{}}}let t=e!==this.sourceJSON.editingInfo?.lastEditDate;return{dataChanged:t,updates:t?{editingInfo:this.sourceJSON.editingInfo,extent:this.sourceJSON.extent}:null}}),this._ongoingAssetUploads=new Map}load(e){let t=this.layer.sourceJSON,n=this._fetchService(t,{...e}).then(()=>this.layer.setUserPrivileges(this.sourceJSON.serviceItemId,e)).then(()=>this._ensureLatestMetadata(e));return this.addResolvingPromise(n),Promise.resolve(this)}initialize(){this.addHandles([o(()=>{let e=this.layer;return e&&`lastEditsEventDate`in e?e.lastEditsEventDate:null},e=>this._handleLastEditsEventChange(e))])}destroy(){this._removeEditInterceptor()}get queryTask(){let{capabilities:e,parsedUrl:t,gdbVersion:n,spatialReference:r,fieldsIndex:i,uniqueIdFields:a}=this.layer,o=`infoFor3D`in this.layer?this.layer.infoFor3D:null,s=`dynamicDataSource`in this.layer?this.layer.dynamicDataSource:null,c=x(`featurelayer-pbf`)&&e?.query.supportsFormatPBF&&o==null;return new U({dynamicDataSource:s,fieldsIndex:i,gdbVersion:n,infoFor3D:o,pbfSupported:c,queryAttachmentsSupported:e?.operations?.supportsQueryAttachments??!1,sourceSpatialReference:r,uniqueIdFields:a,url:t.path})}async addAttachment(e,t){await this.load();let{layer:n}=this;await r(n,`editing`);let i=e.attributes[n.objectIdField],a=n.parsedUrl.path+`/`+i+`/addAttachment`,o=this._getLayerRequestOptions(),s=this._getFormDataForAttachment(t,o.query);try{let e=await f(a,{body:s});return R(e.data.addAttachmentResult)}catch(e){throw this._createAttachmentErrorResult(i,e)}}async updateAttachment(e,t,n){await this.load();let{layer:i}=this;await r(i,`editing`);let a=e.attributes[i.objectIdField],o=i.parsedUrl.path+`/`+a+`/updateAttachment`,s=this._getLayerRequestOptions({query:{attachmentId:t}}),c=this._getFormDataForAttachment(n,s.query);try{let e=await f(o,{body:c});return R(e.data.updateAttachmentResult)}catch(e){throw this._createAttachmentErrorResult(a,e)}}async applyEdits(e,t){await this.load();let{layer:n}=this;await r(n,`editing`);let i=`infoFor3D`in n?n.infoFor3D:null,o=i!=null,s=o||(t?.globalIdUsed??!1),c=o?await this._uploadMeshesAndGetAssetMapEditsJSON(e):null,l=e.addFeatures?.map(e=>z(this.layer,e,i))??[],u=(await Promise.all(l)).filter(A),d=e.updateFeatures?.map(e=>z(this.layer,e,i))??[],p=(await Promise.all(d)).filter(A),m=B(this.layer,e.deleteFeatures,s);a(u,p,n.spatialReference);let h=await L(this.layer,e),g=n.capabilities.editing.supportsAsyncApplyEdits&&o,_=t?.gdbVersion||n.gdbVersion,b={gdbVersion:_,rollbackOnFailure:t?.rollbackOnFailureEnabled,useGlobalIds:s,returnEditMoment:t?.returnEditMoment,usePreviousEditMoment:t?.usePreviousEditMoment,async:g};await T(this.layer.url,_,!0);let x=k(this.layer.url,_||null);if(await C(n.url,_,n.historicMoment))throw new v(`feature-layer-source:historic-version`,`Editing a historic version is not allowed`);t?.returnServiceEditsOption?(b.edits=JSON.stringify([{id:n.layerId,adds:u.length?u:null,updates:p.length?p:null,deletes:m.length?m:null,attachments:h,assetMaps:c}]),b.returnServiceEditsOption=G.toJSON(t?.returnServiceEditsOption),b.returnServiceEditsInSourceSR=t?.returnServiceEditsInSourceSR):(b.adds=u.length?JSON.stringify(u):null,b.updates=p.length?JSON.stringify(p):null,b.deletes=m.length?s?JSON.stringify(m):m.join(`,`):null,b.attachments=h&&JSON.stringify(h),b.assetMaps=c==null?void 0:JSON.stringify(c));let S=this._getLayerRequestOptions({method:`post`,query:b});x&&(S.authMode=`immediate`,S.query.returnEditMoment=!0,S.query.sessionId=y);let w=t?.returnServiceEditsOption?n.url:n.parsedUrl.path,E;try{E=g?await this._asyncApplyEdits(w+`/applyEdits`,S):await f(w+`/applyEdits`,S)}catch(e){if(!I(e))throw e;S.authMode=`immediate`,E=g?await this._asyncApplyEdits(w+`/applyEdits`,S):await f(w+`/applyEdits`,S)}return this._createEditsResult(E)}async deleteAttachments(e,t){await this.load();let{layer:n}=this;await r(n,`editing`);let i=e.attributes[n.objectIdField],a=n.parsedUrl.path+`/`+i+`/deleteAttachments`;try{return(await f(a,this._getLayerRequestOptions({query:{attachmentIds:t.join(`,`)},method:`post`}))).data.deleteAttachmentResults.map(R)}catch(e){throw this._createAttachmentErrorResult(i,e)}}fetchRecomputedExtents(e={}){let t=e.signal;return this.load({signal:t}).then(async()=>{let t=this._getLayerRequestOptions({...e,query:{returnUpdates:!0}}),{layerId:n,url:r}=this.layer,{data:i}=await f(`${r}/${n}`,t),{id:a,extent:o,fullExtent:s,timeExtent:c}=i,l=o||s;return{id:a,fullExtent:l&&p.fromJSON(l),timeExtent:c&&u.fromJSON({start:c[0],end:c[1]})}})}async queryAttachments(e,t={}){await this.load();let n=this._getLayerRequestOptions(t);return this.queryTask.executeAttachmentQuery(e,n)}async queryFeatures(e,t){await this.load();let n=await this.queryTask.execute(e,{...t,query:this._createRequestQueryOptions(t)});if(e.outStatistics?.length&&n.features.length){let t=new Map;if(n.features.forEach(n=>{let r=n.attributes;e.outStatistics?.forEach(({outStatisticFieldName:e})=>{if(e){let n=e.toLowerCase();n&&n in r&&e!==n&&(r[e]=r[n],delete r[n],t.set(n,e))}})}),n.fields!=null)for(let e of n.fields){let n=t.get(e.name.toLowerCase());n!=null&&(e.name=n)}}return n}async queryFeaturesJSON(e,t){return await this.load(),this.queryTask.executeJSON(e,{...t,query:this._createRequestQueryOptions(t)})}async queryObjectIds(e,t){return await this.load(),this.queryTask.executeForIds(e,{...t,query:this._createRequestQueryOptions(t)})}async queryFeatureCount(e,t){return await this.load(),this.queryTask.executeForCount(e,{...t,query:this._createRequestQueryOptions(t)})}async queryExtent(e,t){return await this.load(),this.queryTask.executeForExtent(e,{...t,query:this._createRequestQueryOptions(t)})}async queryRelatedFeatures(e,t){return await this.load(),this.queryTask.executeRelationshipQuery(e,{...t,query:this._createRequestQueryOptions(t)})}async queryRelatedFeaturesCount(e,t){return await this.load(),this.queryTask.executeRelationshipQueryForCount(e,{...t,query:this._createRequestQueryOptions(t)})}async queryPivot(e,t){return await this.load(),this.queryTask.executePivotQuery(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopFeatures(e,t){return await this.load(),this.queryTask.executeTopFeaturesQuery(e,{...t,query:this._createRequestQueryOptions(t)})}async queryAttributeBins(e,t){return await this.load(),this.queryTask.executeAttributeBinsQuery(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopObjectIds(e,t){return await this.load(),this.queryTask.executeForTopIds(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopExtents(e,t){return await this.load(),this.queryTask.executeForTopExtents(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopCount(e,t){return await this.load(),this.queryTask.executeForTopCount(e,{...t,query:this._createRequestQueryOptions(t)})}async fetchPublishingStatus(){if(!D(this.layer.url))return`unavailable`;let e=g(this.layer.url,`status`),t=await f(e,{query:{f:`json`}});return K.fromJSON(t.data.status)}async uploadAssets(e,t){let{uploadAssets:r}=await n(async()=>{let{uploadAssets:e}=await import(`./uploadAssets-b_rtPlxV.js`);return{uploadAssets:e}},__vite__mapDeps([0,1,2,3,4,5,6,7,8,9]));return r(e,{layer:this.layer,ongoingUploads:this._ongoingAssetUploads},t)}_handleLastEditsEventChange(e){let t=this.layer;if(e==null||!(`capabilities`in t)||!(`effectiveCapabilities`in t)||!(!t.capabilities?.operations?.supportsEditing&&t.effectiveCapabilities?.operations?.supportsEditing))return;let n=t.url;n!=null&&(`layerId`in t&&g(n,t.layerId.toString()),this._getOrCreateEditInterceptor(n).before=t=>{let n=t.requestOptions.method??`auto`;if(n===`auto`||n===`head`){let n=t.requestOptions.query??{};n._ts=e.getTime(),t.requestOptions.query=n}})}_getOrCreateEditInterceptor(e){return this._editInterceptor??(this._editInterceptor={urls:e},m.request.internalInterceptors.push(this._editInterceptor)),this._editInterceptor}_removeEditInterceptor(){this._editInterceptor!=null&&(S(m.request.internalInterceptors,this._editInterceptor),this._editInterceptor=null)}async _asyncApplyEdits(e,t){let n=(await f(e,t)).data.statusUrl;for(;;){let e=(await f(n,{query:{f:`json`},responseType:`json`})).data;switch(e.status){case`Completed`:return f(e.resultUrl,{query:{f:`json`},responseType:`json`});case`CompletedWithErrors`:throw new v(`async-applyEdits-failed`,`asynchronous applyEdits call failed.`);case`Failed ImportChanges`:case`InProgress`:case`Pending`:case`ExportAttachments`:case`ExportChanges`:case`ExportingData`:case`ExportingSnapshot`:case`ImportAttachments`:case`ProvisioningReplica`:case`UnRegisteringReplica`:break;default:throw new v(`async-applyEdits-failed`,`asynchronous applyEdits call failed (undefined response status)`)}await _(J)}}_createRequestQueryOptions(e){let t={...this.layer.customParameters,token:this.layer.apiKey,...e?.query};return this.layer.datesInUnknownTimezone&&(t.timeReferenceUnknownClient=!0),t}async _fetchService(e,t){if(!e){let n={};x(`featurelayer-advanced-symbols`)&&(n.returnAdvancedSymbols=!0),t?.cacheBust&&(n._ts=Date.now());let{data:r}=await f(this.layer.parsedUrl.path,this._getLayerRequestOptions({query:n,signal:t?.signal}));e=r}this.layer.applyPreferredHost(e),this.sourceJSON=await this._patchServiceJSON(e,t?.signal);let n=e.type;if(!this.supportedSourceTypes.has(n))throw new v(`feature-layer-source:unsupported-type`,`Source type "${n}" is not supported`)}async _patchServiceJSON(e,t){if(e.type!==`Table`&&e.geometryType&&!e?.drawingInfo?.renderer&&!e.defaultSymbol){let t=F(e.geometryType).renderer;i(`drawingInfo.renderer`,t,e)}if(e.geometryType===`esriGeometryMultiPatch`&&e.infoFor3D&&(e.geometryType=`mesh`),e.extent==null)try{let{data:n}=await f(this.layer.url,this._getLayerRequestOptions({signal:t}));n.spatialReference&&(e.extent={xmin:0,ymin:0,xmax:0,ymax:0,spatialReference:n.spatialReference})}catch(e){d(e)}return e}async _ensureLatestMetadata(e){if(this.layer.userHasUpdateItemPrivileges&&this.sourceJSON.cacheMaxAge>0)return this._fetchService(null,{...e,cacheBust:!0})}async _uploadMeshesAndGetAssetMapEditsJSON(e){let{addAssetFeatures:t}=e;if(!t?.length||await this._areAllAssetsAlreadyMapped(t))return null;let r=e.addFeatures.filter(e=>e.geometry);if(t.length!==r.length+e.updateFeatures.length)throw new v(`feature-layer-source:unsupported-mesh-edits`,`Mixing attribute only edits with mesh geometry edits is not currently supported`);let i=[],a=new Map;for(let e of t){let{geometry:t}=e,{vertexSpace:r}=t;if(N(r))i.push(t);else{let r=t.origin,{convertMeshVertexSpace:o}=await n(async()=>{let{convertMeshVertexSpace:e}=await import(`./convertMeshVertexSpace-H3sMyOMX.js`);return{convertMeshVertexSpace:e}},__vite__mapDeps([10,1,2,11,12,13,14,15,16,17,18,19,20,21,22,23])),s=await o(t,new M({origin:[r.x,r.y,r.z??0]}));a.set(s,t),e.geometry=s,i.push(s)}}await this.uploadAssets(i);for(let[e,t]of a)t.addExternalSources(e.metadata.externalSources.items);return{adds:this._getAssetMapEditsJSON(t),updates:[],deletes:[]}}_getAssetMapEditsJSON(e){let t=[],n=this.layer.globalIdField,r=this.layer.parsedUrl;for(let i of e){let{metadata:e}=i.geometry,a=e.getExternalSourcesOnService(r),o=i.getAttribute(n);if(a.length===0){j.getLogger(this).error(`Skipping feature ${o}. The mesh it is associated with has not been uploaded to the service and cannot be mapped to it.`);continue}let{source:s}=a.find(P)??a[0];for(let e of s.assets)e.parts.length===1?t.push({globalId:c(),parentGlobalId:o,assetName:e.assetName,assetHash:e.parts[0].partHash,flags:[]}):j.getLogger(this).error(`Skipping asset ${e.assetName}. It does not have exactly one part, so we cannot map it to a feature.`)}return t}_createEditsResult(e){let t=e.data,{layerId:n}=this.layer,r=[],i=null;if(Array.isArray(t))for(let e of t)r.push({id:e.id,editedFeatures:e.editedFeatures}),e.id===n&&(i={addResults:e.addResults??[],updateResults:e.updateResults??[],deleteResults:e.deleteResults??[],attachments:e.attachments,editMoment:e.editMoment});else i=t;let a=V(i);if(r.length>0){a.editedFeatureResults=[];for(let e of r){let{editedFeatures:t}=e,n=t?.spatialReference?new h(t.spatialReference):null;a.editedFeatureResults.push({layerId:e.id,editedFeatures:H(t,n)})}}return a}_createAttachmentErrorResult(e,t){let n=t.details.messages?.[0]||t.message,r=t.details.httpStatus||t.details.messageCode;return{objectId:e,globalId:null,error:new v(`feature-layer-source:attachment-failure`,n,{code:r})}}_getFormDataForAttachment(e,t){let n=e instanceof FormData?e:e&&e.elements?new FormData(e):null;if(n)for(let e in t){let r=t[e];r!=null&&(n.set?n.set(e,r):n.append(e,r))}return n}_getLayerRequestOptions(e={}){let{layer:t,layer:{parsedUrl:n,gdbVersion:r}}=this;return{...e,query:{gdbVersion:r,layer:`dynamicDataSource`in t&&t.dynamicDataSource?JSON.stringify({source:t.dynamicDataSource}):void 0,...n.query,f:`json`,...this._createRequestQueryOptions(e)},responseType:`json`}}async _areAllAssetsAlreadyMapped(e){let{layer:n}=this,{globalIdField:r,parsedUrl:i}=n,a=`infoFor3D`in n?n.infoFor3D:null;if(a==null||r==null)return!1;let o=O(a);if(o==null)return!1;let s=g(i.path,`../${o.id}`),c=[];for(let t of e){if(!(t.geometry.metadata.getExternalSourcesOnService(i).length>0))return!1;c.push(t)}let l=c.map(e=>e.getAttribute(r)).filter(A);if(l.length===0)return!1;let{assetMapFieldRoles:{parentGlobalId:u,assetHash:d}}=a,f=new t({where:`${u} IN (${l.map(e=>`'${e}'`)})`,outFields:[d,u],returnGeometry:!1}),{features:p}=await W(s,f);return p.length!==0&&!c.some(e=>{let t=e.getAttribute(r);if(!t)return!0;let{metadata:n}=e.geometry,a=p.filter(e=>e.getAttribute(u)===t);if(a.length===0)return!0;let o=a.map(e=>e.getAttribute(d));return n.getExternalSourcesOnService(i).flatMap(({source:e})=>e.assets.flatMap(e=>e.parts.map(e=>e.partHash))).some(e=>o.every(t=>e!==t))})}};e([l()],q.prototype,`type`,void 0),e([l({constructOnly:!0})],q.prototype,`layer`,void 0),e([l({constructOnly:!0})],q.prototype,`supportedSourceTypes`,void 0),e([l({readOnly:!0})],q.prototype,`queryTask`,null),q=e([E(`esri.layers.graphics.sources.FeatureLayerSource`)],q);var J=1e3;export{q as t};
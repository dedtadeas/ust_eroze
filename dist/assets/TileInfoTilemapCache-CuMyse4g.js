import{Zw as e,_E as t,qw as n}from"./index-BqmCqmfp.js";var r=class{constructor(e,t=0,n=e.lods[e.lods.length-1].level){this.tileInfo=e,this.minLOD=t,this.maxLOD=n,e.lodAt(t)||(this.minLOD=e.lods[0].level),e.lodAt(n)||(this.maxLOD=e.lods[e.lods.length-1].level)}get effectiveMinLOD(){return this.minLOD??this.tileInfo.lods[0].level}get effectiveMaxLOD(){return this.maxLOD??this.tileInfo.lods[this.tileInfo.lods.length-1].level}getAvailability(e,t,n){let r=this.tileInfo?.lodAt(e);return!r||e<this.minLOD||e>this.maxLOD?`unavailable`:r.cols&&r.rows?n>=r.cols[0]&&n<=r.cols[1]&&t>=r.rows[0]&&t<=r.rows[1]?`unknown`:`unavailable`:`unknown`}async fetchAvailability(e,r,i,a){await n(a);let o=this.getAvailability(e,r,i);if(o===`unavailable`)throw new t(`tile-map:tile-unavailable`,`Tile is not available`,{level:e,row:r,col:i});return o}async fetchAvailabilityUpsample(t,r,i,a,o){await n(o),a.level=t,a.row=r,a.col=i;let s=this.tileInfo;return s.updateTileInfo(a),this.fetchAvailability(t,r,i,o).catch(t=>{if(e(t))throw t;if(s.upsampleTile(a))return this.fetchAvailabilityUpsample(a.level,a.row,a.col,a,o);throw t})}};export{r as t};
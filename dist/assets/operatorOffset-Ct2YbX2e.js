import{n as e,t}from"./SimpleGeometryCursor-CI9GIWKa.js";import{A as n,cn as r,dn as i,et as a,in as o,k as s,kt as c,mn as l,nt as u,wn as d}from"./Point2D-UYEfE6HP.js";import{dn as f,mn as p,qt as m,sn as h}from"./UnitFactory-J9WMNXdY.js";function g(e,t,n,r,i,a){if(e===null&&o(``),e.getDimension()<1&&o(``),i>0||o(``),l(e),t===0||e.isEmpty())return e;let s=new w(a);return s.m_bUseZ=e.hasAttribute(1),s.m_bUseM=e.hasAttribute(2),s.m_inputGeometry=e,s.m_distance=t,s.m_tolerance=i,s.m_joins=n,s.m_miterLimit=r>1?r:1,s.m_progressCounter=0,s.constructOffset()}var _=1.4142135623730951,v=.017453292519943295,y=256,b=512,x=1024,S=class e{static construct(t,n,r){let i=new e;return i.x=t.x,i.y=t.y,i.m_next=-1,i.m_prev=-1,i.z=n,i.m=r,i.type=0,i}clone(){let t=new e;return t.x=this.x,t.y=this.y,t.m_next=this.m_next,t.m_prev=this.m_prev,t.z=this.z,t.m=this.m,t.type=this.type,t}asPoint2D(){return new c(this.x,this.y)}};function C(){return{pt:new S,bAtExistingPt:!1}}var w=class e{constructor(e){this.m_distance=-1,this.m_tolerance=-1,this.m_miterLimit=10,this.m_joins=0,this.m_progressCounter=0,this.m_bUseZ=!1,this.m_bUseM=!1,this.m_srcPts=[],this.m_srcPtCount=0,this.m_offsetPts=[],this.m_offsetPtCount=0,this.m_a1=0,this.m_a2=0,this.m_progressTracker=e}constructOffset(){let e=this.m_inputGeometry.getGeometryType();if(e===r.enumLine)return this.offsetLine();if(e===r.enumEnvelope)return this.offsetEnvelope();if(i(e)){let e=new m;return e.addSegment(this.m_inputGeometry,!0),this.m_inputGeometry=e,this.constructOffset()}if(e===r.enumPolyline){let e=new m;return this.offsetMultiPath(e),e}if(e===r.enumPolygon){let e=new h;return this.offsetMultiPath(e),e}d(``)}offsetLine(){let e=this.m_inputGeometry,t=e.getStartXY(),n=e.getEndXY(),r=new c;r.setSub(n,t),r.normalize(),r.leftPerpendicularThis(),r.scale(this.m_distance),t.addThis(r),n.addThis(r);let i=e.clone();return i.setStartXY(t),i.setEndXY(n),i}offsetEnvelope(){let e=this.m_inputGeometry;if(this.m_distance>0&&this.m_joins!==2){let t=new h;return t.addEnvelope(e,!1),this.m_inputGeometry=t,this.constructOffset()}let t=e.clone();return t.inflateCoords(this.m_distance,this.m_distance),t}progress(){}static buildPoint(e,t,n,r){r.x=e.x+t*Math.cos(n),r.y=e.y+t*Math.sin(n),r.type=e.type,r.z=e.z,r.m=e.m,r.m_next=-1,r.m_prev=-1}addPoint(e){this.m_offsetPts.push(e.clone()),this.m_offsetPtCount++}addPointEx(t,n){if(this.m_offsetPtCount===0)return void this.addPoint(t);let r=this.m_srcPtCount,i=this.m_srcPts[n===0?r-1:n-1],a=this.m_srcPts[n],o=e.dotSign(i,a,this.m_offsetPts[this.m_offsetPtCount-1],t);if(o>0)this.addPoint(t);else if(o<0)if(e.dotSign(i,a,a,this.m_offsetPts[this.m_offsetPtCount-1])>0){let a=new S,o;o=n===0?r-2:n===1?r-1:n-2;let s=this.m_srcPts[o],c=Math.atan2(i.y-s.y,i.x-s.x);if(e.buildPoint(i,this.m_distance,c-u,a),this.m_offsetPts[this.m_offsetPtCount-1]=a.clone(),this.m_joins===1||this.m_joins===2){a.x=.5*(a.x+i.x),a.y=.5*(a.y+i.y),this.addPoint(a),e.buildPoint(i,this.m_distance,this.m_a1+u,a);let t=a.clone();t.x=.5*(t.x+i.x),t.y=.5*(t.y+i.y),t.type|=y,this.addPoint(t),this.addPoint(a)}else e.buildPoint(i,this.m_distance,this.m_a1+u,a),a.type|=y,this.addPoint(a);this.addPointEx(t,n)}else{let t=new S;if(e.buildPoint(a,this.m_distance,this.m_a1+u,t),this.addPoint(t),this.m_joins===1||this.m_joins===2){t.x=.5*(t.x+a.x),t.y=.5*(t.y+a.y),this.addPoint(t),e.buildPoint(a,this.m_distance,this.m_a2-u,t);let n=t.clone();n.x=.5*(n.x+a.x),n.y=.5*(n.y+a.y),n.type|=y,this.addPoint(n),this.addPoint(t)}else e.buildPoint(a,this.m_distance,this.m_a2-u,t),t.type|=y,this.addPoint(t)}}buildOffset(){let t=new S,r=this.m_srcPtCount;this.m_offsetPtCount=0;let i=.5*this.m_tolerance,a=0,o=0;for(let s=0;s<r;s++){let l=this.m_srcPts[s],d=s===0?this.m_srcPts[r-1]:this.m_srcPts[s-1],f=s===r-1?this.m_srcPts[0]:this.m_srcPts[s+1],p,m,h=0;{let e=d.x-l.x,t=d.y-l.y,n=f.x-l.x,r=f.y-l.y;p=Math.atan2(t,e),m=Math.atan2(r,n),this.m_a1=p,this.m_a2=m,s===0&&(a=p,o=m),h=c.orientationRobust(l.asPoint2D(),d.asPoint2D(),f.asPoint2D())}let g=m;if(m<p&&(m+=n),!(Math.abs(Math.abs(p-m)-Math.PI)<1e-8))if(h*this.m_distance>0)if(this.m_joins===1||this.m_joins===2){e.buildPoint(l,this.m_distance,p+u,t),this.addPoint(t);let n=.001;t.x=l.x+(t.x-l.x)*n,t.y=l.y+(t.y-l.y)*n,this.addPoint(t),e.buildPoint(l,this.m_distance,m-u,t);let r=t.clone();r.x=l.x+(r.x-l.x)*n,r.y=l.y+(r.y-l.y)*n,r.type|=y,this.addPoint(r),this.addPoint(t)}else{let n=.5*(m-p),r=n===0?this.m_distance:this.m_distance/Math.abs(Math.sin(n));e.buildPoint(l,r,.5*(p+m),t),this.addPointEx(t,s)}else{if(l.type&b){let n=1-i/Math.abs(this.m_distance),r=1,a=this.m_distance<0?-Math.PI:Math.PI;if(n>-1&&n<1){let e=2*Math.acos(n);e<v&&(e=v),r=Math.trunc(Math.PI/e+1.5),r>1&&(a/=r)}r<=1&&(r=2,a/=2);let o=p+u;e.buildPoint(l,this.m_distance,o,t),s===0&&(t.type|=x),this.addPointEx(t,s);let c=this.m_distance/Math.cos(a/2);for(o+=a/2,e.buildPoint(l,c,o,t),t.type|=x,this.addPoint(t);--r>0;)o+=a,e.buildPoint(l,c,o,t),t.type|=x,this.addPoint(t);e.buildPoint(l,this.m_distance,m-u,t),t.type|=x,this.addPoint(t);continue}if(this.m_joins!==1){if(this.m_joins===0){let n=1-i/Math.abs(this.m_distance),r=1,a=m-u-(p+u);if(n>-1&&n<1){let e=2*Math.acos(n);e<v&&(e=v),r=Math.trunc(Math.abs(a)/e+1.5),r>1&&(a/=r)}let o=this.m_distance/Math.cos(.5*a),c=p+u+.5*a;for(e.buildPoint(l,o,c,t),this.addPointEx(t,s);--r>0;)c+=a,e.buildPoint(l,o,c,t),this.addPoint(t);continue}if(this.m_joins===2){let n=d.x-l.x,r=d.y-l.y,i=f.x-l.x,a=f.y-l.y,o=(n*i+r*a)/Math.sqrt(n*n+r*r)/Math.sqrt(i*i+a*a);if(o=Math.max(o,-1),o>.99999999){e.buildPoint(l,_*this.m_distance,m-.25*Math.PI,t),this.addPointEx(t,s),e.buildPoint(l,_*this.m_distance,m+.25*Math.PI,t),this.addPoint(t);continue}let u=Math.abs(this.m_distance/Math.sin(.5*Math.acos(o))),h=Math.abs(this.m_miterLimit*this.m_distance);if(u>h){let n=.5*(m-p),r=this.m_distance/Math.abs(Math.sin(n));e.buildPoint(l,r,.5*(p+m),t);let i=c.construct(t.x,t.y),a=c.construct(l.x,l.y),o=new c;o.setSub(i,a);let d=new c;d.setScaleAdd(h/o.length(),o,a);let f=Math.sqrt(u*u-this.m_distance*this.m_distance),g=(u-h)*Math.abs(this.m_distance)/f;this.m_distance>0?o.rightPerpendicularThis():o.leftPerpendicularThis(),o.scale(g/o.length());let _=new c;_.setAdd(d,o);let v=new c;v.setSub(d,o),t.x=_.x,t.y=_.y,this.addPointEx(t,s),t.x=v.x,t.y=v.y,this.addPoint(t);continue}let g=.5*(m-p),v=this.m_distance/Math.abs(Math.sin(g));e.buildPoint(l,v,.5*(p+m),t),this.addPointEx(t,s);continue}{let r;if(m=g,this.m_distance>0?(m>p&&(m-=n),r=p-m<u):(m<p&&(m+=n),r=m-p<u),r){let n=this.m_distance*_,r;r=n<0?p+.25*Math.PI:p+3*Math.PI*.25,e.buildPoint(l,n,r,t),this.addPointEx(t,s),r=n<0?m-.25*Math.PI:m-3*Math.PI*.25,e.buildPoint(l,n,r,t),this.addPoint(t)}else{let r=.5*(m-p),i=this.m_distance/Math.abs(Math.sin(r));m<p&&(m+=n),e.buildPoint(l,i,(p+m)/2,t),this.addPointEx(t,s)}}}else e.buildPoint(l,this.m_distance,p+u,t),this.addPointEx(t,s),e.buildPoint(l,this.m_distance,m-u,t),this.addPoint(t)}}return this.m_a1=a,this.m_a2=o,this.addPointEx(this.m_offsetPts[0],0),this.m_offsetPts[0]=this.m_offsetPts[this.m_offsetPtCount-1].clone(),this.removeBadSegsFast()}removeBadSegsFast(){let e=!1;for(let e=0;e<this.m_offsetPtCount;e++){let t=this.m_offsetPts[e];t.m_next=e+1,t.m_prev=e-1}this.m_offsetPts[0].m_prev=this.m_offsetPtCount-2,this.m_offsetPts[this.m_offsetPtCount-2].m_next=0;let t=0;for(let n=0;n<this.m_offsetPtCount;n++)if(this.m_offsetPts[t].type&y){let n=this.deleteClosedSeg(t);if(n===-1){e=!0;break}t=n}else t=this.m_offsetPts[t].m_next;return!e&&(this.compressOffsetArray(t),!0)}deleteClosedSeg(e){let t=this.m_offsetPtCount-1,n,r,i=e;for(let a=1;a<=t-2;a++){i=this.m_offsetPts[i].m_next,n=i,r=e;for(let e=1;e<=a;e++){if(r=this.m_offsetPts[r].m_prev,(this.m_offsetPts[r].type&y)===0&&(this.m_offsetPts[n].type&y)===0){let e=this.handleClosedIntersection(r,n);if(e!==-1)return e}n=this.m_offsetPts[n].m_prev}}return-1}handleClosedIntersection(e,t){let n=this.m_offsetPts[this.m_offsetPts[e].m_prev],r=this.m_offsetPts[e],i=this.m_offsetPts[this.m_offsetPts[t].m_prev],a=this.m_offsetPts[t];if(!this.sectGraphicRect(n,r,i,a))return-1;let o=C();if(((r.x-n.x)*(a.y-i.y)-(r.y-n.y)*(a.x-i.x))*this.m_distance<0&&this.findIntersection(n,r,i,a,o)&&!o.bAtExistingPt){let s=1e-8,c=Math.sqrt((r.x-n.x)*(r.x-n.x)+(r.y-n.y)*(r.y-n.y)),l=(r.x-n.x)/c,u=(r.y-n.y)/c,d=Math.sqrt((a.x-i.x)*(a.x-i.x)+(a.y-i.y)*(a.y-i.y)),f=(a.x-i.x)/d,p=(a.y-i.y)/d,m=!1,h=o.pt.clone();h.x+=(l+f)*s,h.y+=(u+p)*s;let g=i,_=o.pt,v=this.m_offsetPts[e].m_prev;for(;_.y>h.y!=g.y>h.y&&h.x<(g.x-_.x)*(h.y-_.y)/(g.y-_.y)+_.x&&(m=!m),g=_,v=this.m_offsetPts[v].m_next,v!==t;)_=this.m_offsetPts[v];if(m)return-1;let y=this.m_offsetPts[e].m_prev;return o.pt.type=r.type,o.pt.m_next=t,o.pt.m_prev=y,this.m_offsetPts[e]=o.pt,this.m_offsetPts[t].m_prev=e,t}return-1}sectGraphicRect(e,t,n,r){return Math.max(e.x,t.x)>=Math.min(n.x,r.x)&&Math.max(n.x,r.x)>=Math.min(e.x,t.x)&&Math.max(e.y,t.y)>=Math.min(n.y,r.y)&&Math.max(n.y,r.y)>=Math.min(e.y,t.y)}findIntersection(e,t,n,r,i){let a,o,s,c;return i.bAtExistingPt=!1,a=(t.y-e.y)*(r.x-n.x)-(t.x-e.x)*(r.y-n.y),o=(n.y-e.y)*(t.x-e.x)-(n.x-e.x)*(t.y-e.y),s=a===0?2:o/a,s>=0&&s<=1&&(c=s,a=(r.y-n.y)*(t.x-e.x)-(r.x-n.x)*(t.y-e.y),o=(e.y-n.y)*(r.x-n.x)-(e.x-n.x)*(r.y-n.y),s=a===0?2:o/a,s>=0&&s<=1)&&(i.pt.x=e.x+s*(t.x-e.x),i.pt.y=e.y+s*(t.y-e.y),this.m_bUseZ&&(i.pt.z=n.z+c*(r.z-n.z)),this.m_bUseM&&(i.pt.m=n.m+c*(r.m-n.m)),c!==0&&c!==1||s!==0&&s!==1||(i.bAtExistingPt=!0),!((c===0||c===1)&&s>0&&s<1||(s===0||s===1)&&c>0&&c<1))}compressOffsetArray(e){for(;this.m_offsetPts[e].m_prev<e;)e=this.m_offsetPts[e].m_prev;let t=0,n=e;do{let e=this.m_offsetPts[n].clone();this.m_offsetPts[t]=e,n=e.m_next,t++}while(n!==e);this.m_offsetPts[t]=this.m_offsetPts[0].clone(),this.m_offsetPtCount=t+1}addPart(e,t){if(!(t<2))for(let n=0;n<t;n++){let t=this.m_offsetPts[e+n];if(n?this.m_bUseZ?this.m_resultPath.lineTo3DCoords(t.x,t.y,t.z):this.m_resultPath.lineToCoords(t.x,t.y):this.m_bUseZ?this.m_resultPath.startPath3DCoords(t.x,t.y,t.z):this.m_resultPath.startPathCoords(t.x,t.y),this.m_bUseM){let e=this.m_resultPath.getPointCount()-1;this.m_resultPath.setAttribute(2,e,0,t.m)}}}offsetMultiPath(e){let t=f(this.m_inputGeometry,0,this.m_tolerance,0,this.m_progressTracker,12e3),n=t.querySegmentIterator();n.resetToFirstPath();let r=-1;for(;n.nextPath();)r++,this.offsetPath(t,r,e)}offsetPath(e,t,n){let r=e.getPathStart(t),i=e.getPathEnd(t);if(this.m_resultPath=n,e.isClosedPath(t)){let t=e.getXY(r);for(;i>r&&e.getXY(i-1).equals(t);)i--;if(i-r>=2){this.m_srcPtCount=i-r,this.m_srcPts.length=this.m_srcPtCount;for(let t=r;t<i;t++)this.progress(),this.m_srcPts[t-r]=S.construct(e.getXY(t),this.m_bUseZ?e.getAttributeAsDbl(1,t,0):0,this.m_bUseM?e.getAttributeAsDbl(2,t,0):0);this.buildOffset()&&this.addPart(0,this.m_offsetPtCount-1)}}else{let t=e.getXY(r);for(;r<i-1&&e.getXY(r+1).equals(t);)r++;let n=e.getXY(i-1);for(;r<i-1&&e.getXY(i-2).equals(n);)i--;if(i-r>=2){this.m_srcPtCount=2*(i-r)-2,this.m_srcPts.length=this.m_srcPtCount;let n=S.construct(t,this.m_bUseZ?e.getAttributeAsDbl(1,r,0):0,this.m_bUseM?e.getAttributeAsDbl(2,r,0):0);n.type|=b+x,this.m_srcPts[0]=n;let a=1,o=this.m_srcPtCount-1;for(let t=r+1;t<i-1;t++,a++,o--)this.progress(),n=S.construct(e.getXY(t),this.m_bUseZ?e.getAttributeAsDbl(1,t,0):0,this.m_bUseM?e.getAttributeAsDbl(2,t,0):0),this.m_srcPts[a]=n.clone(),n.type|=x,this.m_srcPts[o]=n.clone();if(n=S.construct(e.getXY(i-1),this.m_bUseZ?e.getAttributeAsDbl(1,i-1,0):0,this.m_bUseM?e.getAttributeAsDbl(2,i-1,0):0),n.type|=b,this.m_srcPts[a]=n.clone(),this.buildOffset())if(this.m_offsetPts.length>=2){let e=-1,t=-1,n=(this.m_offsetPts[this.m_offsetPtCount-1].type&x)!==0;n||(e=0);for(let r=1;r<this.m_offsetPtCount;r++){this.progress();let i=(this.m_offsetPts[r].type&x)!==0;i?n||(t=r-1,t-e+1>1&&this.addPart(e,t-e+1)):n&&(e=r-1),n=i}n||(t=this.m_offsetPtCount-1,t-e+1>1&&this.addPart(e,t-e+1))}else{let e=this.m_offsetPtCount-1;e-0>=1&&this.addPart(0,e-0+1)}}}this.m_srcPts.length=0,this.m_srcPtCount=0,this.m_offsetPts.length=0,this.m_offsetPtCount=0}static dotSign(e,t,n,r){let i=t.x-e.x,o=t.y-e.y,c=r.x-n.x,l=r.y-n.y,u=a(i,o,c,l);return s(u)}},T=class{getOperatorType(){return 10108}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!0}executeMany(e,t,n,r,i,a,o){return new E(e,t,n,r,i,a,o)}execute(e,t,n,r,i,a,o){return new E(null,t,n,r,i,a,o).offset(e)}},E=class extends e{constructor(e,t,n,r,i,a,o){super(),this.m_progressTracker=o,this.m_index=-1,this.m_inputGeoms=e,this.m_spatialReference=t,this.m_distance=n,this.m_joins=r,this.m_miterLimit=i,this.m_flattenError=a}tock(){return!0}getRank(){return 1}next(){if(!this.m_inputGeoms)return null;let e;for(;e=this.m_inputGeoms.next();)return this.m_index=this.m_inputGeoms.getGeometryID(),this.offset(e);return null}getGeometryID(){return this.m_index}offset(e){let t;return l(e),t=this.m_flattenError<=0?p(this.m_spatialReference,e,!0).total():this.m_flattenError,g(e,this.m_distance,this.m_joins,this.m_miterLimit,t,this.m_progressTracker)}},D=new T;function O(e,t,n,r,i,a){return D.execute(e,t,n,r,i,a,null)}function k(e,n,r,i,a,o){let s=D.executeMany(new t(e),n,r,i,a,o,null);return Array.from(s)}export{O as n,k as t};
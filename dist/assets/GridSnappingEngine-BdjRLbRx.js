import{CD as e,Cg as t,MC as n,OC as r,Pu as i,Qx as a,Ta as o,kC as s,ob as c,ou as l,vE as u,yg as d}from"./index-BqmCqmfp.js";import"./quatf64-CJzmL3cc.js";import"./vectorStacks-CKtslZxP.js";import"./plane-CTjDePZl.js";import"./dehydratedPoint-Dwb3orme.js";import"./sphere-CicnK0Bn.js";import"./elevationInfoUtils-Df_uYU_q.js";import"./geodesicUtils-DJORTTMv.js";import{d as f,m as p}from"./LineSnappingHint-BAcwqgNT.js";import{t as m}from"./snappingUtils-CbrwOS61.js";import"./constraints-DXu8cqG3.js";import"./SnappingCandidate-BzUm7cf4.js";import"./IntersectionSnappingHint-C3U4Rx6H.js";import{t as h}from"./IntersectionSnappingCandidate-Cv9i7Mdt.js";import{t as g}from"./LineSnappingCandidate-Cp24TJlP.js";import{n as _,r as v,t as y}from"./gridUtils-7cbr2rDG.js";var b=class extends r{constructor(e){super(e),this.options=null}destroy(){this._set(`options`,null)}get grid(){return this.view.grid}get effectiveViewRotation(){return this.grid?.rotateWithMap?0:c(this.view.rotation??0)}get gridRotation(){return c(this.grid?.rotation??0)}get gridCenter(){let{spatialReference:e,grid:n}=this;if(!n||!e||!t(n.center.spatialReference,e))return null;try{let t=d(n.center,e),r=e.isWrappable&&this.view?.center!=null?i(t.x,this.view.center.x,e):t.x;return p(r,t.y,t.z)}catch(e){return u.getLogger(this).errorOnce(`Grid Snapping - Failed to project grid center.`,e),null}}get offsetScaleFactor(){let{pixelsPerStride:e,grid:t}=this;if(!t||!e)return 1;let{majorLineInterval:n,dynamicScaling:r}=t;return n<1?null:y(n,e,r)}get spatialReference(){return this.view.spatialReference}get gridMetersPerStride(){let{grid:e}=this;return e?a(e.spacing,e.units,`meters`):null}get viewMetersPerPixel(){let{viewMetersPerSRUnit:e}=this;return e==null?null:e*o(this.view.scale,this.view.spatialReference)}get viewMetersPerSRUnit(){let{spatialReference:e}=this.view;return this.gridCenter?_(this.gridCenter[0],this.gridCenter[1],e):null}get pixelsPerStride(){let{gridMetersPerStride:e,viewMetersPerPixel:t}=this;return t&&e?e/t:null}get updating(){return this.grid!=null&&this.spatialReference!=null&&this.viewMetersPerSRUnit==null}async fetchCandidates(e,t,n){let{options:r,view:i}=this;if(!r?.effectiveGridEnabled||!i.grid||n.feature?.attributes&&m in n.feature.attributes)return[];let a=n.coordinateHelper.arrayToPoint(e),o=r.distance*(n.pointer===`touch`?r.touchSensitivityMultiplier:1);return this.fetchCandidatesSync(a,o)}fetchCandidatesSync(e,n){let r=[],{grid:i,effectiveViewRotation:a,gridRotation:o,gridCenter:s,viewMetersPerPixel:c,viewMetersPerSRUnit:l,offsetScaleFactor:u,spatialReference:f,gridMetersPerStride:m,pixelsPerStride:_}=this;if(!(i&&c&&l&&s&&f&&u&&m&&_)||!i.dynamicScaling&&_<5||!t(e.spatialReference,f))return r;let v=d(e,f),y=p(v.x,v.y,v.z),b=x(y,-o,s,-a),T=m/l*u,E=S(b,T,s),{shouldSnapX:D,shouldSnapY:O}=C(E,b,n,c,l);if(!D&&!O)return[];let k=p((D?E:b)[0],(O?E:b)[1]),A=x(k,o,s,a),j=x(E,o,s,a);if(O){let e=w(E,b,T,`y`),t=x(e,o,s,a);r.push(new g({lineStart:j,lineEnd:t,targetPoint:A,isDraped:!1}))}if(D){let e=w(E,b,T,`x`),t=x(e,o,s,a);r.push(new g({lineStart:j,lineEnd:t,targetPoint:A,isDraped:!1}))}return D&&O&&r.push(new h(A,r[0],r[1],!1)),r}};e([n({constructOnly:!0})],b.prototype,`view`,void 0),e([n()],b.prototype,`options`,void 0),e([n()],b.prototype,`grid`,null),e([n()],b.prototype,`effectiveViewRotation`,null),e([n()],b.prototype,`gridRotation`,null),e([n()],b.prototype,`gridCenter`,null),e([n()],b.prototype,`offsetScaleFactor`,null),e([n()],b.prototype,`spatialReference`,null),e([n()],b.prototype,`gridMetersPerStride`,null),e([n()],b.prototype,`viewMetersPerPixel`,null),e([n()],b.prototype,`viewMetersPerSRUnit`,null),e([n()],b.prototype,`pixelsPerStride`,null),e([n()],b.prototype,`updating`,null),b=e([s(`esri.views.interactive.snapping.GridSnappingEngine`)],b);var x=(e,t,n,r)=>{let i=f(e[0],e[1],e[2]);return l(i,l(i,i,n,t),n,r)},S=(e,t,n)=>{let r=(e[0]-n[0])/t,i=(e[1]-n[1])/t,a=Math.trunc(r),o=Math.trunc(i),s=Math.round(r%1),c=Math.round(i%1),l=n[0]+(a+s)*t,u=n[1]+(o+c)*t;return p(l,u)},C=(e,t,n,r,i)=>{if(r<=0)return{shouldSnapX:!1,shouldSnapY:!1};let a=(e[0]-t[0])/r,o=(e[1]-t[1])/r;return{shouldSnapX:Math.abs(a*i)<n,shouldSnapY:Math.abs(o*i)<n}},w=(e,t,n,r)=>{if(r===`y`){let r=t[0]>e[0]?1:-1;return p(e[0]+n*r,e[1])}let i=t[1]>e[1]?1:-1;return p(e[0],e[1]+n*i)};export{b as GridSnappingEngine};
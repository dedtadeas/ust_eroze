import{Ax as e,Bg as t,Vg as n,gg as r,yg as i}from"./index-BqmCqmfp.js";var a=class a{constructor(e){this.geometry=e,this.spatialReference=e.spatialReference}export(){return this._exporter(this.coordinates,this.spatialReference)}clone(e){let t=new a(this.geometry);return t.spatialReference=this.spatialReference,t.coordinates=e??this.coordinates.map(e=>e.clone()),t._exporter=this._exporter,t}async project(e,t){if(this.spatialReference.equals(e))return this.clone();await r([{source:this.spatialReference,dest:e}],{signal:t});let a=new n({spatialReference:this.spatialReference,points:this.coordinates.map(e=>[e.x,e.y])}),o=i(a,e);if(!o)return null;let s=this.coordinates.map((e,t)=>{let n=e.clone(),r=o.points[t];return n.x=r[0],n.y=r[1],n}),c=this.clone(s);return c.spatialReference=e,c}static fromGeometry(r){let i=new a(r);if(r instanceof a)return i.coordinates=r.coordinates.map(e=>e.clone()),i._exporter=(e,t)=>{let n=r.clone(e);return n.spatialReference=t,n},i;switch(r.type){case`point`:{let t=r,{hasZ:n,hasM:a}=t;return i.coordinates=n&&a?[new o(t.x,t.y,t.z,t.m)]:n?[new o(t.x,t.y,t.z)]:a?[new o(t.x,t.y,null,t.m)]:[new o(t.x,t.y)],i._exporter=(t,n)=>r.hasM?new e(t[0].x,t[0].y,t[0].z,t[0].m,n):new e(t[0].x,t[0].y,t[0].z,n),i}case`multipoint`:{let e=r,{hasZ:t,hasM:a}=e;return i.coordinates=t&&a?e.points.map(e=>new o(e[0],e[1],e[2],e[3])):t?e.points.map(e=>new o(e[0],e[1],e[2])):a?e.points.map(e=>new o(e[0],e[1],null,e[2])):e.points.map(e=>new o(e[0],e[1])),i._exporter=(e,t)=>r.hasM?new n({points:e.map(e=>[e.x,e.y,e.z??0,e.m??0]),hasZ:!0,hasM:!0,spatialReference:t}):new n({points:e.map(e=>[e.x,e.y,e.z??0]),spatialReference:t}),i}case`polyline`:{let e=r,n=[],a=[],{hasZ:s,hasM:c}=r,l=0;for(let t of e.paths)if(a.push([l,l+t.length]),l+=t.length,s&&c)for(let e of t)n.push(new o(e[0],e[1],e[2],e[3]));else if(s)for(let e of t)n.push(new o(e[0],e[1],e[2]));else if(c)for(let e of t)n.push(new o(e[0],e[1],null,e[2]));else for(let e of t)n.push(new o(e[0],e[1]));return i.coordinates=n,i._exporter=(e,n)=>{let i=r.hasM?e.map(e=>[e.x,e.y,e.z??0,e.m??0]):e.map(e=>[e.x,e.y,e.z??0]),o=a.map(e=>i.slice(e[0],e[1]));return new t({paths:o,hasM:r.hasM,hasZ:!0,spatialReference:n})},i}}}},o=class e{constructor(e,t,n=null,r=null,i=null,a=null){this.x=e,this.y=t,this.z=n,this.m=r,this.tile=i,this.elevationTile=a}clone(){return new e(this.x,this.y,this.z,this.m)}};export{a as t};